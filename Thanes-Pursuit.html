<!//////////////////////////////////////////
//  --- THAINE'S PURSUIT ---
//
//  Copyright (c) Muckytaters 2024
//
//  This program is free software: you can
//  redistribute it and/or modify it under 
//  the terms of the GNU General Public License
//  as published by the Free Software Foundation,
//  either version 3 of the License, or (at your
//  option) any later version.
//
//  This program is distributed in the hope it
//  will be useful, but WITHOUT ANY WARRANTY;
//  without even the implied warranty of MERCHANTABILITY
//  or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU
//  General Public License along with this
//  program. If not, see http://www.gnu.org/license
////////////////////////////////////////////>

<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<title>THANE'S PURSUIT</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script>
// onload = function(){
game = function ( CW ) {

    // Remove color way selection buttons from the HTML document
    document.getElementById( "color_way_select" ).remove();

    ///////////////////////////////////////////
    // PROMPT USER BEFORE PAGE REFRESH/CLOSE
    window.addEventListener(
        'beforeunload',
        (event) => {
            event.preventDefault();
            event.returnValue = '';
        }
    );

    ///////////////////////////////////////////
    // BITWISE CONSTANTS (DO NOT AMMEND)
    const SOLID_LEFT = 1;
    const SOLID_RIGHT = 2;
    const SOLID_TOP = 4;
    const SOLID_BOTTOM = 8;
    const SOLID_ALL = SOLID_LEFT | SOLID_RIGHT | SOLID_TOP | SOLID_BOTTOM;
    const SOLID_ALL_PLAYER_ONLY = 16; 

    ///////////////////////////////////////////
    // DIRECTION CONSTANTS (DO NOT AMMEND)
    const DIR_UP = 0;
    const DIR_LEFT = 1;
    const DIR_DOWN = 2;
    const DIR_RIGHT = 3;
    const DIR_NONE = 4;
    const DIR_REVERSE= [
        DIR_DOWN,
        DIR_RIGHT,
        DIR_UP,
        DIR_LEFT,
        DIR_NONE
    ];
    const DIR_90_CLOCKWISE = [
        DIR_RIGHT,
        DIR_UP,
        DIR_LEFT,
        DIR_DOWN,
        DIR_NONE
    ];
    const DIR_90_ANTI_CLOCKWISE = [
        DIR_LEFT,
        DIR_DOWN,
        DIR_RIGHT,
        DIR_UP,
        DIR_NONE
    ];

    // Directions in radians
    const DIR_RAD_UP = 0;
    const DIR_RAD_LEFT = 3 * Math.PI / 2;
    const DIR_RAD_DOWN = Math.PI;
    const DIR_RAD_RIGHT = Math.PI / 2;
    const DIR_IN_RADS = [
        DIR_RAD_UP,
        DIR_RAD_LEFT,
        DIR_RAD_DOWN,
        DIR_RAD_RIGHT,
        DIR_RAD_UP  // DIR_NONE maps to 'up'
    ];

    ///////////////////////////////////////////
    // INITIAL DECLARATIONS & PREP
    
    // BASIC WINDOW/TIME CHARACTERISTICS
    const CHARS_WIDE = 24;
    const CHARS_HIGH = 16;
    const PX_PER_CHAR_HOZ = 8;
    const PX_PER_CHAR_VERT = 8;
    const FRAME_RATE = 30;
    const POP_UP_MIN_WIDTH_IN_CHARS = 6;
    const POP_UP_MAX_WIDTH_IN_CHARS = CHARS_WIDE - 2;
    const POP_UP_MIN_HEIGHT_IN_CHARS = 6;
    const POP_UP_MAX_HEIGHT_IN_CHARS = CHARS_HIGH - 2;

    // GAME CHARACTERISTICS
    const PLAYER_START_LIVES = 3;
    const PLAYER_START_ARMOR = 5;
    const PLAYER_ARMOR_CEILING = 99; // Limit of display capacity

    // ASCII CODES (SEE MORE IN LEVEL DESIGN SECTION)
    const INVALID_ASCII = 8;
    const PLAYER_CHAR_ASCII = 251;
    const TICK_ASCII = 226;
    const CROSS_ASCII = 227;
    const FX_ONLY_ASCII = 248;
    const NO_MUTE_ASCII = 249;
    const MUTE_ASCII = 250;

    // Pop-up border ASCII codes
    const BORDER_VERT_ASCII = 21;
    const BORDER_HOZ_ASCII = 22;
    const BORDER_SE_ASCII = 23;
    const BORDER_SW_ASCII = 24;
    const BORDER_NW_ASCII = 25;
    const BORDER_NE_ASCII = 26;

    // Get current window dimensions
    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;

    // Calculate number of virtual pixels
    const PIXELS_WIDE = CHARS_WIDE * PX_PER_CHAR_HOZ;
    const PIXELS_HIGH = CHARS_HIGH * PX_PER_CHAR_VERT;

    // Calculate best size for virtual pixels
    const PIXEL_WIDTH = Math.floor( WIDTH / PIXELS_WIDE );  
    const PIXEL_HEIGHT
        = Math.floor( 
            HEIGHT / ( PIXELS_HIGH + 1 * PX_PER_CHAR_VERT )
        );  
    
    // And then character width
    const CHAR_WIDTH = PIXEL_WIDTH * PX_PER_CHAR_HOZ;
    const CHAR_HEIGHT = PIXEL_HEIGHT * PX_PER_CHAR_VERT;

    // Calculate frame duration in milliseconds
    const FRAME_DURATION = Math.floor( 1000 / FRAME_RATE );

    // Screen to screen transition ticks per char
    const SCREEN_TRANS_TICKS_PER_CHAR = 100;

    // Colo(u)r ways for 4 colo(u)rs (EGA)
    const COL_4_BG = 'black';
    const COL_4_FG_0 = 'white';
    const COL_4_FG_1 = 'cyan';
    const COL_4_FG_2 = 'magenta';

    // Colo(u)r ways for 16 colo(u)rs (CGA)
    const COL_16_BLK = '#000000';
    const COL_16_BLU = '#0000AA';
    const COL_16_GRN = '#00AA00';
    const COL_16_CYN = '#00AAAA';
    const COL_16_RED = '#AA0000';
    const COL_16_MAG = '#AA00AA';
    const COL_16_BRW = '#AA5500';
    const COL_16_LGY = '#AAAAAA';
    const COL_16_DGY = '#555555';
    const COL_16_LBL = '#5555FF';
    const COL_16_LGR = '#55FF55';
    const COL_16_LCY = '#55FFFF';
    const COL_16_LRD = '#FF5555';
    const COL_16_LMG = '#FF55FF';
    const COL_16_YEL = '#FFFF00';
    const COL_16_WHT = '#FFFFFF';

    // Specify colo(u)r way
    // THIS MAY BE CHOSEN EXTERNAL IN FUTURE
    // const CW = true;   // true = 4-way (EGA), false = 16-way (CGA)
    console.log( "Colo(u)r way =", CW ? "EGA" : "CGA" );

    /*
    // Colo(u)r shortcuts
    const COL_BLACK = CW ? COL_4_BG : COL_16_BCK;
    const COL_BLUE = CW ? COL_4_FG_2 : COL_16_BLU;
    const COL_GREEN = CW ? COL_4_FG_1 : COL_16_GRN;
    const COL_CYAN = CW ? COL_4_FG_1 : COL_16_CYN ;
    const COL_RED = CW ? COL_4_FG_2 : COL_16_RED;
    const COL_MAGENTA = CW ? COL_4_FG_2 : COL_16_MAG ;
    const COL_BROWN = CW ? COL_4_FG_1 : COL_16_BRW ;
    const COL_LIGHT_GRAY = CW ? COL_4_FG_1 : COL_16_LGY ;
    const COL_DARK_GRAY = CW ? COL_4_FG_1 : COL_16_DGY ;
    const COL_LIGHT_BLUE = CW ? COL_4_FG_1 : COL_16_LBL ;
    const COL_LIGHT_GREEN = CW ? COL_4_FG_1 : COL_16_LGR ;
    const COL_LIGHT_CYAN = CW ? COL_4_FG_1 : COL_16_LCY ;
    const COL_LIGHT_RED = CW ? COL_4_FG_1 : COL_16_LRD ;
    const COL_LIGHT_MyAGENTA = CW ? COL_4_FG_2 : COL_16_LMG ;
    const COL_YELLOW = CW ? COL_4_FG_0 : COL_16_YEL ;
    const COL_WHITE = CW ? COL_4_FG_0 : COL_16_WHT ;
    */

    // Colo(u)r definitions
    // Note: see level design section for enemy colo(u)r defs
    const DEFAULT_BG_COL = CW ? COL_4_BG : COL_16_BLK;
    const DEFAULT_FG_COL = CW ? COL_4_FG_0 : COL_16_WHT;
    const PLAYER_COL = CW ? COL_4_FG_0 : COL_16_WHT;
    const DEFAULT_ENEMY_OVERLAY_COL = CW ? COL_4_FG_0 : COL_16_RED;
    const DEFAULT_BORDER_COL = CW ? COL_4_FG_1 : COL_16_CYN;
    const FLASH_BORDER_COL = CW ? COL_4_FG_2 : COL_16_MAG;
    const STAT_BG_COL = DEFAULT_BORDER_COL;
    const STAT_LIVES_COL = CW ? COL_4_BG : COL_16_WHT;
    const STAT_ARMOR_COL = CW ? COL_4_BG : COL_16_BLK; 
    const STAT_NUM_COL = DEFAULT_FG_COL; 
    const STAT_TIMER_FG_COL = CW ? COL_4_FG_2 : COL_16_RED; 
    const STAT_TIMER_BG_COL = CW ? COL_4_FG_0 : COL_16_WHT; 
    const STAT_ALERT_FG_COL = CW ? COL_4_BG : COL_16_BLK;
    const STAT_ALERT_BG_COL = CW ? COL_4_FG_1 : COL_16_CYN;
    const POP_UP_BG_COL = DEFAULT_BG_COL;
    const POP_UP_TEXT_COL = CW ? COL_4_FG_1 : COL_16_CYN;
    const POP_UP_TITLE_COL = CW ? COL_4_FG_2 : COL_16_MAG;
    const POP_UP_FOOTER_COL = CW ? COL_4_FG_2 : COL_16_MAG;
    const POP_UP_BORDER_COL = CW ? COL_4_FG_0 : COL_16_WHT;

    // Text colo(u)r used for game intro screens
    const INTRO_TEXT_COL = CW ? COL_4_FG_1 : COL_16_WHT;
    const INTRO_FOOTER_COL = CW ? COL_4_FG_2 : COL_16_MAG;


    // Declare (empty) 2D arrays to hold characters
    const chars = [];  // Main play area
    const sb_chars = [];  // Stat bar

    // Create (empty) array to keep a reference to all sprites
    let all_sprites = new Set;

    // Create (empty) array to keep a reference to enemy sprites
    let enemy_sprites = new Set;

    // Create (empty) array to keep a reference to blocking sprites
    let blocking_sprites = new Set;

    // Create (empty) array to keep a reference to collectable sprites
    let collectable_sprites = new Set;

    // Max number of player missiles available on-screen at one time
    const DEFAULT_MAX_PLAYER_MISSILES = 3;

    const DEFAULT_PLAYER_TICKS_PER_LAUNCH = 330;

    // Max number of enemy missiles available on-screen at one time
    const DEFAULT_MAX_ENEMY_MISSILES = 64;

    // Keep track of enemy types player has met
    let known_enemy_types = new Set();

    // Keep track of new enemy types for which pop-ups
    // need to be created
    let new_enemy_types = new Set();

    // Keep track of collectable types player has met
    let known_collectable_types = new Set();

    // Keep track of new collectable types for which pop-ups
    // need to be created
    let new_collectable_types = new Set();

    // Keep track of tips given to player
    let game_tips_given = new Set();

    // Flag to indicate whether game tips should be displayed
    let game_tips = true;

    // Minimum number of ticks (ms) between player moves
    const DEFAULT_PLAYER_TICKS_PER_MOVE = 125;
    let player_ticks_per_move = DEFAULT_PLAYER_TICKS_PER_MOVE;
   
    // Number of bonus move increments (for stat bar)
    let player_move_bonus = 0;

    const DEFAULT_TICKS_PER_FALL = 250;
    let player_ticks_per_fall = DEFAULT_TICKS_PER_FALL;

    // Declare missile managers (created in 'draw_level_sprites')
    let player_missile_man = 0;
    let splat_missile_man = 0;

    // Keeps track of player's range bonus
    let player_range_bonus = 0;

    // Keeps track of player's missile speed/
    let player_missile_speed_bonus = 0;

    // Player launch interval
    let player_ticks_per_launch = DEFAULT_PLAYER_TICKS_PER_LAUNCH;

    // Create (initially zero) variable to store main loop interval ID;
    let main_loop_interval_id = 0;

    // Flag to track if key handler is on
    let key_handler_on = false;

    // Enumerate game states
    const GAME_STATE_TITLE = 0;
    const GAME_STATE_BLERB = 1;
    const GAME_STATE_MENU = 2;
    const GAME_STATE_INSTRUCTIONS_1 = 3;
    const GAME_STATE_INSTRUCTIONS_2 = 4;
    const GAME_STATE_INSTRUCTIONS_3 = 5;
    const GAME_STATE_INSTRUCTIONS_4 = 6;
    const GAME_STATE_SELECT_LEVEL = 7;
    const GAME_STATE_ABOUT = 8;
    const GAME_STATE_LEVEL_INTRO = 9;
    const GAME_STATE_BUILDING_LEVEL = 10;
    const GAME_STATE_IN_PLAY = 11;
    const GAME_STATE_PLAY_PAUSED = 12;
    const GAME_STATE_QUIT_OPTION = 13;
    const GAME_STATE_RESTART_OPTION = 14;
    const GAME_STATE_LOST_LIFE = 15;
    const GAME_STATE_COMPLETED_LEVEL = 16;
    const GAME_STATE_BONUS_FINISHED = 17;
    const GAME_STATE_HIT_ANY_KEY_TO_PLAY = 18;
    const GAME_STATE_GAME_OVER = 19;
    const GAME_STATE_GAME_COMPLETED_WITH_CHEATS = 20;
    const GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS = 21;
    const GAME_STATE_GAME_COMPLETED_SEQUENCE = 22;
    const GAME_STATE_AWAITING_MOUSE_CLICK = 23;
    const GAME_STATE_POP_UP = 23;
    const GAME_STATE_PAUSE_MENU = 24;
    const GAME_STATE_AWAITING_RESTART = 25;
    const GAME_STATE_MAX = 26;

    // Enumerate mute states
    const MUTE_STATUS_FULL_AUDIO = 0;
    const MUTE_STATUS_FX_ONLY = 1;
    const MUTE_STATUS_MUTE_ALL = 2;
    const MUTE_STATUS_MAX = 3;

    // Stat bar parameters
    const STAT_BAR_EMPTY_ASCII = 32;
    const STAT_BAR_LEVEL_DIGITS = 2;
    const STAT_BAR_LIVES_MAX = 5;
    const STAT_BAR_LIVES_ASCII = PLAYER_CHAR_ASCII;
    const STAT_BAR_ARMOR_DIGITS = 2;
    const STAT_BAR_ARMOR_ASCII = 239;
    const STAT_BAR_RANGE_DIGITS = 1;
    const STAT_BAR_RATE_DIGITS = 1;
    const STAT_BAR_MOVE_DIGITS = 1;
    // const STAT_BAR_SCORE_DIGITS = 5;
    const STAT_BAR_TIMER_DIGITS = 3;
    const STAT_BAR_TIMER_INTERVAL_IN_MS = 3000;
    const STAT_BAR_FLASH_ONCE_TICKS = 250;
    const STAT_BAR_FLASH_CONTINUAL_TICKS = 500;

    // Non-printable ASCII characters
    const CHAR_COPYRIGHT = String.fromCharCode( 255 );
    const CHAR_UP = String.fromCharCode( 221 );
    const CHAR_LEFT = String.fromCharCode( 224 );
    const CHAR_DOWN = String.fromCharCode( 223 );
    const CHAR_RIGHT = String.fromCharCode( 222 );

    // Length (in milliseconds) of short delay
    // before checking for key entry 
    const KEY_ENTRY_DELAY = 50;

    // Length (in milliseconds) of short delay
    // before pop-up appears
    const POP_UP_DELAY = 200;

    // Length (in milliseconds) of delay after
    // player loses life
    const ACTION_PAUSE_DELAY = 1000;

    //! Flag used to delay key response
    let key_handling_delay = false;    

    // Track current game state
    let game_state = GAME_STATE_TITLE; 

    // Track audio mute status
    let audio_mute = MUTE_STATUS_FULL_AUDIO;

    // Track current level number
    let current_level = 0;

    // Track highest level achieved
    let max_level_achieved = 0;

    // Remember start level
    let start_level = 0;

    // Track current screen within level
    let current_screen_i = 0;
    let current_screen_j = 0;

    // Track items collected within level
    // (this prevents collected items
    //  reappearing when a screen is revisited)
    let ignore_coord_list = new Set();

    // Certain ASCII codes represent NPC
    // (non-player characters, i.e. player allies)
    // These need to be treated differently to
    // ordinary non-printable ascii code level furniture,
    // as they must be made solid
    let npc_ascii_codes = new Set();
    npc_ascii_codes.add( 206 ); // Old man
    npc_ascii_codes.add( 205 ); // Lady Muckford
    npc_ascii_codes.add( 204 ); // Faitful servant
    npc_ascii_codes.add( 199 ); // Corpse
    npc_ascii_codes.add( 191 ); // Lord Muckford
    npc_ascii_codes.add( 240 ); // Skull
    npc_ascii_codes.add( 230 ); // Prisoner

    // Map pixels for current level,
    // each pixel representing one character square
    let level_map_pixels = [];

    // Colo(u)rs for level map
    const LEVEL_MAP_BG_COL = DEFAULT_BG_COL;
    const LEVEL_MAP_PLATFORM_COL = CW ? COL_4_FG_0 : COL_16_WHT;
    const LEVEL_MAP_LADDER_COL = CW ? COL_4_FG_1 : COL_16_CYN;
    const LEVEL_MAP_SPEC_COL = CW ? COL_4_FG_2 : COL_16_MAG;

    // Track player lives left
    let player_lives = PLAYER_START_LIVES;

    // Track player armo(u)r
    let player_max_armor = PLAYER_START_ARMOR;
    let player_armor_remaining = player_max_armor;

    // Level timer (seconds left to complete level)
    let level_timer = 0;
    
    // Starting value of level timer
    let level_timer_max = 0;

    // Level timer reference ticks (used to calc value of timer)
    let level_timer_reference_ticks = 0;

    // Time (in ms) spent in pause mode this level
    let level_pause_total_ticks = 0;

    // Remember ticks when game put into pause mode
    let level_pause_ticks = 0;

    // Remember player start position
    let player_start_char_i= 0;
    let player_start_char_j = 0;

    // Remember 1st digit used to select level
    const NO_DIGIT_SELECTED = -1;
    let select_level_first_digit = NO_DIGIT_SELECTED;

    // Remember letters used to enter cheat code
    const CHEAT_CODE_LEN = 8;
    let cheat_code_alpha = [];
    for( let n = 0; n < CHEAT_CODE_LEN; n++ )
    {
        cheat_code_alpha.push( NO_DIGIT_SELECTED );
    }
    
    // Create (initially NULL) reference to 'div' to hold
    // all sprite 'div's
    let top_sprite_div = 0;

    // Create (initially NULL) reference to 'div' to hold
    // all parked missiles (this 'div' will be disabled)
    let parking_div = 0;

    // Create (initially NULL) reference to player sprite
    let player_sprite = 0;

    // Create player score
    // Note: this is not a member of 'player_sprite' object
    //       because this value transcends individual levels,
    //       and 'player_sprite' is recreated with every level.
    let player_score = 0;

    // Create player high score
    let player_hi_score = 0;

    // Reference to current boss sprite, if any.
    let current_boss_sprite = 0;

    // Keep track of milliseconds at *previous* animation frame
    // Note: negative value indicates there is no previous frame
    let prev_ticks = -1;

    // Create (initially NULL) reference to sprite
    // that leaves a scent trail. If zero, no sprite
    // leaves a scent trail
    let scent_sprite = 0;

    // (optional) custom colo(u)r palette
    let custom_colors = {};

    // Create top-level 'div' covering whole window
    const top_div = document.createElement( "div" );
    top_div.id = "div_id" ;
    top_div.className = "div_class";
    top_div.style.width = "100%";
    top_div.style.height = "100%";
    document.body.appendChild( top_div );

    // Create pop-up 'div' covering whole window
    // (initially hidden)
    const pop_up_div = document.createElement( "div" );
    pop_up_div.id = "pop_up_div_id" ;
    pop_up_div.className = "div_class";
    pop_up_div.style.width = "100%";
    pop_up_div.style.height = "100%";
    pop_up_div.style.visibility = 'hidden';
    document.body.appendChild( pop_up_div );

    // Set default border colo(u)r
    document.body.style.background = DEFAULT_BORDER_COL;

    // Calculate hoz/vert padding
    const PAD_LEFT
        = Math.floor( 
            ( WIDTH - CHAR_WIDTH * CHARS_WIDE ) / 2
        );
    // Note: height of one char added here to account for stat line
    const PAD_TOP
        = Math.floor( 
            ( HEIGHT - CHAR_HEIGHT * ( CHARS_HIGH - 1 ) ) / 2
        );

    console.log( "Inner window dims:", WIDTH, HEIGHT,
                 "Virtual pixel dims (in screen pixels):",
                    PIXEL_WIDTH, PIXEL_HEIGHT,
                 "Char dims (in screen pixels):",
                    CHAR_WIDTH, CHAR_HEIGHT,
                 "Active window dims (exc. stat bar):",
                    CHARS_WIDE * CHAR_WIDTH,
                    CHARS_HIGH * CHAR_HEIGHT,
                 "Active window dims (inc. stat bar):",
                    CHARS_WIDE * CHAR_WIDTH,
                    ( CHARS_HIGH + 1 ) * CHAR_HEIGHT,
                 "Padding:", PAD_LEFT, PAD_TOP );
   
    // CREATE CANVASES....

    // Main character canvas
    const CANV_CHARS = document.createElement( 'canvas' );
    CANV_CHARS.id = 'main_char_canvas';
    const TOTAL_CHAR_WIDTH 
            = CANV_CHARS.width = CHARS_WIDE * CHAR_WIDTH;
    const TOTAL_CHAR_HEIGHT 
           = CANV_CHARS.height = CHARS_HIGH * CHAR_HEIGHT;
    CANV_CHARS.style.position = "absolute";
    CANV_CHARS.style.left = PAD_LEFT + "px";
    CANV_CHARS.style.top = PAD_TOP + "px";
    top_div.appendChild( CANV_CHARS );

    // Stat bar canvas
    const CANV_SB = document.createElement( 'canvas' );
    CANV_SB.id = 'stat_bar_canvas';
    const STAT_BAR_WIDTH 
            = ( CANV_SB.width = CHARS_WIDE * CHAR_WIDTH );
    const STAT_BAR_HEIGHT 
           = ( CANV_SB.height = CHAR_HEIGHT );
    CANV_SB.style.position = "absolute";
    CANV_SB.style.left = PAD_LEFT + "px";
    CANV_SB.style.top = ( PAD_TOP - CHAR_HEIGHT ) + "px";
    top_div.appendChild( CANV_SB );

    // Pop-up canvas
    const CANV_POP = document.createElement( 'canvas' );
    CANV_POP.id = 'pop_up_canvas';
    const CANV_POP_WIDTH
            = ( CANV_POP.width = CHARS_WIDE * CHAR_WIDTH );
    const CANV_POP_HEIGHT
           = ( CANV_POP.height = CHARS_HIGH * CHAR_HEIGHT );
    CANV_POP.style.position = "absolute";
    CANV_POP.style.left = PAD_LEFT + "px";
    CANV_POP.style.top = PAD_TOP + "px";
    pop_up_div.appendChild( CANV_POP );

    // CREATE 2D CANVAS CONTEXTS
    const CANV_CHARS_CTX = CANV_CHARS.getContext('2d');
    const CANV_SB_CTX = CANV_SB.getContext('2d');
    const CANV_POP_CTX = CANV_POP.getContext('2d');

    // AUDIO CONSTANTS AND REFERENCES
    const AUDIO_DEFAULT_GAIN = 0.05;  // Default volume when unmuted
    const AUDIO_THEME_IN_GAME_GAIN = 4.0; // Relative volume of in-game theme

    // Intialize audio (see also the 'init_audio' function)
    const AUDIO = new Audio();
    
    // AUDIO COMPONENTS
    // (populated during audio init)

    // Audio context reference (initially set to zero)
    // This is set in 'init_audio'
    let audio_context = 0;

    let audio_theme_oscillator = 0;

    // Audio gain (volume) references (initially set to zero)
    // These are set in 'init_audio'
    let audio_master_gain = AUDIO_DEFAULT_GAIN;
    let audio_theme_gain = 0;

    // Current callback for theme (if zero, theme is not playing)
    let audio_theme_callback = 0;


    ///////////////////////////////////////////
    // GRAPHIC DATA

    // Note: This ASCII data is adapted from the MuckyVision3
    //       game engine (by the same author, also GPL3):
    //          https://github.com/MuckyTaters/MuckyVision3
    //
    // Note 2: Empty arrays here represent ASCII values not used
    //         in this game. Feel free to make use of them.

    const ASCII_DATA = [
    [],[],[],[], // 0-3  Not used
    [ // 4
    0b11111111, // Right Ledge
    0b11111110,
    0b11110000,
    0b11000000,
    0b11000000,
    0b10000000,
    0b10000000,
    0b00000000
    ],
    [ // 5
    0b11101110, // Roof tile
    0b11101110,
    0b01000100,
    0b00000000,
    0b10111011,
    0b10111011,
    0b00010001,
    0b00000000
    ],
    [ // 6
    0b11111111, // Left Ledge
    0b01111111,
    0b00011111,
    0b00000011,
    0b00000011,
    0b00000001,
    0b00000001,
    0b00000000
    ],
    [ // 7
    0b01001001,
    0b10010010,
    0b00100100,
    0b01001001,
    0b10010010,
    0b00100100,
    0b01001001,
    0b10010010
    ],
    [ // 8
    0b10011001,  // ALSO USED AS INVALID MARKER
    0b00110011,
    0b01100110,
    0b11001100,
    0b10011001,
    0b00110011,
    0b01100110,
    0b11001100
    ],
    [ // 9
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01000000,
    0b10000000
    ],
    [],[],[],[],[],  // 10 - 14   Not used      
    [ // 15
    0b01111100,
    0b10000010,
    0b11111110,
    0b10101010,
    0b10101010,
    0b10101010,
    0b01111100,
    0b00000000   // Barrel
    ],
    [ // 16
    0b11111111,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b11111111
    ],
    [ // 17
    0b11111111,  // Grate
    0b10000001,
    0b11111111,
    0b10000001,
    0b11111111,
    0b10000001,
    0b11111111,
    0b00000000
    ],
    [ // 18
    0b10101010,  // Portculis
    0b11111110,
    0b10101010,
    0b11111110,
    0b10101010,
    0b11111110,
    0b10101010,
    0b00000000
    ],
    [ // 19
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000
    ],
    [ // 20
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010
    ],
    [ // 21
    0b00101000,
    0b00101000,
    0b00101000,
    0b00101000,
    0b00101000,
    0b00101000,
    0b00101000,
    0b00101000
    ],
    [ // 22
    0b00000000,
    0b00000000,
    0b11111111,
    0b00000000,
    0b11111111,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 23
    0b00000000,
    0b00000000,
    0b00111111,
    0b00100000,
    0b00101111,
    0b00101000,
    0b00101000,
    0b00101000
    ],
    [ // 24
    0b00000000,
    0b00000000,
    0b11111000,
    0b00001000,
    0b11101000,
    0b00101000,
    0b00101000,
    0b00101000
    ],
    [ // 25
    0b00101000,
    0b00101000,
    0b11101000,
    0b00001000,
    0b11111000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 26
    0b00101000,
    0b00101000,
    0b00101111,
    0b00100000,
    0b00111111,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [],[],[],[],[],  // 27-31   Not used
    [ // 32
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 33
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00000000
    ],
    [ // 34
    0b00010100,
    0b00010100,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 35
    0b00010100,
    0b00010100,
    0b01111111,
    0b00010100,
    0b01111111,
    0b00010100,
    0b00010100,
    0b00000000
    ],
    [ // 36
    0b00001000,
    0b00111111,
    0b01001000,
    0b00111110,
    0b00001001,
    0b01111110,
    0b00001000,
    0b00000000
    ],
    [ // 37
    0b01110001,
    0b01010010,
    0b01110100,
    0b00001000,
    0b00010111,
    0b00100101,
    0b01000111,
    0b00000000
    ],
    [ // 38
    0b00111100,
    0b01000010,
    0b00110100,
    0b01001000,
    0b01000100,
    0b01000010,
    0b00111101,
    0b00000000
    ],
    [ // 39
    0b00011000,
    0b00001000,
    0b00010000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 40
    0b00000100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000100,
    0b00000000
    ],
    [ // 41
    0b00010000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00010000,
    0b00000000
    ],
    [ // 42
    0b00001000,
    0b01001001,
    0b00101010,
    0b00011100,
    0b00101010,
    0b01001001,
    0b00001000,
    0b00000000
    ],
    [ // 43
    0b00000000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00001000,
    0b00001000,
    0b00000000,
    0b00000000
    ],
    [ // 44
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00011000,
    0b00001000,
    0b00010000
    ],
    [ // 45
    0b00000000,
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 46
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 47
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01000000,
    0b00000000
    ],
    [ // 48
    0b00111110,
    0b01000011,
    0b01000101,
    0b01001001,
    0b01010001,
    0b01100001,
    0b00111110,
    0b00000000
    ],
    [ // 49
    0b00001000,
    0b00011000,
    0b00101000,
    0b01001000,
    0b00001000,
    0b00001000,
    0b01111111,
    0b00000000
    ],
    [ // 50
    0b00111110,
    0b01000001,
    0b00000001,
    0b00111110,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 51
    0b00111110,
    0b01000001,
    0b00000001,
    0b00011110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 52
    0b00011100,
    0b00100100,
    0b01000100,
    0b01000100,
    0b01111111,
    0b00000100,
    0b00000100,
    0b00000000
    ],
    [ // 53
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 54
    0b00111110,
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 55
    0b01111111,
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 56
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 57
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 58
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 59
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00110000,
    0b00000000
    ],
    [ // 60
    0b00000011,
    0b00001100,
    0b00110000,
    0b01000000,
    0b00110000,
    0b00001100,
    0b00000011,
    0b00000000
    ],
    [ // 61
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 62
    0b11000000,
    0b00110000,
    0b00001100,
    0b00000010,
    0b00001100,
    0b00110000,
    0b11000000,
    0b00000000
    ],
    [ // 63
    0b00111110,
    0b01000001,
    0b00000001,
    0b00011110,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 64
    0b00111110,
    0b01000001,
    0b01011111,
    0b01010001,
    0b01011111,
    0b01000000,
    0b00111110,
    0b00000000
    ],
    [ // 65
    0b00011100,
    0b00100010,
    0b01000001,
    0b01111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 66
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b00000000
    ],
    [ // 67
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 68
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01111110,
    0b00000000
    ],
    [ // 69
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 70
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 71
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000111,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 72
    0b01000001,
    0b01000001,
    0b01000001,
    0b01111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 73
    0b01111111,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b01111111,
    0b00000000
    ],
    [ // 74
    0b01111111,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b01000100,
    0b00111000,
    0b00000000
    ],
    [ // 75
    0b01000001,
    0b01000010,
    0b01000100,
    0b01111000,
    0b01000100,
    0b01000010,
    0b01000001,
    0b00000000
    ],
    [ // 76
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 77
    0b01000001,
    0b01100011,
    0b01010101,
    0b01001001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 78
    0b01000001,
    0b01100001,
    0b01010001,
    0b01001001,
    0b01000101,
    0b01000011,
    0b01000001,
    0b00000000
    ],
    [ // 79
    0b00111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 80
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 81
    0b00111110,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01000101,
    0b01000010,
    0b00111101,
    0b00000000
    ],
    [ // 82
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 83
    0b00111110,
    0b01000001,
    0b01000000,
    0b00111110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 84
    0b01111111,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 85
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 86
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00000000
    ],
    [ // 87
    0b01000001,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01010101,
    0b01100011,
    0b01000001,
    0b00000000
    ],
    [ // 88
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00010100,
    0b00100010,
    0b01000001,
    0b00000000
    ],
    [ // 89
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 90
    0b01111111,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01111111,
    0b00000000
    ],
    [ // 91
    0b00011100,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00011100,
    0b00000000
    ],
    [ // 92
    0b01000000,
    0b00100000,
    0b00010000,
    0b00001000,
    0b00000100,
    0b00000010,
    0b00000001,
    0b00000000
    ],
    [ // 93
    0b00011100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00011100,
    0b00000000
    ],
    [ // 94
    0b00001000,
    0b00010100,
    0b00100010,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 95
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b01111111,
    0b00000000
    ],
    [ // 96
    0b00011000,
    0b00010000,
    0b00001000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 97
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000001,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 98
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 99
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 100
    0b00000001,
    0b00000001,
    0b00111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 101
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01111111,
    0b01000000,
    0b00111110,
    0b00000000
    ],
    [ // 102
    0b00001111,
    0b00010000,
    0b00010000,
    0b01111111,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00000000
    ],
    [ // 103
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 104
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 105
    0b00001000,
    0b00000000,
    0b00111000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00000000
    ],
    [ // 106
    0b00000100,
    0b00000000,
    0b00011100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00111000,
    0b00000000
    ],
    [ // 107
    0b01000000,
    0b01000000,
    0b01000001,
    0b01000010,
    0b01111100,
    0b01000010,
    0b01000001,
    0b00000000
    ],
    [ // 108
    0b00001100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00000000
    ],
    [ // 109
    0b00000000,
    0b00000000,
    0b01110110,
    0b01001001,
    0b01001001,
    0b01001001,
    0b01001001,
    0b00000000
    ],
    [ // 110
    0b00000000,
    0b00000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 111
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 112
    0b00000000,
    0b00000000,
    0b01111110,
    0b01000001,
    0b01111110,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 113
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00000001,
    0b00000000
    ],
    [ // 114
    0b00000000,
    0b00000000,
    0b01011110,
    0b01100001,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 115
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000000,
    0b00111110,
    0b00000001,
    0b01111110,
    0b00000000
    ],
    [ // 116
    0b00000000,
    0b00100000,
    0b01111110,
    0b00100000,
    0b00100000,
    0b00100010,
    0b00011100,
    0b00000000
    ],
    [ // 117
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 118
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00000000
    ],
    [ // 119
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01010101,
    0b00100010,
    0b00000000
    ],
    [ // 120
    0b00000000,
    0b00000000,
    0b01000001,
    0b00110110,
    0b00001000,
    0b00110110,
    0b01000001,
    0b00000000
    ],
    [ // 121
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01111111,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 122
    0b00000000,
    0b00000000,
    0b01111111,
    0b00000010,
    0b00011100,
    0b00100000,
    0b01111111,
    0b00000000
    ],
    [ // 123
    0b00000110,
    0b00001000,
    0b00001000,
    0b00010000,
    0b00001000,
    0b00001000,
    0b00000110,
    0b00000000
    ],
    [ // 124
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 125
    0b00110000,
    0b00001000,
    0b00001000,
    0b00000100,
    0b00001000,
    0b00001000,
    0b00110000,
    0b00000000
    ],
    [ // 126
    0b00000000,
    0b00000000,
    0b00111001,
    0b01001110,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    // These are unused
    [],[],[],[],[],  // 127 - 131
    [ // 132
    0b00000000,
    0b00100010,
    0b00000000,
    0b00111101,
    0b01000011,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 133
    0b11111110,  // Armo(u)r enhance +1
    0b11101110,
    0b11000110,
    0b11101110,
    0b11111110,
    0b01111100,
    0b00111000,
    0b00000000
    ],
    [ // 134
    0b11111110,  // Armo(u)r enhance +2
    0b11011110,
    0b10001110,
    0b11010110,
    0b11100010,
    0b01110100,
    0b00111000,
    0b00000000
    ],
    [ // 135
    0b11111110,  // Armo(u)r enhance +3
    0b10111010,
    0b00010000,
    0b10101010,
    0b11000110,
    0b01101100,
    0b00111000,
    0b00000000
    ],
    [ // 136
    0b11111110,  // Armo(u)r repair +1
    0b11101110,
    0b11001110,
    0b11101110,
    0b01101100,
    0b01000100,
    0b00111000,
    0b00000000
    ],
    [ // 137
    0b11111110,  // Armo(u)r repair +2
    0b11000110,
    0b11110110,
    0b11000110,
    0b01011100,
    0b01000100,
    0b00111000,
    0b00000000
    ],
    [ // 138
    0b11111110,  // Armo(u)r repair +3
    0b11000110,
    0b11110110,
    0b11100110,
    0b01110100,
    0b01000100,
    0b00111000,
    0b00000000
    ],
    [  // 139
    0b00000110,  // Inc weapon range
    0b00001110,
    0b00011100,
    0b10111000,
    0b01110000,
    0b11100000,
    0b11010000,
    0b00000000
    ],
    [  // 140
    0b01111100,  // Inc attack rate
    0b00010000,
    0b01101100,
    0b11101110,
    0b11100010,
    0b11111110,
    0b01111100,
    0b00000000
    ],
    [  // 141
    0b01111110,  // Inc move speed
    0b01100000,
    0b01111100,
    0b00110000,
    0b00001110,
    0b01111110,
    0b11111110,
    0b00000000
    ],
    [  // 142
    0b11011111,
    0b11011100,
    0b11010001,
    0b00000101,
    0b11101101,
    0b11101101,
    0b11101101,
    0b00001101
    ],
    [  // 143
    0b11101101,
    0b11101101,
    0b11101101,
    0b00001101,
    0b11101101,
    0b11101101,
    0b11101101,
    0b00000000
    ],
    [  // 144
    0b11101111,
    0b00001111,
    0b11000111,
    0b11010000,
    0b11011011,
    0b11011011,
    0b11011011,
    0b11011000
    ],
    [  // 145
    0b11011011,
    0b11011011,
    0b11011011,
    0b11011000,
    0b11011011,
    0b11011011,
    0b11011011,
    0b00000000
    ],
    [  // 146
    0b10111111,  // Solid rock
    0b11011011,
    0b11111101,
    0b11101111,
    0b11110111,
    0b10111111,
    0b11011101,
    0b11111110
    ],
    [ // 147
    0b11100011,
    0b11101011,
    0b11001001,
    0b00011100,
    0b11001001,
    0b11101011,
    0b11101011,
    0b00000000
    ],
    [  // 148
    0b00001000,
    0b00110100,
    0b01011110,
    0b01111010,
    0b00101100,
    0b00011000,
    0b00011000,
    0b00101100
    ],
    [  // 149
    0b00000000,  // Alt bat
    0b00000000,
    0b01110110,
    0b01001001,
    0b00001000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [],[],[],[],[],[],[],[],[],[],  // 150 - 159
    [],[],[],[],[],[],[],[],[],[],  // 160 - 169
    [],[],[],[],[],[],[],[],[],[],  // 170 - 179
    [],[],[],[],[],[],[],  // 180 - 186
    [   // 187
    0b00010000,  // Throne 1
    0b10101010,
    0b11000110,
    0b11101110,
    0b10111010,
    0b11101110,
    0b11101110,
    0b10111010
    ],
    [   // 188
    0b11101111,  // Throne 2
    0b11101111,
    0b10111011,
    0b11101111,
    0b11101110,
    0b11000110,
    0b10000100,
    0b11000110
    ],
    [   // 189
    0b11111000,  // Throne 3
    0b11111000,
    0b01010000,
    0b11110000,
    0b10110000,
    0b00110000,
    0b00010000,
    0b00110000
    ],
    [   // 190
    0b10101000,  // Goblin King
    0b11111000,
    0b11011100,
    0b11110000,
    0b11111100,
    0b11111101,
    0b11111001,
    0b01111111
    ],
    [   // 191
    0b00010100,  // Lord Muckford
    0b00011100,
    0b00111000,
    0b00111000,
    0b00111110,
    0b00101000,
    0b01001000,
    0b01101100
    ],
    [   // 192
    0b11101111,  // Alt brick
    0b11010011,
    0b10111101,
    0b10111110,
    0b01111101,
    0b10111101,
    0b11001011,
    0b11110111,
    ],
    [   // 193
    0b01000000,  // Statue top
    0b10011000,
    0b10011000,
    0b10010000,
    0b01111100,
    0b00111010,
    0b00011010,
    0b00011010,
    ],
    [  // 194
    0b00111100,  // Statue bottom
    0b00111000,
    0b00110000,
    0b00100000,
    0b00110000,
    0b00011000,
    0b01111100,
    0b11111110
    ], 
    [   // 195
    0b00010000,  // Dragon tail segment
    0b01111100,
    0b10000110,
    0b10111110,
    0b10111010,
    0b01111100,
    0b10010010,
    0b01000100
    ],
    [   // 196
    0b10010000,  // Wererat
    0b01001100,
    0b01001110,
    0b01001100,
    0b10011111,
    0b01111000,
    0b10010000,
    0b11011000
    ],
    [   // 197
    0b00101000,  // Paw
    0b10101010,
    0b10000010,
    0b00111000,
    0b01111100,
    0b01111100,
    0b00111000,
    0b00000000
    ],
    [   // 198
    0b00000000,  // Bear
    0b01111010,
    0b11111110,
    0b11111111,
    0b11111110,
    0b11111100,
    0b11001100,
    0b11101110
    ],
    [   // 199
    0b00000000,  // Corpse
    0b00011100,
    0b00101010,
    0b00011100,
    0b10010101,
    0b01100111,
    0b00101001,
    0b11011111
    ],
    [   // 200
    0b00001100,  // Fire
    0b00011000,
    0b00101000,
    0b01010100,
    0b10111010,
    0b10111010,
    0b01010100,
    0b00101000
    ],
    [   // 201
    0b00011000,  // Hammer
    0b00111100,
    0b01111110,
    0b00111111,
    0b00011111,
    0b00101110,
    0b01000100,
    0b10000000
    ],
    [   // 202
    0b00111100,  // Ogre
    0b01110110,
    0b11111110,
    0b11111000,
    0b01111111,
    0b11001100,
    0b11101110,
    0b11101110
    ],
    [   // 203
    0b00000000,  // Giant Rat
    0b00000000,
    0b01000000,
    0b10000000,
    0b10000000,
    0b11000100,
    0b01111110,
    0b00111111
    ],
    [   // 204
    0b00011100,  // Faithful servant
    0b00011100,
    0b00110000,
    0b01110110,
    0b01111110,
    0b01110110,
    0b00110000,
    0b00111000
    ],
    [   // 205
    0b00000000,  // Lady Muckford
    0b00110000,
    0b00010000,
    0b00110000,
    0b00111100,
    0b01110000,
    0b01110000,
    0b01110000
    ],
    [   // 206
    0b00000000,  // Old man
    0b00110000,
    0b00111000,
    0b00011100,
    0b11111110,
    0b10001110,
    0b10001111,
    0b10001111
    ],
    [   // 207
    0b00000000,  // Fire ball
    0b00000000,
    0b00010000,
    0b01001000,
    0b00010010,
    0b00100100,
    0b00000000,
    0b00000000
    ],
    [   // 208
    0b00000000,  // Fire imp
    0b00011000,
    0b11011100,
    0b01100000,
    0b00110000,
    0b01000000,
    0b00000000,
    0b00000000
    ],
    [   // 209
    0b00000100,  // Goblin archer
    0b00000010,
    0b01100010,
    0b11111111,
    0b10110010,
    0b01110010,
    0b10001010,
    0b11001100
    ],
    [   // 210
    0b00000000,  // Goblin
    0b10000000,
    0b10001100,
    0b01111100,
    0b00011010,
    0b00111001,
    0b01000100,
    0b01100110
    ],
    [  // 211
    0b00111100,  // Orc
    0b00011110,
    0b00111100,
    0b01111000,
    0b11111111,
    0b11001000,
    0b10001000,
    0b11101110
    ],
    [  // 212
    0b11010111,  // Fake Solid rock
    0b11110011,
    0b10011111,
    0b11101001,
    0b11111011,
    0b11011111,
    0b10011001,
    0b11111011
    ],
    [ // 213
    0b00110000,  // Scorpion 
    0b01111000,
    0b10000100,
    0b10000000,
    0b11000000,
    0b01100111,
    0b01111100,
    0b10100111
    ],
    [ // 214
    0b00000000,  // Floor trap
    0b00010000,
    0b00111000,
    0b01010100,
    0b00010000,
    0b00010000,
    0b00010000,
    0b11111110
    ],
    [ // 215
    0b00000000,  // Dragon head
    0b10010010,
    0b11111110,
    0b01010100,
    0b01111100,
    0b10101010,
    0b10010010,
    0b01000100,
    ],
    [ // 216
    0b01101100,  // Heart
    0b11111110,
    0b11111110,
    0b11111110,
    0b01111100,
    0b00111000,
    0b00010000,
    0b00000000
    ],
    [ // 217
    0b00001000,  // Droplet
    0b00001000,
    0b00011100,
    0b00011100,
    0b00101110,
    0b01011111,
    0b01111111,
    0b00111110
    ],
    [ // 218
    0b00000000, // Arrow (right facing)
    0b00000000,
    0b10100010,
    0b01111111,
    0b10100010,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 219
    0b00000000, // Arrow (left facing)
    0b00000000,
    0b01000101,
    0b11111110,
    0b01000101,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 220
    0b01100110,  // Bat
    0b11000011,
    0b11111111,
    0b10111101,
    0b10011001,
    0b10000001,
    0b01000010,
    0b00000000
    ],
    [ // 221
    0b00001000,
    0b00011100,
    0b00101010,
    0b01001001,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 222
    0b00001000,
    0b00000100,
    0b00000010,
    0b01111111,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00000000
    ],
    [ // 223
    0b00001000,
    0b00001000,
    0b00001000,
    0b01001001,
    0b00101010,
    0b00011100,
    0b00001000,
    0b00000000
    ],
    [ // 224
    0b00001000,
    0b00010000,
    0b00100000,
    0b01111111,
    0b00100000,
    0b00010000,
    0b00001000,
    0b00000000
    ],
    [ // 225
    0b01111110, // Ghost
    0b11010111,
    0b11111101,
    0b10111101,
    0b10011001,
    0b00011000,
    0b00010000,
    0b00001000
    ],
    [ // 226
    0b00000001,
    0b00000011,
    0b00000110,
    0b00001100,
    0b01011000,
    0b01110000,
    0b00100000,
    0b00000000
    ],
    [ // 227
    0b01000001,
    0b01100011,
    0b00110110,
    0b00011100,
    0b00110110,
    0b01100011,
    0b01000001,
    0b00000000
    ],
    // These are unused
    [],  // 228
    [ // 229
    0b00000100, // baby fire drake
    0b11100111,
    0b01101000,
    0b00110000,
    0b01001000,
    0b10000000,
    0b10010000,
    0b01100000,
    ],
    
    [ // 230
    0b00000000, // Prisoner
    0b00000000,
    0b01100000,
    0b01100000,
    0b11000000,
    0b01110000,
    0b01000100,
    0b01111100,
    ],
    [ // 231
    0b01111010, // Column
    0b01111010,
    0b01111010,
    0b01111010,
    0b01111010,
    0b01111010,
    0b01111010,
    0b01111010,
    ],
    [ // 232
    0b01111111, // Column top left
    0b11000000,
    0b10010111,
    0b11000101,
    0b01111001,
    0b00000001,
    0b00000000,
    0b00000000,
    ],
    [ // 233
    0b11111111, // Column top left
    0b00000000,
    0b11111111,
    0b11111111,
    0b11111111,
    0b11111111,
    0b10000001,
    0b11111111,
    ],
    [ // 234
    0b11111110, // Column top left
    0b00000011,
    0b11101001,
    0b10100010,
    0b10011110,
    0b10000000,
    0b00000000,
    0b00000000,
    ],
    [ // 235
    0b00000000,  // Hand axe
    0b00000100,
    0b00001111,
    0b00011110,
    0b00100100,
    0b01000000,
    0b10000000,
    0b00000000
    ],
    [ // 236
    0b00000000,  // Long sword
    0b00100000,
    0b00100000,
    0b11111111,
    0b00100000,
    0b00100000,
    0b00000000,
    0b00000000
    ],
    [ // 237
    0b00000000,  // Sword
    0b00000000,
    0b00100000,
    0b11111110,
    0b00100000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 238
    0b00000000,  // Short sword
    0b00000000,
    0b00100000,
    0b11111100,
    0b00100000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 239
    0b11111110,  // Shield
    0b10001110,
    0b10001110,
    0b11001110,
    0b01001100,
    0b01101100,
    0b00111000,
    0b00000000
    ],
    [ // 240
    0b00111110,  // Skull
    0b01111111,
    0b01001001,
    0b01101011,
    0b00111110,
    0b00101010,
    0b00000000,
    0b00000000
    ],
    [ // 241
    0b11111111,  // Rock platform
    0b11101110,
    0b01110111,
    0b10111011,
    0b11011101,
    0b10001000,
    0b01000100,
    0b00100010,
    ],
    [ // 242
    0b00000000,  // Clump of Grass
    0b00000000,
    0b00000100,
    0b01001000,
    0b00101000,
    0b00010011,
    0b00010100,
    0b00011000
    ],
    [ // 243
    0b01110110,  // Tree top
    0b11101101,
    0b10110111,
    0b11011101,
    0b01111110,
    0b11010101,
    0b10111111,
    0b01110110,
    ],
    [ // 244
    0b00011000,  // Tree trunk
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00110100,
    0b01010101,
    ],
    [ // 245
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010,
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010
    ],
    [ // 246
    0b11011111,
    0b11011111,
    0b11011111,
    0b00000000,
    0b11111011,
    0b11111011,
    0b11111011,
    0b00000000
    ],
    // This is unused
    [],  // 247
    [  // 248
    0b01110101,  // FX only
    0b01000101,
    0b01000111,
    0b01100010,
    0b01000111,
    0b01000101,
    0b01000101,
    0b00000000
    ],
    [ // 249
    0b00001000,  // Full audio
    0b00001100,
    0b00001110,
    0b00001010,
    0b00001000,
    0b00111000,
    0b00111000,
    0b00000000
    ],
    [ // 250
    0b10001000,  // Full mute
    0b01001100,
    0b00101110,
    0b00011010,
    0b00001000,
    0b00111100,
    0b00111010,
    0b00000001
    ],
    [ // 251
    0b00011000,  // Player image
    0b00011000,
    0b01110000,
    0b01111000,
    0b01111111,
    0b01101000,
    0b11001000,
    0b10001100
    ],
    [ // 252
    0b00000111,  // Collectable image
    0b00000101,
    0b11111101,
    0b10100101,
    0b10100111,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 253
    0b00010000,
    0b00011000,
    0b00110000,
    0b00011000,
    0b00110000,
    0b00011100,
    0b01111000,
    0b00011110
    ],
    [ // 254
    0b01111000,
    0b00011111,
    0b11111000,
    0b00011111,
    0b11111000,
    0b00011000,
    0b00011000,
    0b00011000
    ],
    [ // 255
    0b00111110,
    0b01000001,
    0b01011101,
    0b01010001,
    0b01011101,
    0b01000001,
    0b00111110,
    0b00000000
    ]
    ]

    // ASCII data quality check
    if( ASCII_DATA.length !== 256 )
    {
        console.log( "Fundamental ERROR: ASCII_DATA has length",
                     ASCII_DATA.length,
                     ", should be 256." );
        return;

    }
    for( let n = 0; n < 256; n++ )
    {
        if( typeof ASCII_DATA[n] == "undefined" )
        {
            console.log( "Fundamental ERROR: graphic data for",
                         "ASCII code", n, "is 'undefined', it",
                         "should be either an empty array '[]' or",
                         "an array of length 8." );
            return;
        }
        const NUM_ROWS = ASCII_DATA[n].length;
        if( NUM_ROWS == 0 ) { continue; }
        if( NUM_ROWS !== 8 )
        {
            console.log( "Fundamental ERROR: graphic data for",
                         "ASCII code", n, "has", NUM_ROWS,
                         "row(s), should be zero or 8." );
            return;
        }
        for( let m = 0; m < 8; m++ )
        {
            const VAL = ASCII_DATA[n];
            if( VAL < 0 || VAL > 255 )
            {
                console.log( "Fundamental ERROR: row", m,
                             "of graphic data for ASCII code", n,
                             "has out-of-range value", VAL,
                             ", should be in range 0-255." );
                return;
            }
        }
    }
    console.log( "ASCII graphic data integrity check passed." );

    // Super secret numbers!
    const B1 = 4;
    const B2 = 4;
    const B3 = 4;
    const B4 = 2;
    const B5 = 4;
    const B6 = 6;
    const B7 = 6;
    const B8 = 7;


    const SPEC = [10532,20726,16569,24644,19588,7461,15143,14097,11526];

    // Title screen bitmap
    const TITLE_SCREEN_BITMAP_DATA = [
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 0
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 1
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 2
    0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000, // 3
    0x00000001,0xe0000000,0x00000000,0x00000000,0x00000000,0x00000000, // 4
    0x00000007,0x80000000,0x00000000,0x00000000,0x00000000,0x00000000, // 5
    0x00fffffe,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 6
    0x03fffff8,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 7
    0x0f00c800,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 8
    0x1c00c800,0x00000000,0x00000000,0x00000000,0x000001f8,0x00000000, // 9
    0x1800c800,0x40000000,0x00000000,0x00000000,0x000007f6,0x00000000, // 10
    0x0001c800,0x80000000,0x00000000,0x00000000,0x00000fef,0x80000000, // 11
    0x0003c803,0x00000000,0x00000000,0x00000000,0x00001fdf,0xc0070000, // 12
    0x0006c806,0x00000000,0x00000000,0x00000000,0x00003fbf,0xe00f8000, // 13
    0x0006c80c,0x00000000,0x00000000,0x00000000,0x00007f7f,0xf00f8000, // 14
    0x000cc80c,0x00000000,0x000c0000,0x00000000,0x0000f8ff,0xf8070000, // 15
    0x000cc80c,0x00000000,0x000e0000,0x00000000,0x0001f2fb,0xfc020000, // 16
    0x0018c80c,0x00000000,0x00060000,0x00000000,0x0003e4f5,0xfe050000, // 17
    0x0018c80c,0x00010800,0x00060000,0x00000000,0x0007e9ee,0xff070000, // 18
    0x0018c80c,0x20188410,0x030c0000,0x00000000,0x000fe3df,0x7f850000, // 19
    0x0018c80c,0x703cc638,0x0f806000,0x00000000,0x001fdfb3,0xbf870000, // 20
    0x0038c80c,0xb0e6c658,0x5bc0f000,0x00000000,0x003fbf61,0xdf850000, // 21
    0x0038c80d,0x38c3c69c,0x71e1d800,0x00000000,0x007f7fb8,0xef870000, // 22
    0x0038c80e,0x3cc1c71e,0x60e38800,0x00000000,0x00feffdc,0x77050000, // 23
    0x0038c80c,0x1cc0c60e,0x60c70000,0x00000000,0x01fdffee,0x3a070000, // 24
    0x0038c80c,0x1cc0c60e,0x61830000,0x00000000,0x03c1fff7,0x1c050000, // 25
    0x0038c80c,0x1cc0c60e,0x63018000,0x00000000,0x03001fee,0x08070000, // 26
    0x0038c80c,0x1cc0c60e,0x7e00c000,0x00000000,0x00000fdc,0xc0050000, // 27
    0x0038c80c,0x1cc0c60e,0x70086000,0x00000000,0x3fffe3b9,0xe0070000, // 28
    0x0038c80c,0x1cc0c60e,0x60083000,0x00000000,0xe0177973,0x80006000, // 29
    0x0038881e,0x10c0c608,0x708c7000,0x00000001,0x9ffffc07,0x0007d800, // 30
    0x0039081e,0x30e2e618,0x398ee000,0x00000007,0x7bffffc6,0x000fb000, // 31
    0x003a081c,0x30766218,0x1d07c000,0x0000000c,0xffffe3f0,0x081f6c20, // 32
    0x0038080c,0x607c3330,0x0f038000,0x0000001b,0xffffc608,0x0fdedde0, // 33
    0x00380804,0x403c0020,0x06010000,0x00000037,0xffffcc60,0x081fb020, // 34
    0x001c0808,0x40180020,0x00000000,0x0000006f,0xffff89d8,0x0fdfede0, // 35
    0x000c0838,0x00000000,0x00000000,0x000000ff,0xbfef88fc,0x081ff820, // 36
    0x000e0870,0x00000000,0x00000000,0x000001bf,0xffff9bbb,0x0003f000, // 37
    0x000789e0,0x00000000,0x00000001,0x000003ff,0xffff12df,0x8078f000, // 38
    0x0003ffc0,0x00000000,0x00000002,0x000007fd,0xffff3373,0x6ffe4000, // 39
    0x0000ff80,0x00000000,0x00000002,0x000006ff,0xffff27bf,0xeffe0000, // 40
    0x00003e00,0x00000000,0x00000004,0x000007ff,0xff7f25f6,0xe7fb0000, // 41
    0x00000800,0x00000000,0x0000000c,0x00000fef,0xfffe675f,0xb7f60000, // 42
    0x00000800,0x00000000,0x00000018,0x00000fff,0xfffc47da,0xf7ec8000, // 43
    0x00000800,0x00000000,0x00000018,0x00000fff,0xfffc42ff,0xd3d98000, // 44
    0x001e0880,0x00000000,0x00000838,0x00000fff,0xfdfc47c3,0x7bb18000, // 45
    0x003f09c0,0x00000000,0x00001c38,0x00000fdf,0xfff8437f,0xdb758000, // 46
    0x00438be0,0x00000000,0x00003638,0x00000fff,0xfff8506d,0x0ae58000, // 47
    0x0081cff0,0x00000000,0x00001c38,0x3c000fff,0xf7f8d001,0xfbcd8000, // 48
    0x0001ccf8,0x00000000,0x00000838,0x60000fff,0xfff89000,0x008d8000, // 49
    0x0001c87c,0x00000000,0x00408038,0xc0000eff,0xeff19000,0x000d8000, // 50
    0x0001d83e,0x20820002,0x10304039,0x80000fff,0xfff11000,0x000d8000, // 51
    0x0001e81f,0x10610607,0x081820ff,0x00000fff,0xdfe12000,0x000d8000, // 52
    0x0001c80f,0x98308f0f,0x8c0c31b8,0x00000fff,0xffe17000,0x000d8000, // 53
    0x0001cc0e,0x8c18d79f,0xc60e3b38,0x00000dff,0xffe25000,0x000d8000, // 54
    0x0001cf1e,0x8c1ce3be,0x260e3838,0x00000fff,0xbfc6f000,0x000d8000, // 55
    0x0001c9e6,0x8e1ce1fc,0x170e3838,0x00001fff,0xffc4a000,0x000d8000, // 56
    0x0001c806,0x8e1ce038,0x070e3838,0x00001dfe,0xff99e000,0x000d8000, // 57
    0x0001c806,0x8e1ce018,0x070e3838,0x00001fff,0xffbb4000,0x000d8000, // 58
    0x0001cbf6,0x8e1ce00c,0x070e3838,0x000017fd,0xff35e000,0x000d8000, // 59
    0x0001ee1e,0x8e1ce186,0x070e3838,0x000017fe,0xff36a000,0x000d8000, // 60
    0x0001e806,0x8e1ce3c3,0x070e3838,0x00001fff,0xfa73e000,0x000d8000, // 61
    0x0001f807,0x8e1ce4c1,0x870e3838,0x00003ffa,0xdc7541c0,0x000d8000, // 62
    0x0001f807,0x0e1ce060,0xc70e3838,0x00002fff,0xf0e067e0,0x000d8000, // 63
    0x0001f806,0x0e1ce070,0x670e3838,0x20002ffb,0xa1a70ff0,0x000d8000, // 64
    0x0001de04,0x0e1ce038,0xe70e3838,0xe0002ff6,0xc36fef70,0x000d8000, // 65
    0x0001df08,0x0e3ce01d,0xc716383c,0x80003ffb,0x8ecfe7f0,0x000d8000, // 66
    0x0001cf90,0x0644600f,0x83220c1f,0x80003fee,0x99c0edd0,0x000d8000, // 67
    0x0001cbe0,0x03821007,0x01c1040f,0x00007fd7,0x17c00f70,0x000d8000, // 68
    0x0001c9c0,0x01010802,0x00800006,0x00007f7c,0x3f87eff0,0x000d8000, // 69
    0x0001c880,0x00008000,0x00000000,0x0000fdc0,0xff854560,0x000d8000, // 70
    0x0001c800,0x00000000,0x00000000,0x0000fc03,0xff8fc3f0,0x000d8000, // 71
    0x0001c800,0x00000000,0x00000000,0x0000f87f,0xff15d7f0,0x000d8000, // 72
    0x0001c800,0x00000000,0x00000000,0x0001e1ff,0xff1fd6d0,0x000d8000, // 73
    0x0001c800,0x00000000,0x00000000,0x00ff07ff,0xfc0bd1f0,0x000d8000, // 74
    0x0001c800,0x00000000,0x00000000,0x1fc07fff,0xf83fddd0,0x000d8000, // 75
    0x0001c800,0x00000000,0x000000ff,0xfe0fffff,0xf03fd9f0,0x000d8000, // 76
    0x0001c800,0x00000000,0x00000ffb,0xf07ffff7,0xc0ff9d70,0x000d8000, // 77
    0x0001c800,0x00000000,0x00007f7f,0xe3ffffff,0x019fbce0,0x000d8000, // 78
    0x0001c800,0x00000000,0x0001f7ff,0xc7ffff7c,0x07fface0,0x000d8000, // 79
    0x0001c900,0x00000000,0x000efffc,0x1ffffff0,0x0dffbea0,0x000d8000, // 80
    0x0003fe00,0x00000000,0x003bffe9,0xfffff7e0,0x17ff9660,0x000d8000, // 81
    0x000ffc00,0x00000000,0x0077ff63,0xffff7e00,0x3fffba60,0x000d8000, // 82
    0x00180800,0x00000000,0x01cfefc7,0xff9df803,0x7fff9f60,0x000d8000, // 83
    0x00200800,0x00000000,0x071ffd9f,0xffff8006,0xf7ffbf60,0x000d8000, // 84
    0x00200800,0x00000000,0x0c16ea9f,0xfef6005b,0xffff3760,0x000d8000, // 85
    0x00100800,0x00000000,0x1fffea3f,0xffcc0000,0x00fe3f60,0x000d8000, // 86
    0x00080800,0x00000000,0x1c0f587f,0xf718000a,0xaa7e5b40,0x000d8000, // 87
    0x00000800,0x00000000,0x1007f1ff,0xddb00003,0xbf3dff08,0x000d8000, // 88
    0x00000800,0x00000000,0x1001e3fd,0xffe00000,0xd5015f1f,0x000d8000, // 89
    0x00000800,0x00000000,0x0000f8ff,0x3b000000,0x1f47f3bd,0xe00d8000, // 90
    0x00000800,0x00000000,0x00001c7f,0xee000000,0x007ebb97,0xe00d8000, // 91
    0x00000000,0x00000000,0x00000e3f,0xd8000000,0x005aff9e,0xc00d8000, // 92
    0x00000000,0x00000000,0x00000301,0xb000007e,0x003feb9b,0x000d8000, // 93
    0x00000000,0x00000000,0x000003c0,0x60000043,0x803baf8f,0x000d8000, // 94
    0x00000000,0x00000000,0x000000ff,0xc000008f,0xc02dffcc,0x000d8000, // 95
    0x00000000,0x00000000,0x00000000,0x0000019f,0xe00f7bc0,0x000d8000, // 96
    0x00000000,0x00000000,0x00000000,0x0000031f,0xf8000ec0,0x000d8000, // 97
    0x00000000,0x00000000,0x00000000,0x0000033f,0x0fbf47c0,0x000d8000, // 98
    0x00040384,0x45e0f220,0x00000000,0x000007ff,0x37ebfdc0,0x00050000, // 99
    0x000a040a,0x6d008a20,0x00000000,0x000007f7,0xf03f7840,0x00050000, // 100
    0x00110411,0x55008a20,0x00000000,0x00000efe,0xdfeddf40,0x00070000, // 101
    0x001104d1,0x45c0f1c0,0x00000000,0x00000eff,0xfaffc940,0x00020000, // 102
    0x001f045f,0x45008880,0x00000000,0x00001fff,0xdfbaad40,0x00020000, // 103
    0x00110451,0x45008880,0x00000000,0x00003bff,0x7afffb40,0x00000000, // 104
    0x00110391,0x45e0f080,0x00000000,0x00007ffb,0xdddf7e40,0x00000000, // 105
    0x00000000,0x00000000,0x00000000,0x00007ffa,0xfffbeec0,0x00000000, // 106
    0x00000000,0x00000000,0x00000000,0x0000effa,0x06dfbec0,0x00000000, // 107
    0x00000000,0x00000000,0x00000000,0x0000ffff,0xe3fdf4c0,0x00000000, // 108
    0x00000000,0x00000000,0x00000000,0x0001bfe8,0x3087dec0,0x00000000, // 109
    0x00000000,0x00000000,0x00000000,0x0001ffe8,0x1ffefd80,0x00000000, // 110
    0x00004121,0x1e22441f,0xc63f9f3e,0x1e017fb8,0x0003e100,0x00000000, // 111
    0x00006321,0x21224402,0x09041021,0x21017f70,0x00003f00,0x00000000, // 112
    0x00005521,0x20244402,0x10841021,0x20017ef0,0x00000000,0x00000000, // 113
    0x00004921,0x20384402,0x10841e3e,0x1e01ffe0,0x00000000,0x00000000, // 114
    0x00004121,0x20243802,0x1f841021,0x0101fdc0,0x00000000,0x00000000, // 115
    0x00004121,0x20221002,0x10841021,0x01017b80,0x00000000,0x00000000, // 116
    0x00004121,0x21221002,0x10841021,0x21017b00,0x00000000,0x00000000, // 117
    0x0000411e,0x1e221002,0x10841f21,0x1e017b00,0x00000000,0x3e18c650, // 118
    0x00000000,0x00000000,0x00000000,0x0001bb00,0x00000000,0x41252950, // 119
    0x00000000,0x00000000,0x00000000,0x0001db00,0x00000000,0x5d052150, // 120
    0x00000000,0x00000000,0x00000000,0x0000e300,0x00000000,0x51192650, // 121
    0x00000000,0x00000000,0x00000000,0x00003e00,0x00000000,0x5d212878, // 122
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x41252910, // 123
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x3e3ccf10, // 124
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 125
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 126
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, // 127
    ];

    // END OF GRAPHIC DATA
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // AUDIO DATA

    // Sound effects (FX) data
    // Explainer:
    // type = specifies waveform ( 'square', 'sine', 'triangle', 'sawtooth' )
    // freq = specifies a static frequency
    //    or
    // start_freq / end_freq = specifies a linear frequency ramp
    // dur = specifies duration in ticks (i.e. milliseconds)
    const FX_DATA = {
        'enemy_hit' : { 'type': 'sawtooth', 'start_freq': 200, 'end_freq': 150, 'dur': 150 },
        'player_hit' : { 'type': 'square', 'start_freq': 400, 'end_freq': 100, 'dur': 400 },
        'splat' : { 'type': 'sawtooth', 'start_freq': 200, 'end_freq': 50, 'dur': 400 },
        'launch' : { 'type': 'sine', 'start_freq': 1200, 'end_freq' : 600, 'dur' : 100 },
        'fall' : { 'type': 'square', 'freq': 100, 'dur': DEFAULT_PLAYER_TICKS_PER_MOVE },
        'collect' : { 'type': 'triangle', 'start_freq': 800, 'end_freq': 1600, 'dur': 200  },
        'alert' : { 'type': 'triangle', 'freq': 3200, 'dur': 100 }
    };

    // Note id/duration data for end-of-level fanfare 
    // Note: Note ID 57 is 'tuning A', i.e. 440Hz.
    const AUDIO_FX_FANFARE_DATA = [
        [  57, 500 ],
        [  55, 500 ],
        [  53, 500 ],
        [  59, 1500 ]
    ];

    // Repeating blocks in theme
    const AUDIO_THEME_BLOCK_1 = [
        [ 52, 500 ],  // E
        [ 0, 25 ],
        [ 55, 1000 ],  // G
        [ 0, 25 ],
        [ 57, 500 ], // A
        [ 0, 25 ],
        [ 59, 750 ],  // B
        [ 0, 25 ],
        [ 60, 250 ],  // C
        [ 0, 25 ],
        [ 59, 500 ],  // B
        [ 0, 25 ],
        [ 57, 1000 ],  // A
        [ 0, 25 ],
        [ 54, 500 ],  // F#
        [ 0, 25 ],
        [ 50, 750 ],  // D
        [ 0, 25 ]
    ];

    const AUDIO_THEME_BLOCK_2 = [
        [ 52, 250  ],  // E
        [ 0, 25 ],
        [ 54, 500  ],  // F#
        [ 0, 25 ],
        [ 55, 1000  ],  // G
        [ 0, 25 ],
        [ 52, 500  ],  // E
        [ 0, 25 ],
        [ 52, 750  ],  // E
        [ 0, 25 ],
        [ 51, 250  ],  // D#
        [ 0, 25 ],
        [ 52, 500  ],  // E
        [ 0, 25 ],
        [ 54, 1000  ],  // F#
        [ 0, 25 ],
        [ 51, 500  ],  // D#
        [ 0, 25 ],
        [ 47, 1000  ],  // B
        [ 0, 250 ]
    ];

    const AUDIO_THEME_BLOCK_3 = [
        [ 52, 250  ],  // E
        [ 0, 25 ],
        [ 54, 500  ],  // F#
        [ 0, 25 ],
        [ 55, 750  ],  // G
        [ 0, 25 ],
        [ 54, 250  ],  // F#
        [ 0, 25 ],
        [ 52, 500  ],  // E
        [ 0, 25 ],
        [ 51, 750  ],  // D#
        [ 0, 25 ],
        [ 49, 250  ],  // C#
        [ 0, 25 ],
        [ 51, 500  ],  // D#
        [ 0, 25 ],
        [ 52, 1500  ],  // E
        [ 0, 25 ],
        [ 52, 750  ],  // E
        [ 0, 250 ]
    ];

    const AUDIO_THEME_BLOCK_4 = [
        [ 62, 1250  ],  // D
        [ 0, 25 ],
        [ 62, 750  ],  // D
        [ 0, 25 ],
        [ 60, 250  ],  // C
        [ 0, 25 ],
        [ 59, 500  ],  // B
        [ 0, 25 ],
        [ 57, 1000  ],  // A
        [ 0, 25 ],
        [ 54, 500  ],  // F#
        [ 0, 25 ],
        [ 50, 750  ],  // D
        [ 0, 25 ]
    ];

    // Note id/duration data for intro theme
    // Note: Note ID 57 is 'tuning A', i.e. 440Hz.
    const AUDIO_THEME_DATA = [].concat(
        AUDIO_THEME_BLOCK_1,
        AUDIO_THEME_BLOCK_2,
        AUDIO_THEME_BLOCK_1,
        AUDIO_THEME_BLOCK_3,
        AUDIO_THEME_BLOCK_4,
        AUDIO_THEME_BLOCK_2,
        AUDIO_THEME_BLOCK_4,
        AUDIO_THEME_BLOCK_3,
        [ [ 0, 1000 ] ]
    );
   
    console.log( "AUDIO_THEME_DATA", AUDIO_THEME_DATA );

    // END OF AUDIO DATA
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // LEVEL DESIGN

    // This must match the size of the following arrays:
    // LEVEL_DIMS, LEVEL_END, LEVEL_DATA, LEVEL_PALETTE, LEVEL_INTRO_TEX, TLEVEL_OUTRO_TEXT
    const NUM_LEVELS = 4;

    // Declare ASCII codes displayed on screen
    // for various level components
    const LEVEL_ERROR = 7;  // Indicates unrecognised symbol in level map
    const LEVEL_SPACE = 32;
    const LEVEL_BRICK = 246;
    const LEVEL_HOLLOW_BRICK = 16;
    const LEVEL_FAKE_BRICK = 212;
    const LEVEL_LADDER = 245;
    const LEVEL_TREE_TOP = 243;
    const LEVEL_TREE_TRUNK = 244;
    const LEVEL_GRASS = 242;
    const LEVEL_ROCK_PLATFORM = 146; //  241;
    const LEVEL_SOLID_ROCK = 146;
    const LEVEL_GRATE = 17;
    const LEVEL_PORTCULIS = 18;
    const LEVEL_BARREL = 15;
    const LEVEL_LEFT_LEDGE = 6;
    const LEVEL_ROOF_TILE = 5;
    const LEVEL_RIGHT_LEDGE = 4;
    const LEVEL_ALT_BRICK = 192;
    const LEVEL_THRONE_1 = 187;
    const LEVEL_THRONE_2 = 188;
    const LEVEL_THRONE_3 = 189;

    // ASCII Literals for level maps...

    // Large door
    const D1 = String.fromCharCode( 142 ); 
    const D2 = String.fromCharCode( 143 ); 
    const D3 = String.fromCharCode( 144 ); 
    const D4 = String.fromCharCode( 145 ); 

    // Statue
    const S1 = String.fromCharCode( 193 ); 
    const S2 = String.fromCharCode( 194 ); 

    // Columns
    const C1 = String.fromCharCode( 231 ); 
    const C2 = String.fromCharCode( 232 ); 
    const C3 = String.fromCharCode( 233 ); 
    const C4 = String.fromCharCode( 234 ); 

    // Arrows
    const AU = String.fromCharCode( 221 ); 
    const AR = String.fromCharCode( 222 ); 
    const AD = String.fromCharCode( 223 ); 
    const AL = String.fromCharCode( 224 ); 

    // Battlement loop-hole
    const LH = String.fromCharCode( 147 );  

    // Pine tree
    const P1 = String.fromCharCode( 253 );  
    const P2 = String.fromCharCode( 254 );  

    // Bush
    const BU = String.fromCharCode( 148 );  

    // Fire
    const FI = String.fromCharCode( 200 );

    // NPCs
    const OM = String.fromCharCode( 206 );  // Old man
    const LM = String.fromCharCode( 205 );  // Lady Muckford
    const FS = String.fromCharCode( 204 );  // Faithfully servant
    const CP = String.fromCharCode( 199 );  // Corpse
    const LD = String.fromCharCode( 191 );  // Lord Muckford
    const SK = String.fromCharCode( 240 );  // Skull (not really NPC)
    const PR = String.fromCharCode( 230 );  // Prisoner

    // Enemy type (ET) enumeration
    // IMPORTANT: Start as 1 to avoid clash
    //            with player sprite type (0)
    const ET_GOBLIN = 1;
    // const ET_ORC = 2;
    const ET_BAT = 3;
    const ET_GOB_ARC = 4;
    const ET_STAT_ARC = 5;
    const ET_FIRE_IMP = 6;
    const ET_RAT = 7;
    const ET_OGRE = 8;
    const ET_BEAR = 9;
    const ET_WERERAT = 10;
    const ET_HOBGOB = 11;
    const ET_GOB_KING = 12;
    const ET_DRAGON = 13;
    const ET_DRAGON_TAIL = 14;
    const ET_BABY_DRAKE = 15;
    const NUM_ET = 16;
        
    // Missile type (MT) enumeration
    const MT_NONE = NUM_ET + 0;
    const MT_HAND_AXE = NUM_ET + 1;
    const MT_SHORT_SWORD = NUM_ET + 2;
    const MT_SWORD = NUM_ET + 3;
    const MT_LONG_SWORD = NUM_ET + 4;
    const MT_ARROW = NUM_ET + 5;
    const MT_FIRE_BALL = NUM_ET + 6;
    const MT_LR_FIRE_BALL = NUM_ET + 7;
    const MT_HAMMER = NUM_ET + 8;
    const MT_PAW = NUM_ET + 9;
    const NUM_MT = 10;

    const ENEMY_DATA = {
    //  SYMBOL: [name, ET, HTK, ascii, tpm, start_dir, tpl, MT ]
        'g': [ "Goblin", ET_GOBLIN, 2, 210, 250, DIR_RIGHT, 500, MT_HAND_AXE ],
        'h': [ "Hobgoblin",    ET_HOBGOB,    4, 211, 250, DIR_LEFT, 500, MT_LONG_SWORD ],
        'b': [ "Giant Bat",    ET_BAT,    1, 149 /*220*/, 250, DIR_LEFT, 500, MT_NONE ],
        'a': [ "Goblin Archer", ET_GOB_ARC, 2, 209, 500, DIR_RIGHT, 1000, MT_ARROW ],
        'f': [ "Fire Imp", ET_FIRE_IMP, 1, 208, 250, DIR_LEFT, 1000, MT_FIRE_BALL ],
        'r': [ "Giant Rat",    ET_RAT,    1, 203, 150, DIR_LEFT, 500, MT_NONE ],
        'w': [ "Wererat",    ET_WERERAT,    3, 196, 150, DIR_LEFT, 250, MT_PAW ],
        'e': [ "Ogre",    ET_OGRE,    6, 202, 400, DIR_LEFT, 330, MT_HAMMER ],
        'v': [ "Bear",    ET_BEAR,    7, 198, 400, DIR_LEFT, 330, MT_PAW ],
        's': [ "Goblin Archer", ET_STAT_ARC, 2, 209, 1000, DIR_LEFT, 750, MT_ARROW ],
        't': [ "Goblin Archer", ET_STAT_ARC, 2, 209, 1000, DIR_RIGHT, 750, MT_ARROW ],
        'd': [ "Fire Drake", ET_DRAGON, 3,    215,  330, DIR_RIGHT, 750, MT_LR_FIRE_BALL ],
        'c': [ "Drake tail", ET_DRAGON_TAIL, 1,     195,  500, DIR_RIGHT, 500, MT_NONE ],
        'y': [ "Baby Fire Drake", ET_BABY_DRAKE, 3,     229,  250, DIR_RIGHT, 500, MT_LR_FIRE_BALL ],
        'k': [ "Goblin King", ET_GOB_KING, 3,     190,  500, DIR_RIGHT, 500, MT_HAMMER ],
        };

    // Column enumerations for ENEMY_DATA (ED)
    ED_COL_NAME = 0;
    ED_COL_TYPE = 1;
    ED_COL_HTK = 2;
    ED_COL_ASCII = 3;
    ED_COL_TPM = 4;
    ED_COL_START_DIR = 5;
    ED_COL_TPL = 6;
    ED_COL_MT = 7;
    ED_NUM_COLS = 8;

    const MISSILE_DATA = {}
    //  Missile type:[ name, ascii, pxps, range in px, v-range in px ]
    MISSILE_DATA[MT_HAND_AXE] =    [ "Hand Axe",    235, 64, 32, 0 ];
    MISSILE_DATA[MT_LONG_SWORD] =  [ "Long Sword",  236, 128, 56, 8 ];
    MISSILE_DATA[MT_SWORD] =       [ "Sword",       237, 96, 48, 8 ];
    MISSILE_DATA[MT_SHORT_SWORD] = [ "Short Sword", 238, 64, 64, 0 ];
    MISSILE_DATA[MT_ARROW] = [ "Arrow", 218, 64, 72, 72 ];
    MISSILE_DATA[MT_FIRE_BALL] = [ "Fire Ball", 207, 64, 64, 24 ];
    MISSILE_DATA[MT_LR_FIRE_BALL] = [ "Fire Ball", 207, 64, 24*8, 16*8 ];
    MISSILE_DATA[MT_HAMMER] = [ "Hammer", 201, 128, 48, 8 ];
    MISSILE_DATA[MT_PAW] = [ "Paw", 197, 64, 32, 32 ];

    // Column enumerations for MISSILE_DATA (MD)
    MD_COL_NAME = 0;
    MD_COL_ASCII = 1;
    MD_COL_PXPS = 2;
    MD_COL_RANGE_IN_PX = 3;
    MD_COL_V_RANGE_IN_PX = 4;
    MD_NUM_COLS = 5;

    // Collectable type (CT) enumeration
    const CT_ARM_REP_1 = NUM_ET + NUM_MT + 0;
    const CT_ARM_REP_2 = NUM_ET + NUM_MT + 1;
    const CT_ARM_REP_3 = NUM_ET + NUM_MT + 2;
    const CT_ARM_ENH_1 = NUM_ET + NUM_MT + 3;
    const CT_ARM_ENH_2 = NUM_ET + NUM_MT + 4;
    const CT_ARM_ENH_3 = NUM_ET + NUM_MT + 5;
    const CT_XTRA_LF = NUM_ET + NUM_MT + 6;
    const CT_WEP_RNG = NUM_ET + NUM_MT + 7;
    const CT_ATT_RT = NUM_ET + NUM_MT + 8;
    const CT_MV_SPD = NUM_ET + NUM_MT + 9;
    const NUM_CT = 10;

    // Collectable data
    COLLECTABLE_DATA = {
        // SYMBOL : [name, collectable type, ascii, description]
        '1': ["Armor repair", CT_ARM_REP_1, 136,
                ["Restores 1 lost", "armor point"] ], 
        '2': ["Armor repair x2", CT_ARM_REP_2, 137, 
                ["Restores up to 2", "lost armor points"] ], 
        '3': ["Armor repair x3", CT_ARM_REP_3, 138, 
                ["Restores up to 3", "lost armor points"] ], 
        '4': ["Armor enhance", CT_ARM_ENH_1, 133,
                ["Increases armor", "capacity by 1"] ], 
        '5': ["Armor enhance x2", CT_ARM_ENH_2, 134, 
                ["Increases armor", "capacity by 2"] ], 
        '6': ["Armor enhance x3", CT_ARM_ENH_3, 135, 
                ["Increases armor", "capacity by 3"] ],
        '7': ["Extra life", CT_XTRA_LF, 216, 
                ["Gives you an", "extra life!"] ],
        '8': ["Weapon range+", CT_WEP_RNG, 139, 
                ["Increases weapon", "range by 1"] ],
        '9': ["Attack rate+", CT_ATT_RT, 140, 
                ["Increases attack", "rate"] ],
        '0': ["Move speed+", CT_MV_SPD, 141, 
                ["Increases move", "speed"] ],
    };

    // Column enumerations for COLLECTABLE_DATA (CD)
    CD_COL_NAME = 0;
    CD_COL_TYPE = 1;
    CD_COL_ASCII = 2;
    CD_COL_DESC = 3;

    // Shortcuts to ASCII codes needed by stat bar
    const ASCII_WEAPON_RANGE
        = COLLECTABLE_DATA['8'][CD_COL_ASCII];
    const ASCII_ATTACK_RATE
        = COLLECTABLE_DATA['9'][CD_COL_ASCII];
    const ASCII_MOVE_SPEED
        = COLLECTABLE_DATA['0'][CD_COL_ASCII];

    // Additional sprite types
    const SPRITE_TYPE_PLAYER = 0;
    const SPRITE_TYPE_SPLAT = NUM_ET + NUM_MT + NUM_CT;

    // Declare actual ASCII codes represented
    // by the symbols used in the level maps below
    // e.g. '.' maps to blank space (ASCII 32)
    let LEVEL_NOTATION = {};
    {
        LEVEL_NOTATION["UNKNOWN"] = LEVEL_ERROR; 
        LEVEL_NOTATION['.'] = LEVEL_SPACE;
        LEVEL_NOTATION['='] = LEVEL_BRICK;
        LEVEL_NOTATION['*'] = LEVEL_HOLLOW_BRICK;
        LEVEL_NOTATION['%'] = LEVEL_FAKE_BRICK;
        LEVEL_NOTATION['#'] = LEVEL_LADDER;
        LEVEL_NOTATION['+'] = LEVEL_TREE_TOP;
        LEVEL_NOTATION['|'] = LEVEL_TREE_TRUNK;
        LEVEL_NOTATION[','] = LEVEL_GRASS;
        LEVEL_NOTATION[';'] = LEVEL_ROCK_PLATFORM;
        LEVEL_NOTATION[':'] = LEVEL_SOLID_ROCK;
        LEVEL_NOTATION['~'] = LEVEL_GRATE;
        LEVEL_NOTATION['$'] = LEVEL_PORTCULIS;
        LEVEL_NOTATION['@'] = LEVEL_BARREL;
        LEVEL_NOTATION[']'] = LEVEL_LEFT_LEDGE;
        LEVEL_NOTATION['`'] = LEVEL_ROOF_TILE;
        LEVEL_NOTATION['['] = LEVEL_RIGHT_LEDGE;
        LEVEL_NOTATION['^'] = LEVEL_ALT_BRICK;
        LEVEL_NOTATION['&'] = LEVEL_THRONE_1;
        LEVEL_NOTATION['('] = LEVEL_THRONE_2;
        LEVEL_NOTATION[')'] = LEVEL_THRONE_3;

        // These symbols have special meaning, but display as space
        LEVEL_NOTATION['p'] = LEVEL_SPACE; // Player sprite start
        LEVEL_NOTATION['k'] = LEVEL_SPACE; // Player checkpoint
        
        // This symbols has special meaning, but displays as ladder
        LEVEL_NOTATION['j'] = LEVEL_LADDER; // Player ladder checkpoint
        
        // Add enemy symbols to LEVEL_NOTATION. Note a 'space'
        // is used to draw the character square when the level
        // is rendered, as enemies are instead rendered using
        // sprites.
        for( const key in ENEMY_DATA )
        {
            LEVEL_NOTATION[key] = LEVEL_SPACE; 
        }
        
        // Add collectable symbols to LEVEL_NOTATION. Note a 'space'
        // is used to draw the character square when the level
        // is rendered, as enemies are instead rendered using
        // sprites.
        for( const key in COLLECTABLE_DATA )
        {
            LEVEL_NOTATION[key] = LEVEL_SPACE; 
        }
    }

    // Identify which symbols are solid and in what way
    // (ammend this to suit)
    let LEVEL_SOLID_ASCII_VALUES = {};
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_BRICK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_ROCK_PLATFORM ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_SOLID_ROCK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_HOLLOW_BRICK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_FAKE_BRICK ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_LADDER ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_BARREL ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_TREE_TRUNK ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_TREE_TOP ] = SOLID_LEFT & SOLID_RIGHT;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_GRATE ] = SOLID_ALL_PLAYER_ONLY;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_PORTCULIS ] = SOLID_ALL_PLAYER_ONLY;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_LEFT_LEDGE ] = SOLID_TOP | SOLID_RIGHT;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_ROOF_TILE ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_RIGHT_LEDGE ] = SOLID_TOP | SOLID_RIGHT;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_ALT_BRICK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_THRONE_1 ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_THRONE_2 ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_THRONE_3 ] = SOLID_ALL;

    // Identify which symbols are deadly to player
    let LEVEL_DEADLY_ASCII_VALUES = new Set();
    // Currently empty

    // Each level is composed of one or more screens, arranged
    // in a matrix. This data structure gives the size if this
    // matrix, in whole screens ( hoz first, vert second )
    const LEVEL_DIMS = [
        [ 5, 3 ], // Level 1
        [ 3, 2 ], // Level 2
        [ 1, 1 ], // Level 3
        [ 1, 1 ]  // Level 4
    ];

    // Character square which, when reached by player,
    // triggers end of level. Values:
    //    screen_i, screen_j, char_i, char_j
    const LEVEL_END = [
        [ 4, 0, 20, 9 ],  // Level 1 
        [ 0, 0, -1, -1 ],  // Level 2
        [ 0, 0, -1, -1 ],  // Level 3
        [ 0, 0, -1, -1 ]  // Level 4
    ];

    //! Class to hold screen metadata
    class ScreenMeta
    {
        constructor( level_id, screen_i, screen_j )
        {
            this.level_id = level_id;
            this.screen_i = screen_i;
            this.screen_j = screen_j;

            this.clear_of_enemies = false;
            this.clear_of_collectables = false;
        }

        reset()
        {
            this.clear_of_enemies = false;
            this.clear_of_collectables = false;
        }
    }

    // Create array of persistant meta data for each screen 
    let level_meta = [];
    {
        for( let level_id = 0; level_id < NUM_LEVELS; level_id++ )
        {
            const DIMS = LEVEL_DIMS[level_id];
            const SCREENS_WIDE = DIMS[0];
            const SCREENS_HIGH = DIMS[1];

            level_meta.push([]);
            const META = level_meta[level_id];

            for( let screen_j = 0;
                 screen_j < SCREENS_HIGH;
                 screen_j++
            )
            {
                META.push([]);
                const ROW = META[screen_j];

                for( let screen_i = 0;
                     screen_i < SCREENS_WIDE;
                     screen_i++
                )
                {
                    ROW.push(
                        new ScreenMeta(
                            level_id, screen_i, screen_j
                        )
                    );
                }
            }
        }
}

    // Define level maps
    // These MUST match dimensions CHARS_WIDE and CHARS_HIGH 
    const LEVEL_DATA = [
    [  // Level 0 (i.e. Level 1 as player sees it)
        [  // Screen a-a
        "........................",
        "........................",
        ".=.=....................",
        "====..............8.....",
        "===.............#;;.....",
        "="+LH+"=.............#...+...",
        "===............g#...|...",
        "===............;;;#;;;..",
        "="+D1+D3+"....+..........#.....",
        "="+D2+D4+LM+".p.|..++......#.....",
        ";;;;#;;;;.||......#...,.",
        "::::#::::;;;;.,..;;;#;;;",
        "::::#::::::::;;.....#...",
        "::..#..."+AD+".:::::;....#."+AR+".",
        "::"+FS+".#...#...........#...",
        ":CELLAR:#::::::::FOREST:",
        ],
        [  // Screen b-a
        ".............b..........",
        "....b....."+P1+"+...,"+BU+".......",
        ".........."+P2+"|.;;;;;#..b..",
        "........9.;;;;....#...+.",
        "...b...;;;;....+.,#...|.",
        "............b"+BU+".|;;;;;#;;",
        "..+...+"+P1+"...;CLIMB;...#..",
        ".1|...|"+P2+".;TO;....;,0.#..",
        ".;;#;LEARN;....b.;;;;;;;",
        "...#..............b.....",
        "...#..,"+BU+".,.1........,"+BU+"..",
        ";;;#;;;;;;;;...;;#;;;;;;",
        "...#.........b...#......",
        ".+.#"+P1+"+..+b...++..#....b.",
        ".|.#"+P2+"|.,|..,.||..#..,...",
        "::::::::THE::FOREST:::::",
        ],
        [  // Screen c-a
        "........................",
        ".......+"+P1+"+.....7f..+....",
        "...+..f|"+P2+"|.....;;;.|....",
        "...|.;;;;;;,.....;;;#...",
        ".,;;;;.f..;;;.......#...",
        ";;;...,"+BU+"..f.;;.....;;;..",
        "...f.;;;;.,..;;#.+;;.;;.",
        ",..;;;..;;;..;;#.|#.....",
        ";;;;......;;#;;;;;;.,.+.",
        "............#;;;..;;;.|.",
        ".1........;;#;......;;;;",
        ";;.......;;.#....f......",
        ".........;;#;...........",
        "...+.....;;#;.."+P1+"..+.++..",
        "...|"+BU+".,.."+OM+";#..."+P2+"..|,||..",
        ":::SEEK:YE:BELOW:%::::::",
        ],
        [  // Screen d-a
        "...................b....",
        "...b...,...."+BU+"..++...f...",
        "......;;;;#;;;.||.......",
        "....+..."+P1+".#..;;;;;....+.",
        "....|..."+P2+".#......;;#;;|.",
        "...;;#;;;;;;.......#.;;;",
        ".....#...b.3.=.=.+.#....",
        ".....#...```.=.=.|.#..g.",
        "."+P1+"+..#..`````=.=;;;#;...",
        "."+P2+"|.;;;```````.=...#....",
        ";;;;;..=.....=.=..g#"+BU+"...",
        "......8=@....=0=..;#;;..",
        "......"+CP+"=@v....6=++.#....",
        "...,.:::::::::::||.#.1,.",
        "..::::::::::::::::::::::",
        ":::ABANDONED:COTTAGE::::",
        ],
        [  // Screen e-a
        "........................",
        "...f..............f.....",
        "......b......b..........",
        P1+"..........s.......=.=.=",
        P2+"....b.....=.=.=...=====",
        ";;.3.......=====....="+LH+"=.",
        "..;;7..f....="+LH+"=....s===.",
        "....;......s===....]===.",
        "........b..]===."+FI+"..."+D1+D3+"=:",
        "..b.........===.g.g."+D2+D4+"=:",
        "......b...======#======:",
        ".........8=====.#.....=:",
        ".......,.======.#.@"+FI+"..=:",
        "..,1,..========.#@@e@@=:",
        ":::::::::::::::::::::%::",
        ":GOBLIN:FORTRESS:GATE%::",
        ],
        [  // Screen a-b
        ":::=.=::#:::::::::=.=:::",
        "::==~===#==========~==::",
        "::=@....#............=::",
        "::=@@r..#.r..@..#.r@@=::",
        "::=========~====#=====::",
        "::=.....@.......#....=::",
        "::=.#r@@@@..#r.r#r@..=::",
        "::=~#=======#======~==::",
        "::=.#....=..#........=::",
        "::=r#@@4.$..#r@.#.r@9=::",
        "::=========~====#=====::",
        "::=@.....@......#....=::",
        "::=@.r.2@@@r.0r@#r.r@=::",
        "::==~==============~==::",
        ":::=.=::::::::::::=.=:::",
        ":::=.=WINE::CELLAR=.=:::",
        ],
        [  // Screen b-b
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::I:WOULD:TURN::::::::::",
        "::::::::::::::::::::::::",
        ":::::BACK:IF I::::::::::",
        "::::::::::::::::::::::::",
        ":::::::WERE YOU!::::::::",
        "::::::::::::::::::::::::",
        ":::::::::SAVE THYSELF:::",
        "::::::::::::::::::::::::",
        ":DEATH::................",
        "::::::::....::::::::::::",
        ":::"+AD+"::::....::::::::::::",
        "::::::::....::::::::::::",
        ],
        [  // Screen c-b
        "::::::::::::::::=#=:::::",
        "::::::::::::::===#=:::::",
        "::::::::::::::=..#=:::::",
        "::::::::::::::=#,#=MINE:",
        "::::::::::::::=#===:::::",
        "::::::::::::::=#..=SHAFT",
        "::::::::::::::=#..=:::::",
        "::::::::::::::=#..=::"+AD+"::",
        "::::::::::::::=#r#=:::::",
        "::::::::::::::===#=:::::",
        ":TO THY DOOM!:=b.#=:::::",
        "::::::::::::::=..#=:::::",
        ".................#=:::::",
        "::::::::::::::=..#=:::::",
        ":::"+AL+"::::::::::=#.#=:::::",
        "::::::::::::::=#===:::::",
        ],
        [  // Screen d-b
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "========================",
        ],
        [  // Screen e-b
        ":::::::::::::::::::::%::",
        "::::::::::::::::::::=#=:",
        ":::==================#=:",
        ":::=..."+C2+C3+C4+".."+C2+C3+C4+".."+C2+C3+C4+"=#=:",
        ":::=."+FI+".."+C1+"."+FI+"f."+C1+"."+FI+".."+C1+".=#=:",
        ":::=.f.."+C1+"...."+C1+"...."+C1+"f=#=:",
        ":::=#..1"+C1+"..f7"+C1+"...."+C1+"..#=:",
        ":::=#==================:",
        ":::=#b.=::::::::::::::::",
        ":::=#..=::::::::::::::::",
        ":::=#..=::::UNDER:::"+AU+":::",
        ":::=#2#=::::::::::::::::",
        ":::===#=:::::THE::::::::",
        ":::=..#=:::::::::::::%::",
        ":::=..#=:::GATEHOUSE:%::",
        ":::=..#=:::::::::::::%::",
        ],
        [  // Screen a-c
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        "........................",
        ],
        [  // Screen b-c
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::....::::DIE:::::",
        "::::::::....::::::::::::",
        "::::::::....:::MORTAL!::",
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::....::::::::::::",
        "::::::::."+FI+"."+FI+"::::::::::::",
        "::::::::"+FI+FI+FI+FI+"::::::::::::",
        "::::::::"+FI+FI+FI+FI+"::::::::::::",
        "::::::::::::::::::::::::",
        "::::YOU:WERE:WARNED:::::",
        ],
        [  // Screen c-c
        "::::::::::::::=#..=:::::",
        ":::...::=======#..===:::",
        ":::@@.::=......#....=:::",
        ":::@@...$.85."+FI+".#."+FI+".1=:::",
        "::::::::=#==...#...@=:::",
        "::::::::=#..@e.#.e@@=:::",
        "::::::::=#===========:::",
        ":::::::::#::::::::::::::",
        ":::::::::#::::::::::::::",
        ":::======#==============",
        ":::=.....#..............",
        ":::=."+FI+"...#...."+FI+"...."+FI+"....",
        ":::=..g..#.,.....g..,r..",
        ":::=====================",
        "::::::::::::::::::::::::",
        "::THE:OUTER:GUARD:ROOM::",
        ],
        [  // Screen d-c
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "::::::::::::::::::::::::",
        "========================",
        ".b.......b...........b..",
        "..."+FI+"..b."+FI+"...."+FI+"....."+FI+"....",
        "........@.........e.2.9.",
        "========================",
        "::::::::::::::::::::::::",
        ":::::THE:LONG:TUNNEL::::",
        ],
        [  // Screen e-c
        ":::=..#=::::::::::::::::",
        ":::=#.#=::::::::::::::::",
        ":::=#=========::::::::::",
        ":::=#.....f..=========::",
        ":::=#..."+FI+"............=::",
        ":::====..g.,.."+FI+"..."+FI+"..=::",
        "::::::=======1.g.#...=::",
        "::::::::::::=====#..s=::",
        "::::::=======....#..]=::",
        "=======....f.....#...=::",
        "..........."+FI+".....#.g1=::",
        "..."+FI+"......g..=========::",
        "....,..=======::::::::::",
        "========::::::::::::::::",
        "::::::::::::::::::::::::",
        ":::::UP!:UP!:UP!::::::::",
        ]
    ],
    [  // Level 1
        [  // Screen a-a
        "==::::::::::::::========",
        "==::::::::::::::==......",
        "==================..."+FI+"..",
        "==================9...4.",
        "=====...."+C2+C3+C4+"..e...,..e..",
        "===......."+C1+"..=#=========",
        "==t......."+C1+"...#.........",
        "==[.."+FI+"...."+C1+"...#..."+FI+".....",
        "==......#,"+C1+".,.#......,h.",
        "===....=#=======...2.]==",
        "====....#."+C1+"......h.]===:",
        D1+D3+"......#."+C1+"....h.]===:::",
        D2+D4+"p.....#."+C1+"...,]===:::::",
        "=================:::::::",
        "::::::::::::::::::::::::",
        "::::ENTRANCE::HALL::::::",
        ],
        [  // Screen b-a
        "===========~======~=====",
        "...............=........",
        "...............=........",
        ".....r,..w.w.r.r.r,w....",
        "...==~===============...",
        "=====...............=~..",
        "....................=.=.",
        "....................=.:=",
        "...r,2...r#...r.w,r.$.::",
        "=======~==#==~=======:::",
        "::::=.....#....=::::::::",
        "::::=@....#....=::::::::",
        "::::=@"+CP+"w4.#.@7.$.r..w...",
        "::::=======~====::.:::::",
        ":::::::::::.::::::.:::::",
        ":::::GUARD:.ROOM::.:::::",
        ],
        [  // Screen c-a
        "===:::::::::::::::::::::",
        "..====::::::::::::::::::",
        ".....=====::::::::::::::",
        "..f......============:::",
        "..."+FI+"........f......==:::",
        "...........f.......==:::",
        "..,..f..3..,.#.."+FI+"..==:::",
        "=============#=....==:::",
        ":...."+C2+C3+C4+".....#.....==:::",
        ":t...."+C1+"....h.#..,..==:::",
        ":@3..."+C1+".."+FI+"..======#==:::",
        ":@@..."+C1+"...........#==:::",
        "%@@@8,"+C1+"..e...h,...#==:::",
        "::::==============#==:::",
        ":::::::::::::::=..#==:::",
        "::THE::ARMORY::=..#==:::",
        ],
        [  // Screen a-b
        "::::::::::::::::::::::::",
        ":::ALL:HAIL:THE:KING!:::",
        "::::::::::::::::::::::::",
        ":::::::==========:::::::",
        ":::::===.."+C2+C3+C4+"...===:::::",
        "::::==....."+C1+"......===:::",
        "::::==.."+FI+".."+C1+"..."+FI+"....====",
        "::::==....."+C1+"..........==",
        "::::==..&k."+C1+"..........==",
        "::::==..()."+C1+"..........==",
        "::=====#=======#......"+D1+D3,
        "::==...#=:::::=#......"+D2+D4,
        "::=="+LD+"..#=:::::=#....====",
        "::=======:::::=======:::",
        "::::::::::::::::::::::::",
        "::::::THRONE::ROOM::::::",
        ],
        [  // Screen b-b
        "::::::::::::::::::.:::::",
        "::::::::::::::::::#:::::",
        "::::::::::::::::::#:::::",
        "::::::::::::::::::#:::::",
        "==================#=====",
        "==``````````````````````",
        "==....y......b.......y..",
        "==......................",
        "==...b..."+FI+"..y...."+FI+"......",
        "==......................",
        D1+D3+".y............,..,....",
        D2+D4+"e........=#=======#=..",
        "======.,.r..#..,3.r.#...",
        "::::====================",
        "::::::::::::::::::::::::",
        ":::::BANQUET::HALL::::::",
        ],
        [  // Screen c-b
        ":::::::::::::::=..#==:::",
        "::...st...:::::=.,#==:::",
        "::...@@...:::::=#====:::",
        "::.6w@@....t.b..#b.==:::",
        "===========[,...#.,==:::",
        "`````````=========#====:",
        "..."+C2+C3+C4+"...==.......#..==:",
        "...."+C1+"...."+D1+D3+"..."+FI+"...#..==:",
        "."+FI+".."+C1+".e,."+D2+D4+",.e....#e.==:",
        "...."+C1+"..h======#====#===:",
        "...."+C1+"h===::=..#.=..#.==:",
        "..h,===::::=9.#.=..#.==:",
        ".,===::::::="+CP+".#3="+PR+".#7==:",
        "=====::::::============:",
        "::::::::::::::::::::::::",
        "::THE:LOWER:GUARD ROOM::",
        ],
    ],
    [  // Level 2
        [  // Screen a-a
        "^^^^^^^^^^^^^^^^^^^^^^^^",
        "^"+LD+"$....................^",
        "^^^..........y......^^.^",
        "^....."+SK+".........."+SK+"...^.^",
        "^.........."+S1+"...........^",
        "^.........."+S2+"...........^",
        "^..d.......^..........^^",
        "^..."+S1+".............."+S1+".."+D1+D3,
        "^..."+S2+".............."+S2+".p"+D2+D4,
        "^...^..............^..^^",
        "^.........."+S1+"...........^",
        "^.........."+S2+"...........^",
        "^.^y.."+SK+"....^....."+SK+"...^.^",
        "^.^^................^^.^",
        "^......................^",
        "^^^^ HALL OF STATUES ^^^",
        ],
    ],
    [  // Level 3
        [  // Screen a-a
        "........................",
        "........................",
        ".=.=...THANK YOU........",
        "====....................",
        "===......THRANE ETHREN..",
        "="+LH+"=.....................",
        "===.........GO NOW......",
        "===.....................",
        "="+D1+D3+"....+......IN PEACE..",
        "="+D2+D4+LM+LD+".p|..++............",
        ";;;;;;;;;.||............",
        ":::::::::;;;;.,.........",
        ":::::::::::::;;.........",
        ":::::::::::::::;........",
        "::::::::::::::::;;;;;;;;",
        ":::HIT::SPACE::TO:END:::"
        ]
    ]
    ];

    // Declare default palette
    const DEFAULT_PALETTE = {
        // Enemies
        'Goblin': [CW ? COL_4_FG_2 : COL_16_GRN],
        'Goblin Archer': [CW ? COL_4_FG_2 : COL_16_GRN],
        // 'Static Archer': [CW ? COL_4_FG_2 : COL_16_GRN],
        'Hobgoblin': [CW ? COL_4_FG_2 : COL_16_BLU],
        'Giant Bat': [CW ? COL_4_FG_2 : COL_16_LGY],
        'Fire Imp': [CW ? COL_4_FG_2 : COL_16_RED],
        'Giant Rat': [CW ? COL_4_FG_2 : COL_16_BRW],
        'Wererat': [CW ? COL_4_FG_2 : COL_16_BRW],
        'Ogre': [CW ? COL_4_FG_2 : COL_16_YEL],
        'Bear': [CW ? COL_4_FG_2 : COL_16_BRW],
        'Fire Drake': [CW ? COL_4_FG_2 : COL_16_RED],
        'Drake Tail': [CW ? COL_4_FG_2 : COL_16_RED],
        'Baby Fire Drake': [CW ? COL_4_FG_2 : COL_16_RED],
        'Goblin King': [CW ? COL_4_FG_2 : COL_16_GRN],
        // Missiles
        'Hand Axe': [CW ? COL_4_FG_2 : COL_16_BRW],
        'Long Sword': [CW ? COL_4_FG_2 : COL_16_DGY],
        'Sword': [CW ? COL_4_FG_2 : COL_16_DGY],
        'Short Sword': [CW ? COL_4_FG_2 : COL_16_DGY],
        'Arrow': [CW ? COL_4_FG_2 : COL_16_YEL],
        'Fire Ball': [CW ? COL_4_FG_2 : COL_16_RED],
        'Hammer': [CW ? COL_4_FG_2 : COL_16_YEL],
        'Paw': [CW ? COL_4_FG_2 : COL_16_BRW],

        // Level furniture
        '#':[CW ? COL_4_FG_1 : COL_16_CYN],  // LADDER
        '=':[CW ? COL_4_FG_1 : COL_16_DGY, COL_16_LGY],  // BRICK
        '%':[CW ? COL_4_FG_1 : COL_16_DGY, COL_16_LGY],  // FAKE BRICK
        ';':[CW ? COL_4_FG_1 : COL_16_GRN, COL_16_BRW],  // ROCK PLATFORM
        '+':[CW ? COL_4_FG_1 : COL_16_LGR],  // TREE TOP
        '|':[CW ? COL_4_FG_1 : COL_16_BRW],  // TREE TRUNK
        ',':[CW ? COL_4_FG_1 : COL_16_LGR],  // GRASS
        ':':[CW ? COL_4_FG_1 : COL_16_DGY, COL_16_LGY ],  // SOLID ROCK
        '~':[CW ? COL_4_FG_1 : COL_16_LGY ],  // GRATE
        '$':[CW ? COL_4_FG_1 : COL_16_DGY ],  // PORTCULIS
        '@':[CW ? COL_4_FG_1 : COL_16_LBL ],  // BARREL
        ']':[CW ? COL_4_FG_1 : COL_16_DGY ],  // LEFT LEDGE
        '`':[CW ? COL_4_FG_1 : COL_16_RED ],  // ROOF TILE
        '[':[CW ? COL_4_FG_1 : COL_16_DGY ],  // RIGHT LEDGE
        '^':[CW ? COL_4_FG_1 : COL_16_CYN ],  // ALT BRICK
        '&':[CW ? COL_4_FG_1 : COL_16_YEL ],  // THRONE 1
        '(':[CW ? COL_4_FG_1 : COL_16_YEL ],  // THRONE 2
        ')':[CW ? COL_4_FG_1 : COL_16_YEL ],  // THRONE 3
    }
        
    // LITERAL ASCII colo(u)rs

    // Large door 
    DEFAULT_PALETTE[D1] = 
      DEFAULT_PALETTE[D2] =
        DEFAULT_PALETTE[D3] =
          DEFAULT_PALETTE[D4] =
            [CW ? COL_4_FG_1 : COL_16_BRW, COL_16_BLK ];

    // Arrows
    DEFAULT_PALETTE[AU] = 
      DEFAULT_PALETTE[AR] =
        DEFAULT_PALETTE[AD] =
          DEFAULT_PALETTE[AL] =
            [CW ? COL_4_FG_1 : COL_16_LGY, COL_16_BLK ];

    // Battlement loop-hole
    DEFAULT_PALETTE[LH] =
        [CW ? COL_4_FG_1 : COL_16_DGY, COL_16_LGY ];

    // Fire
    DEFAULT_PALETTE[FI] =
        [CW ? COL_4_FG_2 : COL_16_RED ];

    // Vegetation
    DEFAULT_PALETTE[P1] =
      DEFAULT_PALETTE[P2] =
        DEFAULT_PALETTE[BU] =
          [CW ? COL_4_FG_1 : COL_16_LGR ];

    // Columns
    DEFAULT_PALETTE[C1] =
      DEFAULT_PALETTE[C2] =
        DEFAULT_PALETTE[C3] =
          DEFAULT_PALETTE[C4] =
            [CW ? COL_4_FG_1 : COL_16_LGY ];

    // Statue
    DEFAULT_PALETTE[S1] =
      DEFAULT_PALETTE[S2] =
        [CW ? COL_4_FG_1 : COL_16_CYN ];


    // NPCs
    DEFAULT_PALETTE[OM] =
      DEFAULT_PALETTE[LM] =
        DEFAULT_PALETTE[LD] =
          DEFAULT_PALETTE[FS] =
            DEFAULT_PALETTE[CP] =
              DEFAULT_PALETTE[SK] =
                DEFAULT_PALETTE[PR] =
                  [CW ? COL_4_FG_0 : COL_16_WHT ];


    // Declare custom colo(u)r palette for each level
    const LEVEL_PALETTE = [
        {}, // Level 1
        {}, // Level 2
        // Level 3
        { 
            //'=': [CW ? COL_4_FG_1 : COL_16_CYN],  // Brick
            //'$': [CW ? COL_4_FG_1 : COL_16_CYN]  // Portculis
            '^':[CW ? COL_4_BG : COL_16_CYN,
                    CW ? COL_4_FG_1 : COL_16_WHT]
        },
        {}  // Level 4
    ];

    const LEVEL_INTRO_TEXT = [
        // Level 1
        [  "CASTLE MUCKFORD & WOODS",
           "Explore the woods and",
           "what lies below. Find",
           "a way into the goblin",
           "fortress. Talk to NPCs.",
           "Access map via in-game",
           "menu (press ESC)"
        ],
        // Level 2
        [  "GOBLIN KING'S FORTRESS",
           "A once magnficent",
           "castle, now decaying",
           "and vermin infested.",
           "Seek the Goblin King",
           "and destroy him,",
           "then rescue Muckford."
        ],
        // Level 3
        [  "TRANSFORMATION",
           "The Goblin King's",
           "flacid corpse quivers",
           "as a rapidly growing",
           "shape emerges. He was",
           "really a Fire Drake",
           "in disguise!"
        ],
        // Level 4
        [  "PEACE IS RESTORED",
           "You escort Muckford",
           "back to his castle",
           "where Lady Muckford",
           "awaits.....",
           "",
           ""
        ]
    ];

    const LEVEL_OUTRO_TEXT = [
        // Level 1
        [ "You have breached",
          "the walls of the",
          "Goblin Fortress!",
          "Now storm the keep!"
        ],
        // Level 2
        [ "The Goblin King",
          "lies dead!",
          "You remain on your",
          "guard, as something",
          "doesn't feel right.",
          "This was too easy..."
        ],
        // Level 3
        [ "FIRE DRAKE IS SLAIN!",
          "At the screams of",
          "the dying beast, the",
          "evil minions of the",
          "fortress run away in",
          "terror!"
        ],
        // Level 4
        [ "THE END",  // This should not appear on screen
        ],
    ];

    // Quality check
    if( NUM_LEVELS !== LEVEL_DIMS.length
        || NUM_LEVELS !== LEVEL_END.length
        || NUM_LEVELS !== LEVEL_DATA.length
        || NUM_LEVELS !== LEVEL_PALETTE.length
        || NUM_LEVELS !== LEVEL_INTRO_TEXT.length
        || NUM_LEVELS !== LEVEL_OUTRO_TEXT.length
    )
    {
        console.log( "Error: size of LEVEL_DIMS (",
                     LEVEL_DIMS.length,
                     "), LEVEL_DATA (",
                     LEVEL_DATA.length,
                     "), LEVEL_END (",
                     LEVEL_END.length,
                     "), LEVEL_PALETTE (", LEVEL_PALETTE.length,
                     ") and LEVEL_INTRO_TEXT (",
                     LEVEL_INTRO_TEXT.length,
                     ") do match NUM_LEVELS (", NUM_LEVELS, ")" );
        return;
    }

    // Check quality of each level
    for( let n = 0; n < NUM_LEVELS; n++ )
    {
        // Get level dimensions (in whole screens)
        const DIMS = LEVEL_DIMS[n];

        // Check number of dimensions is two
        if( DIMS.length != 2 )
        {
            console.log( "Error: dimensions of level", n + 1,
                         "does not have 2 elements." );
            return;
        }

        const SCREENS_WIDE = DIMS[0];
        const SCREENS_HIGH = DIMS[1];

        // Get total number of screens in level
        const NUM_SCREENS = SCREENS_WIDE * SCREENS_HIGH;

        const LEVEL = LEVEL_DATA[n];

        if( LEVEL.length !== NUM_SCREENS )
        {
            console.log( "Error: expected number of screens (",
                         NUM_SCREENS,
                         ") for level", n + 1,
                         "does not match number of screens",
                         "provided:", LEVEL.length  );
            return;
        }

        // Check size of each screen
        for( let m = 0; m < NUM_SCREENS; m++ )
        {
            const SCREEN = LEVEL[m];

            if( SCREEN.length !== CHARS_HIGH )
            {
                console.log( "Error: screen ", m,
                             "of level", n,
                             "has incorrect length (",
                             SCREEN.length,
                             ") should be", CHARS_HIGH );
                return;
            }

            for( let p = 0; p < CHARS_HIGH; p++ )
            {
                if( SCREEN[p].length !== CHARS_WIDE )
                {
                    console.log( "Error: line", p,
                                 "of screen ", m,
                                 "of level", n,
                                 "has incorrect length (",
                                 SCREEN[p].length,
                                 ") should be", CHARS_WIDE );
                    return;
                }
            }
        }
    }
    console.log( "Level quality check complete" );
    
    // END OF LEVEL DATA
    ///////////////////////////////////////////


    ///////////////////////////////////////////
    // FUNCTION DEFS

    //! Player loses life
    player_loses_life = function( level_restart = false )
    {
        // Cancel any playing sound FX
        audio_cancel_all_FX();
        
        // Play losing FX
        if( audio_mute !== MUTE_STATUS_MUTE_ALL )
        {
            // TODO: Losing FX
        }

        console.log( "Player loses life" );

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;

        // Reduce player lives
        player_lives -= 1;

        // Update stat bar
        stat_bar_lives();

        // Change border colo(u)r
        document.body.style.background = FLASH_BORDER_COL;

        // Check for player death
        if( player_lives <= 0 )
        {
            // Stop keyboard event handling
            document.removeEventListener( 'keydown', handleKeyEvent );
            key_handler_on = false;

            // Game over
            setTimeout( game_over_screen, ACTION_PAUSE_DELAY );
        }
        else
        {
            // Note: leaving key handler active here, due to pop-up

            // Change game state to 'lost life'
            game_state = GAME_STATE_LOST_LIFE;

            lose_life_pop_up(
                "Lose a life",  // Pop-up title
                [ "You have lost",
                  "",
                  "a life.",  // Pop up text
                  "",
                  "Do be more",
                  "",
                  "careful!"
                ]
            );
        }
    }

    //! Restart game after lost life
    restart_game = function()
    {
        const NEW_CH_I = player_sprite.last_checkpoint[0];
        const NEW_CH_J = player_sprite.last_checkpoint[1];

        // Restore armo(u)r to max
        player_armor_remaining = player_max_armor;
        stat_bar_armor();

        console.log( "Restarting game", NEW_CH_I, NEW_CH_J );
        
        // Change border colo(u)r
        document.body.style.background = DEFAULT_BORDER_COL;

        // Remove 'scent trail' from current location
        if( scent_sprite === player_sprite )
        {
            get_char( scent_sprite ).scent = DIR_NONE; 
        }

        // Get current ticks for timing purposes
        const TICKS = Date.now();

        // Move player to last checkpoint
        if( player_sprite.move( NEW_CH_I, NEW_CH_J ) )
        {
            // Reset number of chars fallen
            player_sprite.chars_fallen = 0;

            // Update previous move ticks
            player_sprite.prev_move_ticks = TICKS;
        }

        // Reset all enemy move timings.
        // Also reset position of enemies, but only if a start
        // position is specified
        for( const enemy of enemy_sprites )
        {
            enemy.prev_move_ticks = TICKS;

            enemy.move(
                enemy.start_char_i,
                enemy.start_char_j
            );

            // Reset direction also
            enemy.dir = ENEMY_START_DIR[enemy.type - 1];
        }

        game_state = GAME_STATE_IN_PLAY;

        // Add key handler, this is IMPORTANT
        // as key handler will have been disabled
        // by calling function 'player_loses_life'.
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }
        
        // Restart main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    }

    
    //! Clear all pixels (and delete all sprites)
    clear_screen = function( bg_col = DEFAULT_BG_COL )
    {
        // Clear main game area
        clear_canvas( CANV_CHARS_CTX, chars, bg_col );

        // Clear stat bar
        clear_canvas( CANV_SB_CTX, sb_chars, bg_col );

        delete_all_sprites();
    }

    //! Draw mouse activation screen
    /* This is necessary as most browsers require some
       kind of user interaction to play audio, and mouse
       click is better than key press as some keys trigger
       unwanted browser actions
    */
    mouse_activation_screen = function()
    {
        // CHECK FOR MOUSE INTERACTION TO INITIALIZE GAME
        document.addEventListener( 'click', mouse_init_audio );

        game_state = GAME_STATE_AWAITING_MOUSE_CLICK;

        console.log( "Mouse activation screen" );

        clear_screen( DEFAULT_BG_COL );

        write_mesg(
            [ "Thane's Pursuit",
              "",
              "* CLICK THIS WINDOW *",
              "TO ACTIVATE",
              "BROWSER GAME"
            ],
            1,
            0,
            true,
            true,
            INTRO_TEXT_COL
        );
    }

    //! Draw Title Screen
    title_screen = function( col, bitmap_px_width, bitmap_px_height, block_width )
    {
        // Pause key handling
        key_handling_delay = true;

        // Change game state
        game_state = GAME_STATE_TITLE;

        console.log( "Title screen" );
    
        clear_screen( DEFAULT_BG_COL );
        
        // Set fill colo(u)r
        CANV_CHARS_CTX.fillStyle = col;
        
        document.body.style.background = DEFAULT_BORDER_COL;

        // Sanity check
        if( bitmap_px_width * bitmap_px_height / block_width
                !== TITLE_SCREEN_BITMAP_DATA.length
        )
        {
            console.log( "Error: TITLE_SCREEN_BITMAP_DATA",
                         "not expected size.",
                         "bitmap_px_wide =", bitmap_px_width,
                         "bitmap_px_high =", bitmap_px_height,
                         "block_width =", block_width,
                         "bitmap data array length =",
                         TITLE_SCREEN_BITMAP_DATA.length
                       );
            return;
        }

        // Draw title bitmap
        let block_num = 0;
        let bit_pos = 0;
        let block_datum = TITLE_SCREEN_BITMAP_DATA[block_num];
        for( let px_j = 0; px_j < bitmap_px_height ; px_j++ )
        {
            for( let px_i = 0; px_i < bitmap_px_width; px_i++ )
            {
                // Only set colo(u)r of pixels set to '1' in bitmap
                const BIT_MASK = 1 << ( block_width - 1 - bit_pos );
                if( ( BIT_MASK & block_datum ) !== 0 )
                {
                    // Draw pixel
                    CANV_CHARS_CTX.fillRect(
                        px_i * PIXEL_WIDTH,
                        px_j * PIXEL_HEIGHT,
                        PIXEL_WIDTH,
                        PIXEL_HEIGHT
                    );
                }

                // Move 'bit_pos' on
                bit_pos += 1;

                // Check for end of current block
                if( bit_pos == block_width )
                {
                    bit_pos = 0;
                    block_num += 1;
                    if( block_num < TITLE_SCREEN_BITMAP_DATA.length )
                    {
                        block_datum
                            = TITLE_SCREEN_BITMAP_DATA[block_num];
                    }
                }
            }
        }
       
        stat_bar_alert( "HIT ENTER TO BEGIN" );

        // Add key handler (defined further on)
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Allow a short wait to allow keyboard activity
        // to cease before checking for key down
        setTimeout(
            function() { key_handling_delay = false; },
            KEY_ENTRY_DELAY
        );
    }

    //! Shared code for screen functions
    draw_screen = function(
        new_game_state,  // Must be a valid game state
        text = [ "" ],  // 1D array of strings
        footer = "",  // String
        centered = true,  // false = left justified
        fg_col = INTRO_TEXT_COL,
        bg_col = DEFAULT_BG_COL,
        footer_col = INTRO_FOOTER_COL 
    )
    {
        // Pause key handling
        key_handling_delay = true;

        if( isFinite( new_game_state )
            && new_game_state >= 0
            && new_game_state < GAME_STATE_MAX
        )
        {
            game_state = new_game_state;
        }
        else
        {
            console.log( "Invalid game state:", new_game_state );
            console.log( "Text:", text );
            return false;
        }

        clear_screen( bg_col );
        
        document.body.style.background = DEFAULT_BORDER_COL;

        let error_free = true;

        // Write title to stat bar
        stat_bar_alert( "THANE'S PURSUIT", bg_col, fg_col );

        // Write text
        if( text !== [] )
        {
            error_free |= write_mesg(
                text,
                1,
                1,
                centered,
                false,
                fg_col,
                bg_col
            );
        }

        // Write footer
        if( footer !== [] )
        {
            error_free |= write_line(
                footer,
                CHARS_WIDE - footer.length - 1,
                CHARS_HIGH - 1,
                footer_col,
                bg_col
            );
        }
        
        // Add key handler (defined further on)
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Allow a short wait to allow keyboard activity
        // to cease before checking for key down
        setTimeout(
            function() { key_handling_delay = false; },
            KEY_ENTRY_DELAY
        );
    }

    //! Draw blerb screen giving background narrative
    blerb_screen = function()
    {
        draw_screen( GAME_STATE_BLERB,
                     [ "You are Ethren,",
                       "Thane of King Athelon.",
                       "You are in pursuit of",
                       "the wicked Goblin King,",
                       "holding Lord Muckford",
                       "prisoner in his castle."
                     ],
                     "M to mute     hit enter"
                   );
    
        console.log( "Blerb screen" );
    }

    //! Draw game menu screen
    menu_screen = function()
    {
        draw_screen( GAME_STATE_MENU,
                     [ "Choose an option:",
                       "1. Help/Intructions",
                       "2. Start at level 1",
                       "3. Select start level",
                       "4. About" ],
                     "hit a number key",
                     false
                   );
    
        console.log( "Menu screen" );
    }

    //! Draw game instruction screen 1
    instruction_screen_1 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_1,
                     [ "Adventure platformer.",
                       "Journey through woods",
                       "and secret places to",
                       "find the Goblin King's",
                       "fortress, then kill",
                       "him in single combat.",
                     ],
                     "1/4        hit enter",
                     false
                   );
    
        console.log( "Instruction screen 1" );
    }

    //! Draw game instruction screen 2
    instruction_screen_2 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_2,
                     [ "WASD IJKL "
                          + CHAR_UP + CHAR_LEFT
                          + CHAR_DOWN + CHAR_RIGHT
                       + " to move.",
                       "[Space] to attack.",
                       "Reach stated objective",
                       "to complete each level,",
                       "and look for power ups",
                       "and armor repair."
                     ],
                     "2/4        hit enter",
                     false
                   );
    
        console.log( "Instruction screen 2" );
    }

    //! Draw game instruction screen 3
    instruction_screen_3 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_3,
                     [ "Pop-up tips in game",
                       "will explain things.",
                       "These can be turned off",
                       "via in-game menu (ESC).",
                       "Approach NPCs (white)",
                       "for advice and secrets!"
                     ],
                     "3/4        hit enter",
                     false
                   );
    
        console.log( "Instruction screen 3" );
    }

    //! Draw game instruction screen 4
    instruction_screen_4 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_4,
                     [ "The boring stuff:",
                       "P to pause/unpause",
                       "M to mute/FX/FX+music",
                       "ESC for in-game menu",
                       "with lots of options.",
                       ".....Good luck!"
                     ],
                     "4/4        hit enter",
                     false
                   );
    
        console.log( "Instruction screen 4" );
    }

    //! Draw select starting level screen
    select_level_screen = function()
    {
        // Reset these values (if needed)
        for( let n = 0; n < cheat_code_alpha.length; n++ )
        {
            draw_char( n, CHARS_HIGH - 3, 32 );
            cheat_code_alpha[n] = NO_DIGIT_SELECTED;
        }


        // Check how many numeric digits required
        if( max_level_achieved == 0 )
        {
            // Cheat code only version
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Enter an eight letter",
                           "'cheat' code, or ESC",
                           "to return to menu.",
                           "",
                           "(you get a code after",
                           "completing each level)"
                         ],
                         "hit letters or ESC",
                       );
            console.log( "Select level screen (cheat only)" );
        }
        else if( max_level_achieved > 8 )
        {
            // Two digit version
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Select starting level",
                           "01 to " + ( max_level_achieved + 1 ),
                           "(type two digits)",
                           "--- or ---",
                           "enter an eight letter",
                           "'cheat' code."
                         ],
                         "hit letters or numbers",
                       );
            console.log( "Select level screen (2 digit)" );
        }
        else
        {
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Select starting level",
                           "1 to " + ( max_level_achieved + 1 ),
                           "--- or ---",
                           "enter an eight letter",
                           "'cheat' code."
                         ],
                         "hit letters or numbers",
                       );
            console.log( "Select level screen" );
        }
    }

    // Processing response to key stroke when in select level mode
    select_level = function( key_code )
    {
        if( key_code == "Escape" )
        {
            menu_screen(); 
        }
        if( key_code.substring( 0, 5 ) == "Digit" )
        {
            // If number pressed, cancel any alpha selection

            for( let n = 0; n < cheat_code_alpha.length; n++ )
            {
                draw_char( n, CHARS_HIGH - 3, 32 );
                cheat_code_alpha[n] = NO_DIGIT_SELECTED;
            }

            const DIGIT = Number( key_code.substring( 5, 6 ) );

            if( max_level_achieved < 9 )
            {
                // Single digit option...

                // Put choice in bottom left corner
                draw_char( 0, CHARS_HIGH - 2, DIGIT + 48 );

                const LEVEL_ID = Number( key_code.substring( 5, 6 ) ) - 1;
                
                if( LEVEL_ID >= 0
                    && LEVEL_ID <= max_level_achieved
                )
                {
                    reset_vars_for_new_game();

                    current_level = LEVEL_ID;
                    start_level = LEVEL_ID;
                    
                    // Put tick in after number
                    draw_char( 1, CHARS_HIGH - 2, TICK_ASCII ); 

                    // Start level intro after short delay
                    setTimeout(
                        function() { level_intro_screen( LEVEL_ID ); },
                        250
                    );
                }
                else
                {
                    // Put cross in after number
                    draw_char( 1, CHARS_HIGH - 2, CROSS_ASCII ); 
                    
                    console.log( "Level", LEVEL_ID + 1, "inaccessible" );

                    // Restart level select after short delay
                    setTimeout(
                        function() { select_level_screen(); },
                        250
                    );
                }
            }
            else
            {
                // Two digit option...

                const DIGIT = Number( key_code.substring( 5, 6 ) );

                if( select_level_first_digit
                        == NO_DIGIT_SELECTED
                )
                {
                    select_level_first_digit = DIGIT;

                    // Put choice in bottom left corner
                    draw_char( 0, CHARS_HIGH - 2, DIGIT + 48 );
                }
                else
                {
                    // Put choice in bottom left corner
                    draw_char( 1, CHARS_HIGH - 2, DIGIT + 48 );
                    
                    // Calculate level ID
                    const LEVEL_ID = select_level_first_digit * 10
                                        + DIGIT - 1;
                    
                    // Reset this value
                    select_level_first_digit = NO_DIGIT_SELECTED;

                    if( LEVEL_ID >= 0
                        && LEVEL_ID <= max_level_achieved
                    )
                    {
                        reset_vars_for_new_game();
                        current_level = LEVEL_ID;
                        start_level = LEVEL_ID;
                        
                        // Put tick after number
                        draw_char( 2, CHARS_HIGH - 2, TICK_ASCII ); 

                        // Start level intro after short delay
                        setTimeout(
                            function() { level_intro_screen( LEVEL_ID ); },
                            250
                        );
                    }
                    else
                    {
                        console.log( "2 digit level",
                                     LEVEL_ID + 1,
                                     "inaccessible" );
                        
                        // Put cross after number
                        draw_char( 2, CHARS_HIGH - 2, CROSS_ASCII ); 
                        
                        // Restart level select after short delay
                        setTimeout(
                            function() { select_level_screen(); },
                            250
                        );
                    }
                }
            }
        }
        else if( key_code.substring( 0, 3 ) == "Key" )
        {
            // If letter pressed, cancel any number selection
            select_level_first_digit = NO_DIGIT_SELECTED;
            draw_char( 0, CHARS_HIGH - 2, 32 );
            
            // Get ascii code of key press
            const ALPHA = key_code.substring( 3, 4 ).charCodeAt();

            // Ignore any non-letter
            if( ALPHA >= 65 && ALPHA <= 90 )
            {
                for( let n = 0; n < cheat_code_alpha.length; n++ )
                {
                    if( n < CHEAT_CODE_LEN - 1 
                        && cheat_code_alpha[n]
                            === NO_DIGIT_SELECTED
                    )
                    {
                        cheat_code_alpha[n] = ALPHA;
                        draw_char( n, CHARS_HIGH - 3, ALPHA );
                        break;
                    }
                    else if( cheat_code_alpha[n]
                                === NO_DIGIT_SELECTED )
                    {
                        draw_char( n, CHARS_HIGH - 3, ALPHA );
                        cheat_code_alpha[n] = ALPHA;
                       
                        let code = ""
                        for( let m = 0; m < cheat_code_alpha.length; m++ )
                        {
                            code += String.fromCharCode(
                                        cheat_code_alpha[m]
                                    );
                        }

                        console.log( "'cheat' code=", code );

                        // Check code is valid (dry run only,
                        // do *not* set player characteristics)
                        const CODE_OK = calc( code, true );

                        if( CODE_OK )
                        {
                            draw_char( CHEAT_CODE_LEN, CHARS_HIGH - 3, TICK_ASCII ); 
                            reset_vars_for_new_game();

                            // Get level number and player
                            // characteristics from code
                            // (this must be done after reset
                            //  above);
                            calc( code );

                            setTimeout(
                                function() {
                                    level_intro_screen( current_level );
                                },
                                250
                            );
                            return;
                        }
                        else
                        {
                            draw_char( CHEAT_CODE_LEN, CHARS_HIGH - 3, CROSS_ASCII ); 
                        }

                        for( let m = 0; m < cheat_code_alpha.length; m++ )
                        {
                            cheat_code_alpha[m] = NO_DIGIT_SELECTED;
                        }
                       
                        setTimeout(
                            function() { select_level_screen(); },
                            250
                        );
                    }
                } 
            }
        }
    }

    about_screen = function()
    {
        draw_screen( GAME_STATE_ABOUT,
                     [ "For Game Off Jam 2024",
                       "Code and graphics:",
                       "(C) MUCKYTATERS 2024",
                       "FREE AND OPEN SOURCE",
                       "Licensed under GPL3",
                       "github.com/MuckyTaters"
                     ],
                     "v1.0   hit enter/ESC"
                   );
        
        console.log( "About" );
    }

    level_intro_screen = function( level )
    {
        audio_stop_theme();
       
        // 1st line of level text is title
        const LEVEL_TITLE = LEVEL_INTRO_TEXT[level][0];

        // Remaining lines are text
        let level_text = [];
        for( let n = 1; n < LEVEL_INTRO_TEXT[level].length; n++ )
        {
            level_text.push( LEVEL_INTRO_TEXT[level][n] );
        }

        draw_screen( GAME_STATE_LEVEL_INTRO,
                     level_text,
                     "hit enter to play",
                     true
                   );

        stat_bar_alert(
            LEVEL_TITLE,
            DEFAULT_BG_COL,
            INTRO_TEXT_COL
        );

        console.log( LEVEL_TITLE );
    }

    //! Draw game over screen
    game_over_screen = function()
    {
        // Stop audio
        audio_cancel_all_FX();
        audio_stop_theme();

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;

        // Add key handler, this is IMPORTANT
        // as key handler will have been disabled
        // by calling function 'player_loses_life'.
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        let text = [ "GAME OVER" ];
        if( current_level > 0 )
        {
            text.push( "If you have a" );
            text.push( "'cheat' code you can" );
            text.push( "use it to start at" );
            text.push( "a higher level." );
            text.push( "See Opt 3 main menu." );
        }

        draw_screen( GAME_STATE_GAME_OVER,
                     text, 
                     "hit enter"
                   );
    
        console.log( "Game over screen" );
    }

    // TODO Totally rewrite this method as no bonus required!
    //! Draw level completion screen
    level_completion_screen = function()
    {
        // Add key handler, this is IMPORTANT
        // as key handler will have been disabled
        // by calling function 'player_loses_life'.
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // console.log( new Error().stack );

        audio_cancel_all_FX();

        let text = [];
        if( current_level < 0 || current_level >= LEVEL_OUTRO_TEXT.length )
        {
            text = ["Error"];
        }
        else
        {
            text = LEVEL_OUTRO_TEXT[current_level];
        }

        draw_screen( GAME_STATE_COMPLETED_LEVEL,
                     text,
                     "hit enter"
                   );

        current_level += 1;
        if( current_level > max_level_achieved )
        {
            max_level_achieved = current_level;
        }
    }

    //! Game completion (with cheating)
    game_completion_screen = function()
    {
        draw_screen( GAME_STATE_GAME_COMPLETED_WITH_CHEATS,
                     [ "Well done, you have",
                       "completed the final",
                       "level, starting from",
                       "level " + ( start_level + 1 ) + ".",
                       "To see the true game",
                       "completion screen,",
                       "start at level 1!"
                    ],
                     "hit enter"
                   );

        // Show score etc.
        stat_bar_update();

        console.log( "Game completion (with cheats) screen" );
    }

    //! Game completion (without cheating)
    true_game_completion_screen = function( phase = 0 )
    {
        // Flag set to true once sequence is complete
        const AT_END = phase >= DR_H_DEATH.length;
        
        // Play end tune
        if( phase == 0 )
        {
            audio_stop_theme();
            
            // If FX only, unmute so that theme now plays
            if( audio_mute == MUTE_STATUS_FX_ONLY )
            {
                audio_mute = MUTE_STATUS_FULL_AUDIO;
                unmute();
            }

            // Set theme to be loud
            audio_theme_oscillator.type = 'square';
            audio_theme_gain.gain.value = audio_master_gain * 2;
            
            audio_play_tune(
                audio_theme_oscillator,
                audio_theme_gain,
                AUDIO_THEME_DATA,
                74,  // start halfway through
                false,  // no repeat
                3.0,  // hi-speed
                -12,  // one octave lower
            );

            draw_screen( GAME_STATE_GAME_COMPLETED_SEQUENCE,
                         [ "!! You win !!" ],
                         ""
                       );
            
            // Show score etc.
            stat_bar_update();
        }
        else
        {
            console.log( "Game completion (without cheats) screen",
                         phase );
        }
        
        if( AT_END )
        {
            // Write footer
            const FOOTER = "hit enter to exit";
            write_line(
                FOOTER,
                CHARS_WIDE - FOOTER.length - 1,
                CHARS_HIGH - 1,
                'purple'
            );

            // Player can now hit enter to return to main menu
            game_state =  
                GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS;
        }
        else
        {
            // If not end, set callback for next sequence
            setTimeout( function() {
                true_game_completion_screen( phase + 1 )
                },
                500
            );
        }
    }

    //! Character graphic data quality check
    char_qual_check = function( c )
    {
        if( !isFinite( c )
            || c < 0
            || c > 255
        )
        {
            console.log( "Error: character code", c,
                         "is non-number or out-of-bounds (0-255)." );
            return false;
        }
        
        const NUM_ROWS = ASCII_DATA[c].length;

        if( NUM_ROWS == 0 )
        {
            console.log( "Error: no graphic data for ascii code", c );
            return false;
        }
        
        if( NUM_ROWS !== 8 )
        {
            console.log( "Error: graphic data for ascii code", c,
                         "has", NUM_ROWS, "rows, should be 8." );
            return false;
        }

        return true;
    }

    //! Draw char on stat bar
    /*! @param i: Horizontal pos (in whole character tiles)
     *  @param c: ASCII value of character
     *  @param fg: Foreground colo(u)r (as string)
     *  @param bg: Background colo(u)r (as string)
     */
    draw_char_sb = function( i, c, fg = DEFAULT_FG_COL, bg = DEFAULT_BG_COL )
    {
        return draw_char( i, 0, c, fg, bg, true );
    }

    //! Write line
    write_line = function( 
        line,
        start_char_i,
        char_j,
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        if( char_j < 0 || char_j >= CHARS_HIGH )
        {
            console.log( "Line write veritcal pos out-of-bounds." );
            return false;
        }

        if( start_char_i < 0 )
        {
            console.log( "Line write underflow." );
            return false;
        }

        let cursor_i = start_char_i;

        for( let n = 0; n < line.length; n++ )
        {
            if( cursor_i >= CHARS_WIDE )
            {
                console.log( "Line write overflow." );
                return false;
            }

            draw_char(
                cursor_i,
                char_j,
                line.charCodeAt( n ),
                fg_col,
                bg_col
            );
            
            // Move to next char
            cursor_i += 1;
        }
            
        return true;
    }

    //! Write message, centered hoz and veritcally
    write_mesg = function( mesg,
                           hoz_margin_in_chars = 0,
                           vert_margin_in_chars = 0,
                           hoz_centered = true,
                           vert_centered = true,
                           fg_col = DEFAULT_FG_COL,
                           bg_col = DEFAULT_BG_COL
                )
    {
        let error_free = true;

        // Calculate starting vert cursor pos
        let cursor_char_j = vert_centered ?
                Math.floor(
                    ( CHARS_HIGH - mesg.length * 2 + 1 ) / 2
                ) : 0;

        // Constrain within margins
        cursor_char_j
            = Math.min( 
                Math.max( cursor_char_j, vert_margin_in_chars ),
                CHARS_HIGH - vert_margin_in_chars
            );

        // Process each line
        for( let p = 0; p < mesg.length; p++ )
        {
            const ln = mesg[p];
        
            let cursor_char_i = hoz_centered ?
                Math.floor(
                    ( CHARS_WIDE - ln.length ) / 2
                ) : 0;

            // Constrain within margins
            cursor_char_i
                = Math.min( 
                    Math.max( cursor_char_i, hoz_margin_in_chars ),
                    CHARS_WIDE - hoz_margin_in_chars
                );

            error_free |= write_line(
                ln,
                cursor_char_i,
                cursor_char_j,
                fg_col,
                bg_col
            );

            // Move to next line (including an extra line of space)
            cursor_char_j += 2;
        }

        return error_free;
    }

    // Clear one line message to stat bar
    stat_bar_alert = function(
        mesg,
        fg_col = STAT_ALERT_FG_COL,
        bg_col = STAT_ALERT_BG_COL,
        blank_char_code = 32
    )
    {
        // HACK
        fg_col = CW ? COL_4_BG : COL_16_BLK;
        bg_col = CW ? COL_4_FG_1 : COL_16_CYN;

        let cursor_char_i
            = Math.floor(
                ( CHARS_WIDE - mesg.length ) / 2
            );

        for( let n = 0; n < cursor_char_i; n++ )
        {
            draw_char_sb( n, blank_char_code, fg_col, bg_col ); 
        }

        for( let n = 0; n < mesg.length; n++ )
        {
            draw_char_sb(
                cursor_char_i,
                mesg.charCodeAt( n ),
                fg_col,
                bg_col
            );
            
            // Move to next char
            cursor_char_i += 1;
        }
        
        for( let n = cursor_char_i; n < CHARS_WIDE; n++ )
        {
            draw_char_sb( n, blank_char_code, fg_col, bg_col ); 
        }
  
        if( mute ) { stat_bar_mute(); }
    }

    clear_stat_bar = function( bg_col = STAT_BG_COL )
    {
        stat_bar_alert( "", bg_col, bg_col );
    }

    stat_bar_lives = function()
    {
        const BASE_I = 0; // STAT_BAR_LEVEL_DIGITS;

        for( let n = 0; n < STAT_BAR_LIVES_MAX; n++ )
        {
            if( n < player_lives )
            {
                draw_char_sb(
                    BASE_I + n,
                    STAT_BAR_LIVES_ASCII,
                    STAT_LIVES_COL,
                    STAT_BG_COL
                );
            }
            else
            {
                draw_char_sb(
                    BASE_I + n,
                    STAT_BAR_EMPTY_ASCII,
                    STAT_LIVES_COL,
                    STAT_BG_COL
                );
            }
        }
    }

    stat_bar_armor = function( flash = false )
    {
        // Sometimes this is called as a callback
        // that is executed just afer the game is paused,
        // Return here to avoid overwriting the 'PAUSED'
        // message on the stat bar.
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        let i = STAT_BAR_LIVES_MAX;

        const FG_COL = flash ? STAT_BG_COL : STAT_ARMOR_COL;
        const BG_COL = flash ? STAT_ARMOR_COL : STAT_BG_COL;

        // Draw armo(u)r symbol
        draw_char_sb(
            i,
            STAT_BAR_ARMOR_ASCII,
            FG_COL,
            BG_COL
        );

        // Draw current armo(u)r values
        i += 1;
        stat_bar_number(
            player_armor_remaining,
            i,
            STAT_BAR_ARMOR_DIGITS,
            FG_COL,
            BG_COL
        );

        // Draw separator
        i += STAT_BAR_ARMOR_DIGITS;
        draw_char_sb(
            i,
            "/".charCodeAt( 0 ),
            FG_COL,
            BG_COL
        );

        // Draw max armo(u)r values
        i += 1;
        stat_bar_number(
            player_max_armor,
            i,
            STAT_BAR_ARMOR_DIGITS,
            FG_COL,
            BG_COL
        );

        // Armo(u)r level is critical, flash continuously
        if( player_armor_remaining === 0 )
        {
            setTimeout(
                function() { stat_bar_armor( !flash ); },
                STAT_BAR_FLASH_CONTINUAL_TICKS
            );
        }
        // Otherwise, schedule second call to clear flash if needed
        else if( flash )
        {
            setTimeout(
                function() { stat_bar_armor( false ); },
                STAT_BAR_FLASH_ONCE_TICKS
            );
        }
    }

    stat_bar_range = function( flash = false )
    {
        // Sometimes this is called as a callback
        // that is executed just afer the game is paused,
        // Return here to avoid overwriting the 'PAUSED'
        // message on the stat bar.
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        let i = STAT_BAR_LIVES_MAX + STAT_BAR_ARMOR_DIGITS * 2 + 3;

        const FG_COL = flash ? STAT_BG_COL : STAT_ARMOR_COL;
        const BG_COL = flash ? STAT_ARMOR_COL : STAT_BG_COL;

        // Draw weapon range symbol
        draw_char_sb(
            i,
            ASCII_WEAPON_RANGE,
            STAT_LIVES_COL,
            BG_COL
        );

        // Draw current weapon range value
        // (in whole chars, capped at 9)
        i += 1;
        stat_bar_number(
            Math.min(
                9,
                Math.round(
                    player_range_bonus / PX_PER_CHAR_HOZ
                )
            ),
            i,
            STAT_BAR_RANGE_DIGITS,
            FG_COL,
            BG_COL
        );

        // Schedule second call to clear flash if needed
        if( flash )
        {
            setTimeout(
                function() { stat_bar_range( false ); },
                STAT_BAR_FLASH_ONCE_TICKS
            );
        }
    }

    stat_bar_rate = function( flash = false )
    {
        // Sometimes this is called as a callback
        // that is executed just afer the game is paused,
        // Return here to avoid overwriting the 'PAUSED'
        // message on the stat bar.
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        let i = STAT_BAR_LIVES_MAX
                + STAT_BAR_ARMOR_DIGITS * 2 + 3
                + STAT_BAR_RANGE_DIGITS + 2;

        const FG_COL = flash ? STAT_BG_COL : STAT_ARMOR_COL;
        const BG_COL = flash ? STAT_ARMOR_COL : STAT_BG_COL;

        // Draw launch rate / missile speed symbol
        draw_char_sb(
            i,
            ASCII_ATTACK_RATE,
            STAT_LIVES_COL,
            BG_COL
        );

        // Draw current launch rate / missile speed value
        // (in whole chars, capped at 9)
        // Note: missile speed is used here as it increases
        //       in fixed increments so is easier to convert
        //       to an integer value
        i += 1;
        stat_bar_number(
            Math.min(
                9,
                Math.round(
                    player_missile_speed_bonus / PX_PER_CHAR_HOZ
                )
            ),
            i,
            STAT_BAR_RATE_DIGITS,
            FG_COL,
            BG_COL
        );

        // Schedule second call to clear flash if needed
        if( flash )
        {
            setTimeout(
                function() { stat_bar_rate( false ); },
                STAT_BAR_FLASH_ONCE_TICKS
            );
        }
    }

    stat_bar_move = function( flash = false )
    {
        // Sometimes this is called as a callback
        // that is executed just afer the game is paused,
        // Return here to avoid overwriting the 'PAUSED'
        // message on the stat bar.
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        let i = STAT_BAR_LIVES_MAX
                + STAT_BAR_ARMOR_DIGITS * 2 + 3
                + STAT_BAR_RANGE_DIGITS + 2
                + STAT_BAR_MOVE_DIGITS + 2;

        const FG_COL = flash ? STAT_BG_COL : STAT_ARMOR_COL;
        const BG_COL = flash ? STAT_ARMOR_COL : STAT_BG_COL;

        // Draw weapon range symbol
        draw_char_sb(
            i,
            ASCII_MOVE_SPEED,
            STAT_LIVES_COL,
            BG_COL
        );

        // Draw current weapon range value
        // (in whole chars, capped at 9)
        i += 1;
        stat_bar_number(
            Math.min( 9, player_move_bonus ),
            i,
            STAT_BAR_RANGE_DIGITS,
            FG_COL,
            BG_COL
        );

        // Schedule second call to clear flash if needed
        if( flash )
        {
            setTimeout(
                function() { stat_bar_move( false ); },
                STAT_BAR_FLASH_ONCE_TICKS
            );
        }
    }

    stat_bar_number = function(
        num,
        char_i,
        digits,
        fg_col = STAT_NUM_COL,
        bg_col = STAT_BG_COL
    )
    {
        let cursor_i = char_i + digits - 1;
        
        const NUM_AS_STRING = '' + num;
        const LEN = NUM_AS_STRING.length;
        const ACTIVE_DIGITS
            = Math.min( digits, LEN );
        const INACTIVE_DIGITS
            = digits - ACTIVE_DIGITS;

        // Draw active digits
        for( let n = 0; n < ACTIVE_DIGITS; n++ )
        {
            draw_char_sb(
                cursor_i,
                NUM_AS_STRING.charCodeAt( LEN - 1 - n ),
                fg_col,
                bg_col
            );

            cursor_i -= 1;
        }

        // Draw leading zeros
        const Z = '0'.charCodeAt( 0 );  // ASCII zero;
        for( let n = 0; n < INACTIVE_DIGITS; n++ )
        {
            draw_char_sb(
                cursor_i,
                Z,
                fg_col,
                bg_col
            );

            cursor_i -= 1;
        }
    }

    stat_bar_level = function()
    {
        stat_bar_number(
            current_level + 1,
            0,
            STAT_BAR_LEVEL_DIGITS
        );
    }

    stat_bar_score = function()
    {
        stat_bar_number(
            player_score, 
            STAT_BAR_LEVEL_DIGITS + STAT_BAR_LIVES_MAX,
            STAT_BAR_SCORE_DIGITS
        );
    }

    stat_bar_hi_score = function()
    {
        stat_bar_number(
            player_hi_score, 
            STAT_BAR_LEVEL_DIGITS 
                + STAT_BAR_LIVES_MAX + STAT_BAR_SCORE_DIGITS + 1,
            STAT_BAR_SCORE_DIGITS
        );
    }

    stat_bar_timer = function()
    {
        if( level_timer_max === 0 )
        {
            // Timer disabled
            return;
        }

        if( level_timer < 0 )
        {
            console.log( "level_timer", level_timer );
            const FLAG = level_timer % 2 == -1;
            stat_bar_number(
                0, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                FLAG ? STAT_TIMER_FG_COL : STAT_TIMER_BG_COL,
                !FLAG ? STAT_TIMER_FG_COL : STAT_TIMER_BG_COL
            );
            
        }
        else if( level_timer >= 10 )
        {
            stat_bar_number(
                level_timer, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                STAT_TIMER_FG_COL,
                STAT_TIMER_BG_COL
            );
        }
        else
        {
            // If timer in single digits, reverse colo(u)rs
            stat_bar_number(
                level_timer, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                STAT_TIMER_BG_COL,  // Note colo(u)r reversal
                STAT_TIMER_FG_COL
            );
        }
    }

    stat_bar_mute = function()
    {
        // Check game state, as this will determine where
        // mute symbol is placed.
        const IN_GAME = 
            game_state == GAME_STATE_IN_PLAY
            || game_state == GAME_STATE_LOST_LIFE
            || game_state == GAME_STATE_COMPLETED_LEVEL
            || game_state == GAME_STATE_GAME_COMPLETED_WITH_CHEATS
            || game_state == GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS
            || game_state == GAME_STATE_GAME_COMPLETED_SEQUENCE;

        // Determine character to represent
        // current mute status
        let c = MUTE_ASCII;
        if( audio_mute == MUTE_STATUS_FX_ONLY )
        {
            // If in game, use blank (i.e. space)
            c = IN_GAME ? 32 : FX_ONLY_ASCII;
        }
        else if( audio_mute == MUTE_STATUS_FULL_AUDIO )
        {
            // If in game, use blank (i.e. space)
            c = IN_GAME ? 32 : NO_MUTE_ASCII;
        }

        if( IN_GAME )
        {
            draw_char_sb(
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS - 1,
                c,
                STAT_NUM_COL,
                STAT_BG_COL
            );
        }
        else
        {
            draw_char_sb(
                CHARS_WIDE - 1,
                c,
                STAT_ALERT_FG_COL,
                STAT_ALERT_BG_COL
            );
        }
    }

    stat_bar_update = function()
    {
        clear_stat_bar();
        // stat_bar_level();
        stat_bar_lives();
        stat_bar_armor();
        stat_bar_range();
        stat_bar_rate();
        stat_bar_move();
        // stat_bar_score();
        // stat_bar_hi_score();
        stat_bar_timer();
        stat_bar_mute();
    }

    //! Parameter quality check for level draw functions
    draw_level_param_check = function(
        level_id,
        screen_i,
        screen_j
    )
    {
        if( !isFinite( level_id )
            || level_id < 0
                || level_id >= NUM_LEVELS
        )
        {
            console.log( "Error in 'draw_level',",
                         "level_id", level_id,
                         "is non-number or out-of-range." );
            return false;
        }
        
        const SCREENS_WIDE = LEVEL_DIMS[level_id][0];
        const SCREENS_HIGH = LEVEL_DIMS[level_id][1];

        if( !isFinite( screen_i )
            || screen_i < 0
                || screen_i >= SCREENS_WIDE
        )
        {
            console.log( "Error in 'draw_level',",
                         "screen_i", screen_i,
                         "is non-number or out-of-range",
                         "for level", level_id );
            return false;
        }

        if( !isFinite( screen_j )
            || screen_j < 0
                || screen_j >= SCREENS_HIGH
        )
        {
            console.log( "Error in 'draw_level',",
                         "screen_j", screen_j,
                         "is non-number or out-of-range",
                         "for level", level_id );
            return false;
        }

        return true;
    }

    //! Draw level chars and sprites
    draw_level = function(
        level_id,
        ctx = CANV_CHARS_CTX,
        screen_i = 0,
        screen_j = 0,
        player_char_i = -1,
        player_char_j = -1,
        player_flip_x = false
    )
    {
        console.log( "draw_level" );
        console.log( "level_id", level_id,
                     "screen_i", screen_i,
                     "screen_j", screen_j );

        if( !draw_level_param_check(
                level_id,
                screen_i,
                screen_j
            )
        ) { return; }

        // Update game state
        game_state = GAME_STATE_BUILDING_LEVEL;
   
        // If not yet defined, create (empty) level map
        // of appropriate size
        if( level_map_pixels.length == 0 )
        {
            const DIMS = LEVEL_DIMS[level_id];
            const MAP_WIDTH = DIMS[0] * CHARS_WIDE;
            const MAP_HEIGHT = DIMS[1] * CHARS_HIGH;
            for( let m = 0; m < MAP_HEIGHT; m++ )
            {
                level_map_pixels.push( [] );
                const ROW = level_map_pixels[m];
                
                for( let n = 0; n < MAP_WIDTH; n++ )
                {
                    // Background colo(u)r by default
                    ROW.push( LEVEL_MAP_BG_COL );
                }
            }

            console.log( "Created empty level map of", MAP_WIDTH,
                         "x", MAP_HEIGHT, "pixels" );
        }

        // Clear new enemy types
        new_enemy_types.clear();

        draw_level_sprites(
            level_id,
            screen_i,
            screen_j,
            player_char_i,
            player_char_j,
            player_flip_x
        );

        draw_level_chars(
            level_id,
            ctx,
            screen_i,
            screen_j
        );

        // Change game state to 'in play'
        game_state = GAME_STATE_IN_PLAY;

        // Check if timer needed for this screen
        {
            // Cellar
            if( level_id == 0 && screen_i == 0 && screen_j == 1 )
            {
                // Set timer for one minute
                level_timer_max = 60;
                level_timer = level_timer_max;
            }
            else
            {
                // Disable timer
                level_timer_max = 0;
                level_timer = 0;
            }
        }

        // Draw stat bar
        stat_bar_update();

        // Start main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    
        // Add key handler (defined further on)     
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Start in-play theme
        audio_stop_theme();
        // Note: sine wave (less harsh than square wave)
        audio_theme_oscillator.type = "triangle";
        audio_theme_gain.gain.value
                = audio_master_gain * AUDIO_THEME_IN_GAME_GAIN;
        audio_play_tune(
            audio_theme_oscillator,
            audio_theme_gain,
            AUDIO_THEME_DATA,
            0,  // start pos
            true,  // repeat
            current_level == 2 ? 5.0 : 1.0,  // speed
            current_level == 2 ? 0 : -24,  // octave offset
        );

        // Set reference point for timer
        level_timer_reference_ticks = Date.now();
        level_pause_total_ticks = 0;
        level_pause_ticks = 0;
   
        // Create pop-up introducing new enemy type
        new_thing_pop_up();

        // Collectables check on start position
        check_for_collectable();
    }

    //! Draw level sprites
    draw_level_sprites = function(
        level_id,
        screen_i = 0,
        screen_j = 0,
        player_char_i = -1,
        player_char_j = -1,
        player_flip_x = false
    )
    {
        console.log( "draw_level_sprites" );

        // Parameter quality check
        if( !draw_level_param_check(
                level_id,
                screen_i,
                screen_j
            )
        ) { return; }

        // Set custom colo(u)r palette
        if( LEVEL_PALETTE.length > level_id )
        {
            custom_colors = LEVEL_PALETTE[ level_id ];
        }
        else
        {
            custom_colors = {};
        }

        // If player position not given, use start position,
        // if available. If start position not found, raise
        // a fatal error.
        const USE_PLAYER_START_POS
            = player_char_i == -1 || player_char_j == -1;
        let player_start_pos_found = false;

        // Remove any existing sprites
        delete_all_sprites();
        
        // Create 'div' to hold all sprite 'div's
        top_sprite_div = document.createElement( "div" );
        top_sprite_div.id = "top_sprite_div" ;
        top_sprite_div.className = "div_class";
        top_sprite_div.style.width = "100%";
        top_sprite_div.style.height = "100%";
        top_div.appendChild( top_sprite_div );

        // Create invisible 'div' to hold all parked missiles
        parking_div = document.createElement( "div" );
        parking_div.id = "parking_div" ;
        parking_div.className = "div_class";
        parking_div.style.width = "100%";
        parking_div.style.height = "100%";
        parking_div.style.visibility = 'hidden';
        top_div.appendChild( parking_div );

        // Get reference to level data
        const LEVEL = LEVEL_DATA[level_id];

        // Get screen id within level
        const SCREEN_ID
            = screen_j * LEVEL_DIMS[level_id][0] + screen_i;

        // Get reference to screen data
        const SCREEN = LEVEL[SCREEN_ID];

        // Loop through screen data, finding sprite info
        for( let j = 0; j < CHARS_HIGH; j++ )
        {
            // Get reference to level line
            const SCREEN_LINE = SCREEN[j];

            for( let i = 0; i < CHARS_WIDE; i++ )
            {
                // Get i'th symbol on line
                const SYMBOL = SCREEN_LINE.substr( i, 1 );

                // Process player start location
                if( USE_PLAYER_START_POS && SYMBOL == 'p' )
                {
                    player_start_pos_found = true;
                    player_char_i = i;
                    player_char_j = j;
                    player_flip_x = false;
                }

                // Process player checkpoint
                if( SYMBOL == 'j' || SYMBOL == 'k' )
                {
                    chars[j][i].checkpoint = true;
                }
                else
                {
                    chars[j][i].checkpoint = false;
                }

                // Check if these coords are to be ignored
                // with regard to enemies and collectables
                if( ignore_coord_list.has(
                        unique_loc_code(
                            current_screen_i,
                            current_screen_j,
                            i,
                            j
                        )
                    )
                )
                {
                    // Skip to next set of coords
                    continue;
                }

                // Create enemy sprite
                if( SYMBOL in ENEMY_DATA )
                {
                    // Get reference to enemy data row
                    const ED = ENEMY_DATA[SYMBOL];

                    const NAME = ED[ED_COL_NAME];

                    const SPRITE_TYPE = ED[ED_COL_TYPE]; 
                   
                    if( !known_enemy_types.has( SPRITE_TYPE ) )
                    {
                        known_enemy_types.add( SPRITE_TYPE );

                        if( game_tips )
                        {
                            // Adding enemy type to this list
                            // will create a pop-up window
                            // when the level starts
                            new_enemy_types.add( SPRITE_TYPE );
                        }
                    }

                    const CHAR_ID = ED[ED_COL_ASCII];

                    // Check 'CHAR_ID' is valid
                    if( !char_qual_check( CHAR_ID ) )
                    {
                        console.log( "Error with image data",
                                     "for enemy '",
                                     ED[ED_COL_NAME],
                                     "', ignoring sprite at",
                                     i, j );
                        continue;
                    }

                    // Get enemy colo(u)r
                    const COL = get_color( NAME );

                    // Get missile type (MT)
                    const MT = ED[ED_COL_MT];

                    // Assume any sprite with missile capability
                    // is a blocking sprite
                    const BLOCKING = MT !== MT_NONE; 


                    let enemy = 0;

                    if( ED[ED_COL_TYPE] !== ET_DRAGON )
                    {
                        enemy = new EnemySprite(
                            // Note enemy number added to ID:
                            "enemy_sprite_" + enemy_sprites.size
                                + "_" + NAME,
                            i,
                            j,
                            ASCII_DATA[CHAR_ID],
                            COL,
                            ED[ED_COL_TYPE],
                            ED[ED_COL_HTK],
                            ED[ED_COL_START_DIR],
                            ED[ED_COL_TPM],
                            BLOCKING
                        );
                    }
                    else
                    {
                        // Create Dragon
                        enemy = new CaterpillarSprite(
                            // Note enemy number added to ID:
                            "enemy_sprite_" + enemy_sprites.size
                                + "_" + NAME,
                            i,
                            j,
                            3,  // Tail length
                            ASCII_DATA[CHAR_ID],  // Head image
                            ASCII_DATA[195],   // Tail image
                            COL,
                            ED[ED_COL_TYPE],  // Head type
                            ET_DRAGON_TAIL,  // Tail type
                            ED[ED_COL_HTK],
                            ED[ED_COL_START_DIR],
                            ED[ED_COL_TPM],
                            BLOCKING
                        );

                        console.log( "Dragon sprite created" );

                        // This ref will be used by tail segment
                        // sprites to call methods that remove
                        // their association with this sprite
                        // once they are destroyed.
                        current_boss_sprite = enemy;
                    }

                    // For certain enemies, set a flag that
                    // results in different movement behavio(u)r
                    // Note: sprite number is used to generate
                    //       this, so this flag roughly switches
                    //       with each enemy created.
                    if( current_level == 0 && enemy.type == ET_RAT )
                    {
                        enemy.alt_move
                            = enemy_sprites.size % 2 == 0;
                    }


                    console.log( enemy.id, enemy.type );

                    // Add extra info...

                    // Check MT is valid
                    if( MT !== MT_NONE && !( MT in MISSILE_DATA ) )
                    {
                        console.log( "Error: missile type", MT,
                                     "for enemy", enemy.id,
                                     "is not valid, enemy",
                                     "given no missile." );
                        enemy['MT'] = MT_NONE;
                    }
                    else
                    {
                        enemy['MT'] = MT;
                        if( MT !== MT_NONE )
                        {
                            // Calculate ranges, hoz and vert,
                            // in pixels and whole chars
                            enemy['range_px']
                                = MISSILE_DATA[MT][MD_COL_RANGE_IN_PX];
                            enemy['v_range_px']
                                = MISSILE_DATA[MT][MD_COL_V_RANGE_IN_PX];
                            enemy['range_ch']
                                = Math.ceil(
                                    enemy.range_px
                                        / PX_PER_CHAR_HOZ
                                );

                            enemy['v_range_ch']
                                = Math.ceil(
                                    enemy.v_range_px
                                        / PX_PER_CHAR_VERT
                                );

                            enemy['prev_launch_ticks'] = -1;
                            enemy['ticks_per_launch']
                                = ED[ED_COL_TPL];
                        }
                    }

                    enemy_sprites.add( enemy );
                    all_sprites.add( enemy );
                    
                    // Assume any enemy with missile capability
                    // is a blocking sprite
                    if( BLOCKING )
                    {
                        blocking_sprites.add( enemy );
                    }
                }
                // Create collectable sprite
                else if( SYMBOL in COLLECTABLE_DATA )
                {
                    // Get reference to collectable data row
                    const CD = COLLECTABLE_DATA[SYMBOL];

                    const NAME = CD[CD_COL_NAME];

                    const SPRITE_TYPE = CD[CD_COL_TYPE]; 
                   
                    if( !known_collectable_types.has( SPRITE_TYPE ) )
                    {
                        known_collectable_types.add( SPRITE_TYPE );

                        if( game_tips )
                        {
                            // Adding collectable type to this list
                            // will create a pop-up window
                            // when the level starts
                            new_collectable_types.add( SPRITE_TYPE );
                        
                            console.log( "NEW COLLECTABLE", SPRITE_TYPE );
                        }
                    }

                    const CHAR_ID = CD[CD_COL_ASCII];

                    // Check 'CHAR_ID' is valid
                    if( !char_qual_check( CHAR_ID ) )
                    {
                        console.log( "Error with image data",
                                     "for enemy '",
                                     CD[CD_COL_NAME],
                                     "', ignoring sprite at",
                                     i, j );
                        continue;
                    }

                    // Get enemy colo(u)r
                    const COL = get_color( NAME );

                    let collectable
                        = new Sprite(
                            // Note enemy number added to ID:
                            "collectable_sprite_" + collectable_sprites.size
                                + "_" + NAME,
                            i * PX_PER_CHAR_HOZ,
                            j * PX_PER_CHAR_VERT,
                            ASCII_DATA[CHAR_ID],
                            COL,
                            SPRITE_TYPE
                        );
     
                    console.log( collectable.id, collectable.type );

                    // Add 'char_i' and 'char_j' to this sprite
                    collectable['char_i'] = i;
                    collectable['char_j'] = j;

                    collectable_sprites.add( collectable );
                    all_sprites.add( collectable );
                }
            }
        }

        if( USE_PLAYER_START_POS
            && !player_start_pos_found
        )
        {   
            console.log( "Error in 'draw_level_sprites':",
                         "No player start position specified ",
                         "and no start position for screen",
                         SCREEN_ID, "in level", level_id );
            return;
        }
        
        // Create player sprite
        player_sprite
            = new CharSprite(
                "player_sprite",
                player_char_i,
                player_char_j,
                ASCII_DATA[PLAYER_CHAR_ASCII],
                PLAYER_COL,
                SPRITE_TYPE_PLAYER,
                DIR_RIGHT,
                player_ticks_per_move,
                // false,  // No need to remember start pos
                true  // blocking sprite
            );

        // Set player facing direction
        player_sprite.redraw( player_flip_x );
        player_sprite.dir = player_sprite.flip_x ?
            DIR_LEFT : DIR_RIGHT;

        // Add extra variables to player sprite...

        player_sprite['range_bonus'] = 0;

        // Number of chars player sprite has fallen
        // Note: 0 indicates player is not falling
        player_sprite['chars_fallen'] = 0;

        // Max number of chars player sprite can fall and live
        player_sprite['max_fall_chars'] = 4;

        // Remember if previous move was up
        player_sprite['last_move_up'] = false;

        // Remember last player checkpoint (default to start location)
        player_sprite['last_checkpoint']
            = [player_char_i,player_char_j,player_flip_x];

        player_sprite['prev_launch_ticks'] = -1;

        // player_sprite['ticks_per_launch'] = 330;

        // ...end of extra variables/methods
        
        // Store player sprite in list of blocking sprites
        blocking_sprites.add( player_sprite );

        // Store player sprite in list all sprites
        all_sprites.add( player_sprite );
    
        // Create missile managers...

        player_missile_man = new MissileManager(
            "player_mis_man",
            DEFAULT_MAX_PLAYER_MISSILES
        );

        enemy_missile_man = new MissileManager(
            "enemy_mis_man",
            DEFAULT_MAX_ENEMY_MISSILES
        );

        splat_missile_man = new MissileManager(
            "splat_mis_man",
            256
        );
    }

    //! Draw level characters
    /*! @param level_id: Level ID (starting at zero)
     */
    draw_level_chars = function(
        level_id,
        ctx = CANV_CHARS_CTX,
        screen_i = 0,
        screen_j = 0,
        clip_rect = [0, 0, CHARS_WIDE, CHARS_HIGH],
        dest_left = 0,
        dest_top = 0
    )
    {
        console.log( "draw_level_chars" );

        // Parameter quality check
        if( !draw_level_param_check(
                level_id,
                screen_i,
                screen_j
            )
        ) { return; }

        // Clipping rect quality check
        if( clip_rect.length !== 4 )
        {
            console.log( "Error in 'draw_level_chars',",
                         "clipping rect must have 4 elements." );
            return;
        }

        const CLIP_LEFT = clip_rect[0];
        const CLIP_TOP = clip_rect[1];
        const CLIP_RIGHT = clip_rect[2];
        const CLIP_BOTTOM = clip_rect[3];
        const CLIP_WIDTH = CLIP_RIGHT - CLIP_LEFT;
        const CLIP_HEIGHT = CLIP_BOTTOM - CLIP_TOP;

        // If these values vary from defaults, there
        // is clipping.
        // Note that when clipping occurs, characters
        // are drawn to canvas but nothing is written
        // to the 'chars' matrix.
        const CLIPPING =
            CLIP_LEFT !== 0
            || CLIP_TOP !== 0
            || CLIP_RIGHT != CHARS_WIDE
            || CLIP_BOTTOM != CHARS_HIGH
            || dest_left !== 0
            || dest_top !== 0;

        // If there is clipping, quality check the
        // clipping rectangle and destination offsets
        if( CLIPPING )
        {
            // console.log ( "draw_level_chars is clipped",
            //               clip_rect, dest_left, dest_top );

            if( CLIP_LEFT < 0
                || CLIP_TOP < 0
                || CLIP_RIGHT > CHARS_WIDE
                || CLIP_BOTTOM > CHARS_HIGH
            )
            {
                console.log( "Error in 'draw_level_chars',",
                             "clip_rect", clip_rect,
                             "has out-of-bounds value" );
                return;
            }
            else if( CLIP_RIGHT < CLIP_LEFT
                     || CLIP_BOTTOM < CLIP_TOP
            )
            {
                console.log( "Error in 'draw_level_chars',",
                             "clip_rect", clip_rect,
                             "has inverted values" );
                return;
            }

            // Check destination values
            if( dest_left < 0
                    || dest_left + CLIP_WIDTH > CHARS_WIDE
            )
            {
                console.log( "Error in 'draw_level_chars',",
                             "horizontally out-of-bounds",
                             "dest_left", dest_left,
                             "CLIP_WIDTH", CLIP_WIDTH );
                return;
            }
            else if( dest_top < 0
                    || dest_top + CLIP_HEIGHT > CHARS_HIGH
            )
            {
                console.log( "Error in 'draw_level_chars',",
                             "vertically out-of-bounds",
                             "dest_top", dest_top,
                             "CLIP_HEIGHT", CLIP_HEIGHT );
                return;
            }
        }

        // Set border colo(u)r to default
        document.body.style.background = DEFAULT_BORDER_COL;

        // Get reference to level data
        const LEVEL = LEVEL_DATA[level_id];

        // Get screen id within level
        const SCREEN_ID
            = screen_j * LEVEL_DIMS[level_id][0] + screen_i;

        // Get reference to screen data
        const SCREEN = LEVEL[SCREEN_ID];

        // Process differently, depending on colo(u)r way
        if( !CW )
        {
            // 'CGA' version

            // Set custom colo(u)r palette
            if( LEVEL_PALETTE.length > level_id )
            {
                custom_colors = LEVEL_PALETTE[ level_id ];
            }
            else
            {
                custom_colors = {};
            }

            // Set foreground colo(u)r, or use default
            const LEVEL_FG_COL = 'foreground' in custom_colors ?
                                custom_colors['foreground'] :
                                DEFAULT_FG_COL;

            // Set background colo(u)r, or use default
            const LEVEL_BG_COL = 'background' in custom_colors ?
                                custom_colors['background'] :
                                DEFAULT_BG_COL;

            // Check if colo(u)r specified for 'alpha'
            const ALP_IN_DEF_PAL = 'alpha' in DEFAULT_PALETTE;
            const ALP_IN_CUST_COLS = 'alpha' in custom_colors;
            const ALP_HAS_COL
                = ALP_IN_DEF_PAL || ALP_IN_CUST_COLS;
                    
            // Check if colo(u)r specified for brick symbol ('=')
            const BRCK_IN_DEF_PAL = '=' in DEFAULT_PALETTE;
            const BRCK_IN_CUST_COLS = '=' in custom_colors;
            const BRCK_HAS_COL
                = BRCK_IN_DEF_PAL || BRCK_IN_CUST_COLS;
            
            for( let j = 0; j < CLIP_HEIGHT; j++ )
            {
                // Calculate destination index
                const DEST_J = dest_top + j;

                // Calculate (potentially clipped) source index 
                const SRC_J = CLIP_TOP + j;

                // Get reference to level line
                const SCREEN_LINE = SCREEN[SRC_J];

                // Get reference to level map pixel row
                /// only used if there is no clipping
                const LEVEL_MAP_PIXELS_ROW
                    = CLIPPING ? 
                        0 : 
                        level_map_pixels[screen_j * CHARS_HIGH + j];

                for( let i = 0; i < CLIP_WIDTH; i++ )
                {
                    // Calculate destination index
                    const DEST_I = dest_left + i;

                    // Calculate (potentially clipped) source index 
                    const SRC_I = CLIP_LEFT + i;

                    // Get i'th symbol on line
                    const SYMBOL = SCREEN_LINE.substr( SRC_I, 1 );

                    const SYMBOL_RAW_ASCII = SYMBOL.charCodeAt( 0 );

                    // Treat certain punctation marks and all uppercase
                    // letters as bricks for solidity purposes,
                    // but otherwise render them as-is.
                    // This flag actions this further on.
                    const ALPHA = SYMBOL_RAW_ASCII == 32  // SPACE
                                  || SYMBOL_RAW_ASCII == 33  // !
                                  || SYMBOL_RAW_ASCII == 63  // ?
                                  ||( SYMBOL_RAW_ASCII >= 65
                                      && SYMBOL_RAW_ASCII <= 90 );

                    // Treat any ascii value >= 128 as literal,
                    // i.e. the ascii value of SYMBOL is the
                    // ascii value displayed on screen
                    const ASCII =
                            SYMBOL_RAW_ASCII > 127;

                    // True if ascii value of SYMBOL is displayed
                    // on screen
                    const LITERAL = ALPHA || ASCII;

                    // Quality check
                    if( !LITERAL && !( SYMBOL in LEVEL_NOTATION ) )
                    {
                        if( !CLIPPING )
                        {
                            // Error, unknown symbol in level map
                            console.log( "Unknown symbol: '",
                                         SYMBOL,
                                         "' in map of level ",
                                         level_id );
                        }

                        draw_char(
                            DEST_I,
                            DEST_J,
                            LEVEL_NOTATION["UNKNOWN"],
                            DEFAULT_FG_COL,
                            DEFAULT_BG_COL,
                            CLIPPING
                        );

                        // Move to next char
                        continue;
                    }

                    // Process player checkpoint
                    if( !CLIPPING )
                    {
                        if( SYMBOL == 'j' || SYMBOL == 'k' )
                        {
                            chars[DEST_J][DEST_I].checkpoint = true;
                        }
                        else
                        {
                            chars[DEST_J][DEST_I].checkpoint = false;
                        }
                    }

                    // Look up ASCII value for symbol 
                    // (for uppercase letters, use raw ASCII)
                    const C = LITERAL ? SYMBOL_RAW_ASCII :
                                      LEVEL_NOTATION[SYMBOL];
                   
                    // Declare fore and background colo(u)rs
                    fg_col = LEVEL_FG_COL;
                    bg_col = LEVEL_BG_COL;

                    // Check if colo(u)r specified for SYMBOL
                    const SYM_IN_DEF_PAL = SYMBOL in DEFAULT_PALETTE;
                    const SYM_IN_CUST_COLS = SYMBOL in custom_colors;
                    const SYM_HAS_COL
                        = SYM_IN_DEF_PAL || SYM_IN_CUST_COLS;

                    // Check if custom colo(u)rs specified for SYMBOL
                    if( SYMBOL == 'c' )
                    {
                        // TODO Collectables as sprites
                    }
                    else if( ALPHA && ALP_HAS_COL )
                    {
                        const COLS = ALP_IN_CUST_COLS ?
                                custom_colors['alpha'] :
                                DEFAULT_PALETTE['alpha'];
                        
                        if( COLS.length > 1 )
                        {
                            fg_col = COLS[0];
                            bg_col = COLS[1];
                        }
                        else if( COLS.length > 0 )
                        {
                            fg_col = COLS[0];
                        }
                    }
                    else if( 
                        ( ALPHA && BRCK_HAS_COL ) 
                        || SYM_HAS_COL
                    )
                    {
                        // For alpha, use brick colo(u)r scheme
                        const COLS 
                            = ALPHA ?
                                ( BRCK_IN_CUST_COLS ?
                                    custom_colors['='] :
                                    DEFAULT_PALETTE['=']
                                ) : ( 
                                  SYM_IN_CUST_COLS ?
                                    custom_colors[SYMBOL] :
                                    DEFAULT_PALETTE[SYMBOL]
                                );

                        // Custom foreground colo(u)r is always first
                        if( COLS.length > 0 )
                        {
                            if( !ALPHA )
                            {
                                fg_col = COLS[0];
                            }
                            else
                            {
                                // For alpha characters, invert colo(u)rs
                                bg_col = COLS[0];
                            }
                        }

                        // Custom background colo(u)r is optional second
                        if( COLS.length > 1 )
                        {
                            if( !ALPHA )
                            {
                                bg_col = COLS[1];
                            }
                            else
                            {
                                // For alpha characters, invert colo(u)rs
                                fg_col = COLS[1];
                            }
                        }
                    }
                   
                    // Draw character
                    draw_char_canvas(
                        ctx,
                        CLIPPING ? 0 : chars,
                        DEST_I,
                        DEST_J,
                        C,
                        fg_col,
                        bg_col
                    );

                    if( !CLIPPING )
                    {
                        // Get reference to character object
                        NEW_CHAR = chars[DEST_J][DEST_I];

                        // Remove any existing special tip
                        if( "tip" in NEW_CHAR )
                        {
                            delete NEW_CHAR.tip;
                        }

                        // Add solidity info to character
                        if( ALPHA 
                            || ( LITERAL && npc_ascii_codes.has( C ) )
                            // Hack
                            || ( LITERAL
                                 && ( SYMBOL == S1 || SYMBOL == S2 ) 
                            )
                        )
                        {
                            // Treat uppercase letters (and NPCs)
                            // as bricks, for solidity purposes
                            NEW_CHAR.solidity
                                = LEVEL_SOLID_ASCII_VALUES[ LEVEL_BRICK ];
                        }
                        else if( C in LEVEL_SOLID_ASCII_VALUES )
                        {
                            NEW_CHAR.solidity = LEVEL_SOLID_ASCII_VALUES[ C ];
                        }
                        else
                        {
                            if( current_level !== 2 )
                            {
                                NEW_CHAR.solidity = 0;
                            }
                            else
                            {
                                // For boss level, all
                                // permable chars are treated
                                // as ladders, this removes
                                // gravity.
                                NEW_CHAR.solidity = SOLID_TOP;
                            }
                        }

                        // Draw map pixel
                        {
                            // Get reference to map pixel
                            const MAP_PIXEL_I = 
                                    screen_i * CHARS_WIDE + DEST_I;

                            // Draw map pixel
                            if( LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                  != 'undefined'
                            )
                            {
                                if( ALPHA
                                    || char_is_platform_like( C )
                                )
                                {
                                    LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                        = LEVEL_MAP_PLATFORM_COL;
                                }
                                else if( C === LEVEL_LADDER )
                                {
                                    LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                        = LEVEL_MAP_LADDER_COL;
                                }
                            }
                        }  // End of draw map pixel
                    }
                }
            }
        } // End of 'CGA' colo(u)r way version
        else
        {
            // Simpler 'EGA' version

            for( let j = 0; j < CLIP_HEIGHT; j++ )
            {
                // Calculate destination index
                const DEST_J = dest_top + j;

                // Calculate (potentially clipped) source index 
                const SRC_J = CLIP_TOP + j;

                // Get reference to level line
                const SCREEN_LINE = SCREEN[SRC_J];

                // Get reference to level map pixel row
                /// only used if there is no clipping
                const LEVEL_MAP_PIXELS_ROW
                    = CLIPPING ? 
                        0 : 
                        level_map_pixels[screen_j * CHARS_HIGH + j];

                for( let i = 0; i < CLIP_WIDTH; i++ )
                {
                    // Calculate destination index
                    const DEST_I = dest_left + i;

                    // Calculate (potentially clipped) source index 
                    const SRC_I = CLIP_LEFT + i;

                    // Get i'th symbol on line
                    const SYMBOL = SCREEN_LINE.substr( SRC_I, 1 );

                    const SYMBOL_RAW_ASCII = SYMBOL.charCodeAt( 0 );

                    // Treat certain punctation marks and all uppercase
                    // letters as bricks for solidity purposes,
                    // but otherwise render them as-is.
                    // This flag actions this further on.
                    const ALPHA = SYMBOL_RAW_ASCII == 32  // SPACE
                                  || SYMBOL_RAW_ASCII == 33  // !
                                  || SYMBOL_RAW_ASCII == 63  // ?
                                  ||( SYMBOL_RAW_ASCII >= 65
                                      && SYMBOL_RAW_ASCII <= 90 );

                    // Treat any ascii value >= 128 as literal,
                    // i.e. the ascii value of SYMBOL is the
                    // ascii value displayed on screen
                    const ASCII =
                            SYMBOL_RAW_ASCII > 127;

                    // True if ascii value of SYMBOL is displayed
                    // on screen
                    const LITERAL = ALPHA || ASCII;
                    
                    // Quality check
                    if( !LITERAL && !( SYMBOL in LEVEL_NOTATION ) )
                    {
                        if( !CLIPPING )
                        {
                            // Error, unknown symbol in level map
                            console.log( "Unknown symbol: '",
                                         SYMBOL,
                                         "' in map of level ",
                                         level_id );
                        }

                        draw_char(
                            DEST_I,
                            DEST_J,
                            LEVEL_NOTATION["UNKNOWN"],
                            COL_4_FG_1,
                            COL_4_BG,
                            CLIPPING
                        );

                        // Move to next char
                        continue;
                    }

                    // Process player checkpoint
                    if( !CLIPPING )
                    {
                        if( SYMBOL == 'j' || SYMBOL == 'k' )
                        {
                            chars[DEST_J][DEST_I].checkpoint = true;
                        }
                        else
                        {
                            chars[DEST_J][DEST_I].checkpoint = false;
                        }
                    }

                    // Look up ASCII value for symbol 
                    // (for uppercase letters, use raw ASCII)
                    const C = LITERAL ? SYMBOL_RAW_ASCII :
                                      LEVEL_NOTATION[SYMBOL];
                   
                    let fg_col = COL_4_FG_1;
                    let bg_col = COL_4_BG;
                    if( ALPHA )
                    {
                        // Invert fg and bg
                        fg_col = COL_4_BG;
                        bg_col = COL_4_FG_1;
                    }
                    else if( LITERAL && npc_ascii_codes.has( C ) )
                    {
                        // Make NPCs same colo(u)r as items
                        fg_col = COL_4_FG_0;
                    }

                    // Draw character
                    draw_char_canvas(
                        ctx,
                        CLIPPING ? 0 : chars,
                        DEST_I,
                        DEST_J,
                        C,
                        fg_col,
                        bg_col
                    );

                    // Process collectable object location
                    if( SYMBOL == 'c' )
                    {
                        // TODO Collectables as sprites
                    }

                    if( !CLIPPING )
                    {
                        // Get reference to character object
                        NEW_CHAR = chars[DEST_J][DEST_I];

                        // Remove any existing special tip
                        if( "tip" in NEW_CHAR )
                        {
                            delete NEW_CHAR.tip;
                        }

                        // Add solidity info to character
                        if( ALPHA
                            || ( LITERAL && npc_ascii_codes.has( C ) )
                            // Hack
                            || ( LITERAL
                                 && ( SYMBOL == S1 || SYMBOL == S2 ) 
                            )
                        )
                        {
                            // Treat uppercase letters as bricks
                            NEW_CHAR.solidity
                                = LEVEL_SOLID_ASCII_VALUES[ LEVEL_BRICK ];
                        }
                        else if( C in LEVEL_SOLID_ASCII_VALUES )
                        {
                            NEW_CHAR.solidity = LEVEL_SOLID_ASCII_VALUES[ C ];
                        }
                        else
                        {
                            NEW_CHAR.solidity = 0;
                        }
                        
                        // Draw map pixel
                        {
                            // Get reference to map pixel
                            const MAP_PIXEL_I = 
                                    screen_i * CHARS_WIDE + DEST_I;

                            // Draw map pixel
                            if( LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                  != 'undefined'
                            )
                            {
                                if( ALPHA
                                    || char_is_platform_like( C )
                                )
                                {
                                    LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                        = LEVEL_MAP_PLATFORM_COL;
                                }
                                else if( C === LEVEL_LADDER || C === LEVEL_ROOF_TILE )
                                {
                                    LEVEL_MAP_PIXELS_ROW[MAP_PIXEL_I]
                                        = LEVEL_MAP_LADDER_COL;
                                }
                            }
                        }  // End of draw map pixel
                    }
                }
            }
        } // End of 'EGA' colo(u)r way version

        // Add player tips at specific locations on certain
        // levels/screens..
        if( !CLIPPING )
        {
            player_tips( level_id, screen_i, screen_j );
        }
    }

    //! Generate player tips for specified level/screen
    player_tips = function( level_id, screen_i, screen_j )
    {
        /////////////////////////////
        // LEVEL 0, SCREEN i=0, j=0
        if( level_id == 0 && screen_i == 0 && screen_j == 0 )
        {
            // Lady Muckford
            chars[9][4]["tip"] = [
                "",
                "Lady Muckford",
                ["Good luck, Ethren.",
                 "", "Bring my Lord",
                 "", "home safe, and may",
                 "", "God be with thee",
                 "", "on thy quest!",
                 ""
                ]
            ];

            // Faithful servant
            if( !level_meta[0][1][0].clear_of_enemies )
            {
                chars[14][3]["tip"] = [
                    "",
                    "Serving Man",
                    ["The Lord's cellar is",
                     "",
                     "full of rats the",
                     "",
                     "size of dogs. I know",
                     "",
                     "not what to do!"
                    ]
                ];
            }
            else
            {
                chars[14][3]["tip"] = [
                    "",
                    "Serving Man",
                    ["Thank you sir!",
                     "",
                     "Good luck fighting",
                     "",
                     "the goblins.",
                     "",
                     "I hear there is a",
                     "",
                     "secret tunnel into",
                     "",
                     "their fortress...",
                     ""
                    ]
                ];
            }

            // Timer warning
            chars[15][8]["tip"] = [
                "cellar_fumes",
                "Noxious fumes!",
                [ 
                "", "The air below is",
                "", "foul beyond measure.",
                "", "You will only",
                "", "survive one minute",
                "", "down there.",
                "", "Use [space] to fight",
                ""
                ]
            ];

            // Combat tip
            chars[8][18]["tip"] = [
                "first_combat",
                "Combat tip",
                [ 
                "", "Use [space] to",
                "", "attack in direction",
                "", "you are facing.",
                "", "A foe's wounds",
                "", "are marked on foe's",
                "", "top left corner.",
                ""
                ]
            ];

            // Height warning
            chars[6][15]["tip"] = [
                "height_warn",
                "Height warning!",
                [ 
                "", "This drop looks",
                "", "precarious. You can",
                "", "only fall 4 squares",
                "", "safely. Any more and",
                "", "you will lose a life",
                "", "regardless of armor.",
                ""
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 0, SCREEN i=1, j=0

        // Climbing
        else if( level_id == 0 && screen_i == 1 && screen_j == 0 )
        {
            chars[7][8]["tip"] = [
                "how_to_climb",
                "Tip",
                ["To climb:",
                "",
                 "Press up,",
                "",
                 "then quickly",
                "",
                 "press right",
                "",
                 "(or left)"
                ]
            ];
        }
        
        /////////////////////////////
        // LEVEL 0, SCREEN i=2, j=0
        else if( level_id == 0 && screen_i == 2 && screen_j == 0 )
        {
            // Old man advice about secret entrance
            if( !level_meta[0][0][2].clear_of_enemies )
            {
                chars[14][8]["tip"] = [
                    "", // "old_man",
                    "Old man of the woods",
                    [ 
                    "", "These pesky imps!",
                    "", "This tree is my home",
                    "", "yet I have no peace.",
                    "", "Rid me of them and",
                    "", "I shall aide ye, for",
                    "", "I know thy quest!",
                    ""
                    ]
                ];
            }
            else
            {
                chars[14][8]["tip"] = [
                    "", // "old_man",
                    "Old man of the woods",
                    [ 
                    "", "Ye seek a secret",
                    "", "path! Old mines lie",
                    "", "below this forest.",
                    "", "Look for disturbed",
                    "", "ground on yonder",
                    "", "side of this tree."
                    ]
                ];
            }

            chars[15][17]["tip"] = [
                "mines_ent",
                "Secret entrance!",
                [ 
                "", "The ground here is",
                "", "soft and recently",
                "", "disturbed. A few",
                "", "minutes digging",
                "", "reveals a trap door.",
                "", "Descend if you dare!",
                ""
                ]
            ];
        }
        
        /////////////////////////////
        // LEVEL 0, SCREEN i=3, j=0
        else if( level_id == 0 && screen_i == 3 && screen_j == 0 )
        {
            chars[12][5]["tip"] = [
                "",
                "Rotting corpse",
                [ 
                    "Long dead lies the",
                "", "cottager, pierced",
                "", "by goblin arrows.",
                "", "The Goblin Fortress",
                "", "must be close by!",
                ]
            ];
        }
        
        /////////////////////////////
        // LEVEL 0, SCREEN i=4, j=0
        else if( level_id == 0 && screen_i == 4 && screen_j == 0 )
        {
            chars[12][8]["tip"] = [
                "gob_fort_no_access",
                "Goblin Fortress",
                [ 
                "", "There is clearly",
                "", "no direct route",
                "", "into this fortress.",
                "", "You must find",
                "", "another way.",
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 0, SCREEN i=2, j=2
        else if( level_id == 0 && screen_i == 2 && screen_j == 2 )
        {
            chars[2][15]["tip"] = [
                "outer_guard_room_intro",
                "Ogre guards",
                [ 
                "", "Who goes there?",
                "", "A foolish human!",
                "", "We'll cook 'em up",
                "", "for supper, we will!",
                ""
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 1, SCREEN i=1, j=0
        else if( level_id == 1 && screen_i == 1 && screen_j == 0 )
        {
            chars[12][7]["tip"] = [
                "",
                "Dead Hobgoblin",
                [ 
                "", "Whilst examing this",
                "", "corpse you notice",
                "", "a breeze coming from",
                "", "the floor vents. Do",
                "", "they lead somewhere?"
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 1, SCREEN i=2, j=1
        else if( level_id == 1 && screen_i == 2 && screen_j == 1 )
        {
            chars[12][13]["tip"] = [
                "",
                "Dead Prisoner",
                [ 
                "", "One of Muckford's",
                "", "loyal soldiers,",
                "", "Tortured and killed",
                "", "by the Goblin",
                "", "King's minions."
                ]
            ];
            
            chars[12][18]["tip"] = [
                "Dying_prisnr",
                "Dying Prisoner",
                [ 
                "", "The... Goblin King",
                "", "is not what he",
                "", "seems... there's",
                "", "something worse",
                "", "inside him..."
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 1, SCREEN i=0, j=1
        else if( level_id == 1 && screen_i == 0 && screen_j == 1 )
        {
            chars[11][21]["tip"] = [
                "goblin_king",
                "The Goblin King",
                [ 
                "", "A weak mortal seeks",
                "", "to challenge ME!?",
                "", "Try thy best, and",
                "", "thy shall receive",
                "", "a very WARM welcome!"
                ]
            ];
        }

        /////////////////////////////
        // LEVEL 2, SCREEN i=0, j=0
        else if( level_id == 2 && screen_i == 0 && screen_j == 0 )
        {
            chars[1][3]["tip"] = [
                "lord_muckford",
                "Lord Muckford",
                [ 
                "", "Ethren!",
                "", "Is that really you?",
                "", "I thought I was",
                "", "going to die alone",
                "", "here..."
                ]
            ];
        }

    }


    //! Transition between screens within level
    screen_transition = function( dir )
    {
        console.log( "screen transition", dir );
        screen_transition_internal( dir );
    }

    //! Internal function for screen transition DO NOT USE
    screen_transition_internal = function(
        dir,  // Direction
        counter = 0,  // Transtition character count
        player_pos = 0,  // Stores hoz or vert coord of player
        screen_A_indices = [0,0],  // A = 'From' screen
        screen_B_indices = [0,0],  // B = 'To' screen
        player_flip_x = false
    )
    {
        // console.log( "screen transition", dir, counter, player_char_j );

        const VERT = dir == DIR_UP || dir == DIR_DOWN;

        // If transition has just started, pause the game
        if( counter == 0 )
        {
            // Remember player's pos
            // (this MUST come before delete sprites command)
            if( VERT )
            {
                player_pos = player_sprite.char_i;
            }
            else
            {
                player_pos = player_sprite.char_j;
            }

            // Remember player's facing dir
            player_flip_x = player_sprite.flip_x;

            // Set indices of current screen (A)
            screen_A_indices = [ current_screen_i, current_screen_j ];

            // Calculate indices of next screen (B)
            // Also perform error checks.
            switch( dir )
            {
                case DIR_UP:

                    // Error check
                    if( current_screen_j <= 0 )
                    {
                        console.log( "Error: top screen, cannot",
                                     "transition up." );
                        return;
                    }

                    // Set indices
                    screen_B_indices = [
                        current_screen_i,
                        current_screen_j - 1
                    ];

                    break;

                case DIR_RIGHT:

                    // Error check
                    if( current_screen_i
                            >= LEVEL_DIMS[current_level][0] - 1
                    )
                    {
                        console.log( "Error: rightmost screen, cannot",
                                     "transition right." );
                        return;
                    }

                    // Set indices
                    screen_B_indices = [
                        current_screen_i + 1,
                        current_screen_j
                    ];

                    break;

                case DIR_DOWN:

                    // Error check
                    if( current_screen_j
                            >= LEVEL_DIMS[current_level][1] - 1
                    )
                    {
                        console.log( "Error: bottom screen, cannot",
                                     "transition down." );
                        return;
                    }
                    
                    // Set indices
                    screen_B_indices = [
                        current_screen_i,
                        current_screen_j + 1
                    ];
                    
                    break;

                case DIR_LEFT:

                    // Error check
                    if( current_screen_i <= 0 )
                    {
                        console.log( "Error: leftmost screen, cannot",
                                     "transition left." );
                        return;
                    }

                    // Set indices
                    screen_B_indices = [
                        current_screen_i - 1,
                        current_screen_j
                    ];

                    break;
                
                default:
                    console.log( "Error in 'screen_transition':",
                                 "dir", dir, "not recognized(3)" );
                    return;
            }

            // Stop FX
            audio_cancel_all_FX();

            delete_all_sprites();

            // Stop keyboard event handling
            document.removeEventListener( 'keydown', handleKeyEvent );
            key_handler_on = false;

            // Stop main loop
            clearInterval( main_loop_interval_id );
            main_loop_interval_id = 0;

            // ... then set up callback for next iteration
            setTimeout(
                function() {
                    screen_transition_internal( 
                        dir,
                        1,  // counter
                        player_pos,
                        screen_A_indices,
                        screen_B_indices,
                        player_flip_x
                    );
                },
                SCREEN_TRANS_TICKS_PER_CHAR
            );
        }
        // Check if transition is still in progress,
        else if( ( VERT && counter < CHARS_HIGH )
                 || ( !VERT && counter < CHARS_WIDE )
        )
        {
            let screen_A_clip = [];
            let screen_A_dest_left = 0;
            let screen_A_dest_top = 0;
            let screen_B_clip = [];
            let screen_B_dest_left = 0;
            let screen_B_dest_top = 0;

            // Work out clip values and destination
            // for old screen and new screen at this
            // point in transition.
            switch( dir )
            {
                case DIR_UP:
                    screen_A_clip = [0, 0, CHARS_WIDE, CHARS_HIGH - counter];
                    screen_A_dest_left = 0;
                    screen_A_dest_top = counter;
                    screen_B_clip = [0, CHARS_HIGH - counter, CHARS_WIDE, CHARS_HIGH];
                    screen_B_dest_left = 0;
                    screen_B_dest_top = 0;
                    break;

                case DIR_RIGHT:
                    screen_A_clip = [counter, 0, CHARS_WIDE, CHARS_HIGH];
                    screen_A_dest_left = 0;
                    screen_A_dest_top = 0;
                    screen_B_clip = [0, 0, counter, CHARS_HIGH];
                    screen_B_dest_left = CHARS_WIDE - counter;
                    screen_B_dest_top = 0;
                    break;

                case DIR_DOWN:
                    screen_A_clip = [0, counter, CHARS_WIDE, CHARS_HIGH];
                    screen_A_dest_left = 0;
                    screen_A_dest_top = 0;
                    screen_B_clip = [0, 0, CHARS_WIDE, counter];
                    screen_B_dest_left = 0;
                    screen_B_dest_top = CHARS_HIGH - counter;
                    break;

                case DIR_LEFT:
                    screen_A_clip = [ 0, 0, CHARS_WIDE - counter, CHARS_HIGH];
                    screen_A_dest_left = counter;
                    screen_A_dest_top = 0;
                    screen_B_clip = [ CHARS_WIDE - counter, 0, CHARS_WIDE, CHARS_HIGH];
                    screen_B_dest_left = 0;
                    screen_B_dest_top = 0;
                    break;

                default:
                    console.log( "Error in 'screen_transition':",
                                 "dir", dir, "not recognized" );
                    return;
            }

            // Remains of current screen (A)
            draw_level_chars(
                current_level,
                CANV_CHARS_CTX,
                screen_A_indices[0],
                screen_A_indices[1],
                screen_A_clip,
                screen_A_dest_left,
                screen_A_dest_top
            );

            // Emerging new screen (B)
            draw_level_chars(
                current_level,
                CANV_CHARS_CTX,
                screen_B_indices[0],
                screen_B_indices[1],
                screen_B_clip,
                screen_B_dest_left,
                screen_B_dest_top
            );
            
            // Set up callback for next iteration
            setTimeout(
                function() {
                    screen_transition_internal( 
                        dir,
                        counter + 1,
                        player_pos,
                        screen_A_indices,
                        screen_B_indices,
                        player_flip_x
                    );
                },
                SCREEN_TRANS_TICKS_PER_CHAR
            );
        }
        // Otherwise, draw new level
        else
        {
            // Work out new position of player sprite
            let player_char_i;
            let player_char_j;
            switch( dir )
            {
                case DIR_UP:
                    player_char_i = player_pos;
                    player_char_j = CHARS_HIGH - 1;
                    break;

                case DIR_RIGHT:
                    player_char_i = 0;
                    player_char_j = player_pos;
                    break;

                case DIR_DOWN:
                    player_char_i = player_pos;
                    player_char_j = 0;
                    break;

                case DIR_LEFT:
                    player_char_i = CHARS_WIDE - 1;
                    player_char_j = player_pos;
                    break;

                default:
                    console.log( "Error in 'screen_transition':",
                                 "dir", dir, "not recognized(2)" );
                    return;
            }

            console.log( "DRAW NEW SCREEN", screen_B_indices );

            current_screen_i = screen_B_indices[0];
            current_screen_j = screen_B_indices[1];

            console.log( "new screen", current_screen_i,
                         current_screen_j );

            draw_level(
                current_level,
                CANV_CHARS_CTX,
                current_screen_i,
                current_screen_j,
                player_char_i,
                player_char_j,
                player_flip_x
            );
        }
    }

    // Additional method(s) for sprites that maintain
    // a whole-character position index (e.g. player_sprite)...
    
    // Calculate 'i' offset for given direction
    calc_i_offset = function( direction )
    {
        switch( direction )
        {
            case DIR_UP: return 0; break;
            case DIR_LEFT: return -1; break;
            case DIR_DOWN: return 0; break;
            case DIR_RIGHT: return 1; break;
            case DIR_NONE: return 0; break;
            default:
                console.log( new Error().stack );
                console.log( "Unknown dir for i offset", direction );
        }
    }
    
    // Calculate 'j' offset for given direction
    calc_j_offset = function( direction )
    {
        switch( direction )
        {
            case DIR_UP: return -1; break;
            case DIR_LEFT: return 0; break;
            case DIR_DOWN: return 1; break;
            case DIR_RIGHT: return 0; break;
            case DIR_NONE: return 0; break;
            default:
                console.log( new Error().stack );
                console.log( "Unknown dir for j offset", direction );
        }
    }

    //! Get hoz index of a character square offset from sprite's current character square
    get_offset_i = function( this_sprite, offset_i )
    {
        const RAW_ANS = ( this_sprite.char_i + offset_i ) % CHARS_WIDE; 
        return RAW_ANS >= 0 ? RAW_ANS : RAW_ANS + CHARS_WIDE; 
    }

    //! Get vert index of a character square offset from sprite's current character square
    get_offset_j = function( this_sprite, offset_j )
    {
        const RAW_ANS = ( this_sprite.char_j + offset_j ) % CHARS_HIGH; 
        return RAW_ANS >= 0 ? RAW_ANS : RAW_ANS + CHARS_HIGH; 
    }

    //! Get character under sprite (or at offset, in whole chars)
    get_char = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        if( !( ( 'char_i' in this_sprite ) && ( 'char_j' in this_sprite ) ) )
        {
            console.log( "Error, get_char called",
                         "on non-char this_sprite." );
            return;  // Return nothing
        }

        const NEW_I = offset_i == 0 ?
                        this_sprite.char_i :
                        get_offset_i( this_sprite, offset_i );
        
        const NEW_J = offset_j == 0 ?
                        this_sprite.char_j :
                        get_offset_j( this_sprite, offset_j );

        if( NEW_J < 0 || NEW_J >= CHARS_HIGH )
        {
            console.log( "Error: NEW_J", NEW_J, "out-of-bounds" );
            return;  // Return nothing
        }

        if( NEW_I < 0 || NEW_I >= CHARS_WIDE )
        {
            console.log( "Error: NEW_I", NEW_I, "out-of-bounds" );
            return;  // Return nothing
        }

        return chars[NEW_J][NEW_I];
    }

    //! Check if character, positioned relative to sprite, is solid
    /*! Returns -1, and logs error, if sprite has no char pos info */
    get_solidity = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        if( !( ( 'char_i' in this_sprite ) && ( 'char_j' in this_sprite ) ) )
        {
            console.log( "Error, solidity check called",
                         "on non-char this_sprite." );
            return -1;
        }

        // Return soldity of char at these indices
        return get_char( this_sprite, offset_i, offset_j ).solidity;
    }

    //! Returns true if char *below* sprite (+ offset) has solid top
    /*! Returns false and logs error, if sprite has no char pos info */
    on_solid_ground = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        if( this_sprite === player_sprite )
        {
            // Player
            return (
                get_solidity(
                    this_sprite,
                    offset_i,
                    offset_j + 1
                ) & ( SOLID_TOP | SOLID_ALL_PLAYER_ONLY )
            ) > 0;
        }
        else
        {
            // Enemy
            return (
                get_solidity(
                    this_sprite,
                    offset_i,
                    offset_j + 1
                ) & SOLID_TOP
            ) > 0;
        }
    }

    //! Returns true if character is ladder or similar
    char_is_ladder_like = function( C )
    {
            return C == LEVEL_LADDER
                   || C == LEVEL_FAKE_BRICK
                   || C == LEVEL_TREE_TRUNK
                   || C == LEVEL_BARREL
                   || C == LEVEL_ROOF_TILE
                   // For boss level, spaces count as ladders 
                   || ( C == LEVEL_SPACE && current_level === 2 );
    }

    //! Returns true if character is platform or similar
    char_is_platform_like = function( C )
    {
        return C == LEVEL_BRICK
               || C == LEVEL_ROCK_PLATFORM;
    }

    //! Returns true if char below sprite is a ladder, or has no slidity
    /*! Returns false and logs error, if sprite has no char pos info */
    can_descend = function( this_sprite )
    {
        return (
            char_is_ladder_like(
                get_char( this_sprite, 0, 1 ).char_id
            )
            || !on_solid_ground( this_sprite )
        );
    }

    //! Returns true if sprite is on a ladder (or equivalent)
    /*! Returns false and logs error, if sprite has no char pos info */
    on_ladder = function( this_sprite )
    {
        return char_is_ladder_like(
            get_char( this_sprite, 0, 0 ).char_id
        );
    }

    //! Returns true if char to left of sprite is right-permeable
    /*! Returns false and logs error, if sprite has no char pos info */
    can_move_left = function( this_sprite )
    {
        if( this_sprite == player_sprite )
        {
            return ( get_solidity( this_sprite, -1, 0 )
                        & ( SOLID_RIGHT | SOLID_ALL_PLAYER_ONLY ) 
                   ) == 0
                   && can_move( this_sprite, DIR_LEFT );
        }
        else
        {
            return ( get_solidity( this_sprite, -1, 0 ) & SOLID_RIGHT ) == 0
                   && can_move( this_sprite, DIR_LEFT );
        }
    }

    //! Returns true if char to right of sprite is left-permeable
    /*! Returns false and logs error, if sprite has no char pos info */
    can_move_right = function( this_sprite )
    {
        if( this_sprite == player_sprite )
        {
            return ( get_solidity( this_sprite, 1, 0 )
                        & ( SOLID_LEFT | SOLID_ALL_PLAYER_ONLY )
                   ) == 0
                   && can_move( this_sprite, DIR_RIGHT );
        }
        else
        {
            return ( get_solidity( this_sprite, 1, 0 ) & SOLID_LEFT ) == 0
                   && can_move( this_sprite, DIR_RIGHT );
        }
    }

    can_move_left_on_solid_ground = function( this_sprite )
    {
        return can_move_left( this_sprite )
               && on_solid_ground( this_sprite, -1, 0 );
    }

    can_move_right_on_solid_ground = function( this_sprite )
    {
        return can_move_right( this_sprite )
               && on_solid_ground( this_sprite, 1, 0 );
    }

    can_move_on_solid_ground = function( this_sprite, direction )
    {
        switch( direction )
        {
            case DIR_UP:
                return get_char( this_sprite ).char_id
                            == LEVEL_LADDER
                       && can_move( this_sprite, DIR_UP );
            
            case DIR_RIGHT:
                return can_move_right_on_solid_ground( this_sprite );
            
            case DIR_DOWN:
                return can_descend( this_sprite );
            
            case DIR_LEFT:
                return can_move_left_on_solid_ground( this_sprite );
            
            default:
                return false;
        }
    }

    //! Check if sprite's move blocked by another sprite
    /* If 'this_sprite' is a 'blocking' sprite and offset char
     * is occupied by another 'blocking' sprite, other sprite's
     * reference is returned. Otherwise, zero is returned.
     */
    blocked = function( this_sprite, offset_i, offset_j )
    {
        // If no offset then char is blocked by self
        if( offset_i == 0 && offset_j == 0 ) { return this_sprite; }

        if( this_sprite.blocking )
        {
            const I = get_offset_i( this_sprite, offset_i );
            const J = get_offset_j( this_sprite, offset_j );

            for( spr of blocking_sprites )
            {
                if( spr.char_i == I
                    && spr.char_j == J
                    && this_sprite.id !== spr.id
                ) { return spr; }
            }
        }

        return 0;
    }

    //! Returns true if sprite blocked by a non-player sprite
    /* Note: offsets indicate direction sprite wishes to move
     */
    blocked_by_non_player_spr = function(
        this_sprite,
        offset_i,
        offset_j
    )
    {
        const BLOCKING_SPR = blocked( this_sprite, offset_i, offset_j );
        return BLOCKING_SPR !== 0 && BLOCKING_SPR !== player_sprite;
    }

    //! Returns true if char in direction 'dir' is permeable
    /*! Returns false and logs error, if 'dir' is invalid,
     *  or sprite has no char pos info */
    can_move = function( this_sprite, dir )
    {
        switch( dir )
        {
            case DIR_UP:
                return ( get_solidity( this_sprite, 0, -1 )
                         & ( SOLID_BOTTOM | SOLID_ALL_PLAYER_ONLY )  
                       ) == 0;
                       // && !blocked( this_sprite, 0, -1 );
                break;

            case DIR_LEFT:
                if( !'char_i' in this_sprite )
                {
                    console.log( "Error, sprite has no 'char_i'" );
                    return false;
                }
                return this_sprite.char_i > 0
                       && ( get_solidity( this_sprite, -1, 0 ) & SOLID_RIGHT ) == 0;
                       // && !blocked( this_sprite, -1, 0 );
                break;

            case DIR_DOWN:
                return ( get_solidity( this_sprite, 0, 1 ) & SOLID_TOP ) == 0;
                       // && !blocked( this_sprite, 0, 1 );
                break;

            case DIR_RIGHT:
                if( !'char_i' in this_sprite )
                {
                    console.log( "Error, sprite has no 'char_i'" );
                    return false;
                }

                return this_sprite.char_i < ( CHARS_WIDE - 1 )
                       && ( get_solidity( this_sprite, 1, 0 ) & SOLID_LEFT ) == 0;
                       // && !blocked( this_sprite, 1, 0 );
                break;

            default:
                console.log( "Error, unrecognized direction:", dir );
                return false;
        }
    }


    //////////////////////////////////////
    // Main loop processing
    main_loop = function()
    {
        // Get current time, in ticks
        const TICKS = Date.now();

        // Get time since previous frame, in milliseconds
        // (if no previous frame, use FRAME_DURATION as default )
        const TICKS_ELAPSED = prev_ticks < 0 ?
                                FRAME_DURATION :
                                TICKS - prev_ticks;
        
        // Calculate ticks elapsed as proportion of desired
        // frame duration
        const FRAME_SCALE = TICKS_ELAPSED / FRAME_DURATION;

        /*
        console.log( TICKS_ELAPSED, FRAME_SCALE,
                     "game_state", game_state );
        */

        // Calculate this for next frame
        prev_ticks = TICKS;

        // Check if timer needs updating
        if( level_timer_max !== 0 )
        {
            const TIME_REMAINING
                = level_timer_max
                    - Math.floor( 
                        ( TICKS - level_timer_reference_ticks
                                    - level_pause_total_ticks )
                            / 1000
                    );

            if( TIME_REMAINING !== level_timer )
            {
                level_timer = TIME_REMAINING;

                if( audio_mute !== MUTE_STATUS_MUTE_ALL
                    // && level_timer < 10
                )
                {
                    audio_play_FX( 'alert' );
                }

                // Update timer on stat bar
                stat_bar_timer();
            
                if( level_timer == 0 )
                {
                    if( audio_mute != MUTE_STATUS_MUTE_ALL )
                    {
                        // TODO play out of time FX
                    }
                    
                    console.log( "Out of time" );

                    player_loses_life();
                }
            }
        }

        // Check for player collision with enemy sprite(s)
        if( check_for_player_enemy_collision() ) { return; }

        // Calculate ticks elapsed since last player move
        const TICKS_SINCE_LAST_PLAYER_MOVE
            = player_sprite.prev_move_ticks < 0 ?
                TICKS : TICKS - player_sprite.prev_move_ticks;
       
        // Check for floor (or blocking sprite) below player sprite
        if( ( player_sprite.chars_fallen > 0
              && TICKS_SINCE_LAST_PLAYER_MOVE >= player_ticks_per_fall 
            )
            // This line ensures move speed inc.  does not prejudice
            // climbing and jumping ability by letting the player
            // 'hang' in the air for the same amount of time 
            || TICKS_SINCE_LAST_PLAYER_MOVE >= DEFAULT_TICKS_PER_FALL 
        ) 
        {
            // Check for falling to a screen below
            if( player_sprite.char_j == CHARS_HIGH - 1
                && !on_ladder( player_sprite )
                && current_screen_j 
                    < LEVEL_DIMS[current_level][1] - 1
            )
            {
                console.log( "Fall off bottom of screen" )
                screen_transition( DIR_DOWN );
                return;
            }
            // Otherwise check for solid ground
            // or blocking sprite as normal
            else if( !on_ladder( player_sprite )
                     && !on_solid_ground( player_sprite )
                     && !blocked( player_sprite, 0, 1 )
            )
            {
                // If falling, get next vertical char index
                const CH_J_BELOW = get_offset_j( player_sprite, 1 );
                
                // Add 'scent trail'
                if( scent_sprite === player_sprite )
                {
                    get_char( scent_sprite ).scent = DIR_DOWN; 
                }

                // Move player to char below
                if( player_sprite.move(
                        player_sprite.char_i,
                        CH_J_BELOW )
                )
                {
                    // Play fall audio FX
                    if( audio_mute !== MUTE_STATUS_MUTE_ALL )
                    {
                        audio_play_FX(
                            'fall', 
                            Math.pow( 0.75, player_sprite.chars_fallen ) 
                        );
                    }

                    // Update char position
                    player_sprite.char_j = CH_J_BELOW;

                    // Update number of chars fallen
                    player_sprite.chars_fallen += 1;

                    // Check for deadly player collisions
                    if( check_for_deadly_item_collision() ) { return; }
                    if( check_for_player_enemy_collision() ) { return; }
    
                    // Check for player collision with checkpoint
                    check_for_player_checkpoint();

                    // Check for collectable
                    // Note: this must be done *after* char indices
                    //       (i.e.. char_i and /or char_j) updated
                    check_for_collectable();

                    // Update previous move ticks
                    player_sprite.prev_move_ticks
                        = TICKS - player_sprite.ticks_per_move / 2;
                }
            }
            else if( player_sprite.chars_fallen >
                        player_sprite.max_fall_chars )
            {
                player_loses_life();
                return;
            }
            else
            {
                audio_cancel_FX( 'fall' );
                player_sprite.chars_fallen = 0;
            }
        }

        // Animate enemy sprites
        let enemies_to_die = [];
        for( const enemy of enemy_sprites )
        {
            // Calculate ticks elapsed since last enemy move
            const TICKS_SINCE_LAST_ENEMY_MOVE
                = enemy.prev_move_ticks < 0 ?
                    TICKS : TICKS - enemy.prev_move_ticks;

            // If next move not due, move to next enemy sprite
            if( TICKS_SINCE_LAST_ENEMY_MOVE < enemy.ticks_per_move )
            {
                continue;
            }

            let offset_i = calc_i_offset( enemy.dir );
            let offset_j = calc_j_offset( enemy.dir );

            // Check if current direction valid and/or
            // decide on next direction.
            switch( enemy.type )
            {
                // Static
                case ET_GOB_KING:
                case ET_STAT_ARC:
                    offset_i = 0;
                    offset_j = 0;
                    break;

                // Basic monster (left/right motion)
                case ET_GOBLIN:
                case ET_GOB_ARC:
                case ET_HOBGOB:
                case ET_OGRE:
                case ET_BEAR:
                case ET_WERERAT:

                    // Type 1 enemies reverse when reaching
                    // obstruction or end of platforms,
                    // so check for this
                    if( !on_solid_ground( enemy, offset_i, offset_j )
                        || !can_move( enemy, enemy.dir )
                        || blocked_by_non_player_spr( enemy, offset_i, offset_j )
                    )
                    {
                        // Reverse direction for next move
                        enemy.dir = DIR_REVERSE[enemy.dir];
                    
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }
                    break;

                // Bat (random, non-homing motion)
                case ET_BABY_DRAKE:
                case ET_FIRE_IMP:
                case ET_BAT:
                    {
                        // Get random digit 0-15 from time
                        const R = Math.floor( Math.random() * 16 );

                        // Type 2 enemies fly in a straight line
                        // then turn when reaching an obstruction
                        // but sometimes randomly change direction
                        if( R > 13 || !can_move( enemy, enemy.dir ) )
                        {
                            offset_i = 0;
                            offset_j = 0;

                            if ( R < 6 || R == 15 ) 
                            {
                                // Turn 90 deg anti-clockwise
                                enemy.dir = DIR_90_ANTI_CLOCKWISE[enemy.dir];
                            }
                            else if( R > 9 || R == 14 )
                            {
                                // Turn 90 deg clockwise
                                enemy.dir = DIR_90_CLOCKWISE[enemy.dir];
                            }
                            else
                            {
                                // Reverse direction
                                enemy.dir = DIR_REVERSE[enemy.dir];
                            }
                        }
                    }
                    break;

                case ET_DRAGON:
                    {
                        if( enemy.chars_moved_in_straight_line
                                > ( enemy.tail.length
                                    - enemy.num_tail_seg_killed )
                        )
                        {
                            // Get random digit 0-15 from time
                            let rnd = Math.floor( Math.random() * 16 );

                            // Find a new direction that is not
                            // a reversal of current direction.
                            let new_dir = DIR_NONE;
                            let safety = 0X0F;
                            do
                            {
                                if( rnd > 0x04 && new_dir !== DIR_NONE )
                                {
                                    // Home in on player
                                    new_dir = home_in( enemy );
                                }
                                else
                                {
                                    // Random direction
                                    new_dir = rnd & 0x03;
                                }

                                rnd = ( rnd + 1 ) & 0x0F;

                                if( safety-- <= 0 )
                                {
                                    new_dir = DIR_NONE;
                                    break;
                                }
                            } while( DIR_REVERSE[new_dir] === enemy.dir )
                                
                            enemy.dir = new_dir;
                            offset_i = calc_i_offset( enemy.dir );
                            offset_j = calc_j_offset( enemy.dir );
                            
                            enemy.chars_moved_in_straight_line = 0;
                        }
                        else
                        {
                            enemy.chars_moved_in_straight_line += 1;
                        }
                    }
                    break;

                case ET_DRAGON_TAIL:

                    if( !( "mobile" in enemy ) )
                    {
                        console.log( "Error, dragon tail segment",
                                     "is wrong type" );
                    }
                   
                    if( enemy.mobile )
                    {
                        const NEW_DIR = get_char( enemy ).scent;
                        switch( NEW_DIR )
                        {
                            case DIR_UP:
                                offset_i = 0;
                                offset_j = -1;
                                break;

                            case DIR_RIGHT:
                                offset_i = 1;
                                offset_j = 0;
                                break;

                            case DIR_DOWN:
                                offset_i = 0;
                                offset_j = 1;
                                break;

                            case DIR_LEFT:
                                offset_i = -1;
                                offset_j = 0;
                                break;

                            case DIR_NONE:
                                offset_i = 0;
                                offset_j = 0;
                                break;

                            default:
                                console.log( "Error: invalid direction",
                                            "for scent (",
                                            NEW_DIR,
                                            ") at offset_i=",
                                            offset_i,
                                            ", offset_j=",
                                            offset_j );
                                continue;

                        }

                        enemy.dir = NEW_DIR;
                    }
                    else
                    {
                        offset_i = 0;
                        offset_j = 0;
                    }
                    break;

                /*
                // Arrows (return to start pos when hit obstruction)
                case 3:  // Left moving
                case 4:  // Right moving

                    if( !can_move( enemy, enemy.dir ) )
                    {
                        // Reset position using offsets
                        offset_i = enemy.start_char_i - enemy.char_i;
                        // Note: reseting 'j' shouldn't be
                        //       needed, but best be safe
                        offset_j = enemy.start_char_j - enemy.char_j;
                    }
                    break;

                // Ghost (semi-random, semi-homing motion)
                case 5:
                    {
                        // Get random digit 0-15 from time
                        const R = Math.floor( Math.random() * 16 );

                        if( R > 10 )
                        {
                            // Home in on player
                            home_in( enemy );
                        }
                        else
                        {
                            // Random direction
                            enemy.dir = R % 4;
                        }
                    }
                    break;

                // Acid drop (drops when player is directly
                // below and within line of sight)
                case 6:

                    // Check if drop waiting at start pos
                    if( enemy.dir !== DIR_DOWN )
                    {
                        // If yes, check for line-of-sight
                        // with player directly below
                        if( enemy.char_i == player_sprite.char_i
                            && enemy.char_j < player_sprite.char_j
                        )
                        {
                            // Loop over characters from droplet
                            // to player
                            let line_of_sight = true;
                            for( let j = enemy.char_j + 1;
                                 j <= player_sprite.char_j;
                                 j++
                            )
                            {
                                // Get character
                                const C = chars[j][enemy.char_i];

                                // Reject if character has solid top
                                if( 'solidity' in C
                                    && ( ( C.solidity & SOLID_TOP ) > 0 )
                                )
                                {
                                    line_of_sight = false;
                                    break;
                                }
                            }
                            // If has line of sight, start drop moving
                            if( line_of_sight )
                            {
                                enemy.dir = DIR_DOWN;
                                offset_j = 1;

                                // Remove move delay be reseting
                                // this value
                                enemy.ticks_per_move
                                    = ENEMY_TICKS_PER_MOVE[enemy.type - 1];
                            }

                        }
                    }
                    // Otherwise, move drop till solid surface reached
                    else
                    {
                        if( !can_move( enemy, enemy.dir ) )
                        {
                            offset_i = 0;
                            offset_j = enemy.start_char_j - enemy.char_j;
                            enemy.dir = DIR_NONE;

                            // Freeze droplet for one second
                            enemy.ticks_per_move = 1000;
                        }
                    }
                    break;
                
                // Roaming monster than randomly ascends/desends
                // ladders, but otherwise moves as basic monster
                case :
                    {
                        // Get random digit 0-15 from time
                        const R = Math.floor( Math.random() * 16 );
                    
                        // Get current direction
                        const DIR = enemy.dir;

                        // Get alternative directions
                        const REV_DIR = DIR_REVERSE[enemy.dir];
                        const CW_DIR = DIR_90_CLOCKWISE[enemy.dir];
                        const ACW_DIR = DIR_90_ANTI_CLOCKWISE[enemy.dir];

                        const CAN_MOVE_FWD
                            = can_move_on_solid_ground( enemy, DIR );

                        const CAN_GO_BACK
                            = can_move_on_solid_ground( enemy, REV_DIR );

                        const CAN_TURN_CW
                            = can_move_on_solid_ground( enemy, CW_DIR );

                        const CAN_TURN_ACW
                            = can_move_on_solid_ground( enemy, ACW_DIR );

                        if( ( CAN_TURN_CW || CAN_TURN_ACW )
                            && ( R < 8 || !CAN_MOVE_FWD )
                        )
                        {
                            if( CAN_TURN_CW && CAN_TURN_ACW )
                            {
                                enemy.dir = ( R % 2 == 0 ) ?
                                                CW_DIR : ACW_DIR;
                            }
                            else
                            {
                                enemy.dir = CAN_TURN_CW ?
                                                CW_DIR : ACW_DIR;
                            }
                        }
                        else if( !CAN_MOVE_FWD && CAN_GO_BACK )
                        {
                            enemy.dir = REV_DIR;
                        }

                        // Adjust offsets to match new direction
                        if( enemy.dir != DIR )
                        {
                            offset_i = calc_i_offset( enemy.dir );
                            offset_j = calc_j_offset( enemy.dir );
                        }
                    }
                    break;

                // Flys and floor traps (up/down, repetatively)
                case 8:  // Fly
                case 9:  // Faster moving fly
                case 10:  // Floor trap
                case 11:  // Faster moving floor trap
                    switch( enemy.dir )
                    {
                        case DIR_NONE: // Start direction defaults to 'down'
                        case DIR_DOWN:
                            enemy.dir = DIR_UP;
                            offset_j = 1;
                            break;

                        case DIR_UP:
                            enemy.dir = DIR_DOWN;
                            offset_j = -1;
                            break;
                        
                        default:
                            offset_i = 0;
                            offset_j = 0;
                            console.log( "Error: Fly/trap has incorrect",
                                         "direction", enemy.dir );
                    }
                    break;
                */

                // Rat (moves as basic monster except falls
                // off end of platforms).
                case ET_RAT:

                    // Fall if char below is not solid
                    if( (
                            // Some rat's do not drop
                            !( "alt_move" in enemy )
                            || !enemy.alt_move
                        )
                        && !on_solid_ground( enemy ) )
                    {
                        enemy.dir = DIR_DOWN;
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }
                    // Check for obstruction
                    else if( !can_move( enemy, enemy.dir ) )
                    {
                        if( enemy.dir == DIR_DOWN )
                        {
                            // If fall is broken, choose random
                            // left/right direction
                            const R = Math.floor( Math.random() * 16 );
                            enemy.dir = R < 7 ?
                                DIR_LEFT : DIR_RIGHT;
                        }
                        else
                        {
                            // Reverse if obstruction encountered
                            enemy.dir = DIR_REVERSE[enemy.dir];
                        }
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }
                    break;

                default:
                    console.log( "Error, unrecognized sprite type.");
                    continue;

            }  // End of switch block

            // Update previous move ticks, even if no
            // move actually takes place (this is to prevent
            // enemy sprites being processed every frame should
            // their movement be blocked in all directions).
            enemy.prev_move_ticks = TICKS;

            // If at least one offset is non-zero, move sprite
            if( offset_i !== 0 || offset_j !== 0 )
            {
                // Flip enemy horizontally, if needed
                // ( regardless of blocking )
                if( offset_i > 0 && enemy.flip_x )
                {
                    enemy.redraw( false );
                }
                else if( offset_i < 0 && !enemy.flip_x )
                {
                    enemy.redraw( true );
                }

                // Move, if target char does not contain
                // a blocking sprite
                if( !blocked( enemy, offset_i, offset_j )
                    || enemy.type === ET_DRAGON
                    || enemy.type === ET_DRAGON_TAIL
                )
                {
                    if( enemy.type === ET_DRAGON )
                    {
                        // console.log( enemy.id, "Dragon NOT blocked" );
                        
                        if( "tail_mobilized" in enemy )
                        {
                            if( !enemy.tail_mobilized )
                            {
                                enemy.mobilize_tail();
                            }
                        }
                        else
                        {
                            console.log( "Error: 'tail_mobilized'",
                                         "not in dragon sprite." );
                        }
                    }

                    const NEW_I = get_offset_i( enemy, offset_i );
                    const NEW_J = get_offset_j( enemy, offset_j );

                    if( enemy.move( NEW_I, NEW_J ) && !enemy.blocking )
                    {
                        // If move succesful and enemy is non-blocking,
                        // check for collision with player (and
                        // thereby enemy kamikaze)
                        if( enemy.char_i == player_sprite.char_i
                            && enemy.char_j == player_sprite.char_j
                        )
                        {
                            console.log( "Kamikaze!", enemy.id );

                            // If collision, player takes a hit
                            armor_hit();
                            enemies_to_die.push( enemy );

                            // Move to next enemy
                            continue;
                        }
                    }
                }
                else
                {
                    if( enemy.type === ET_DRAGON )
                    {
                        if( "tail_mobilized" in enemy )
                        {
                            if( enemy.tail_mobilized )
                            {
                                enemy.immobilize_tail();
                            }
                        }
                        else
                        {
                            console.log( "Error: 'tail_mobilized'",
                                         "not in dragon sprite.(2)" );
                        }
                    }
                }
            }

            // Determine if enemy can/should launch missile
            if( enemy.MT !== MT_NONE 
                && 'prev_launch_ticks' in enemy
                && 'ticks_per_launch' in enemy
                && ( enemy.prev_launch_ticks == -1
                     || TICKS - enemy.prev_launch_ticks
                            >= enemy.ticks_per_launch
                )
            )
            {
                // Check for line of sight
                let line_of_sight = true;
                const DIFF_I = enemy.char_i - player_sprite.char_i;
                const DIFF_J = enemy.char_j - player_sprite.char_j;

                if( Math.abs( DIFF_J ) <= enemy.v_range_ch
                    && Math.abs( DIFF_I ) <= enemy.range_ch
                    && (
                        // Except for dragon,
                        // check enemy is facing correct direction
                        enemy.type === ET_DRAGON
                        || ( !enemy.flip_x && DIFF_I <= 0 )
                        || ( enemy.flip_x && DIFF_I >= 0 )
                    )
                )
                {
                    // If player and enemy on same level,
                    // just loop over whole chars
                    if( DIFF_J == 0 )
                    {
                        for( let i = enemy.char_i;
                             i != player_sprite.char_i;
                             i += -1 * Math.sign( DIFF_I )
                        )
                        {
                            if( chars[enemy.char_j][i].solidity
                                & SOLID_ALL == SOLID_ALL
                            )
                            {
                                line_of_sight = false;
                                break;
                            }
                        }
                    }
                    // Otherwise, loop over pixels
                    else
                    {
                        // This algorithm is far from optimal,
                        // buit will do for now.

                        const NUM_STEPS
                            = Math.max( Math.abs( DIFF_I ),
                                        Math.abs( DIFF_J )
                            ) + 1;

                        let px_i = player_sprite.px_left;
                        let px_j = player_sprite.px_top;
                        
                        const DIFF_PX_I
                            = enemy.px_left - px_i;
                        const DIFF_PX_J
                            = enemy.px_top - px_j;

                        const PX_I_INC
                            = DIFF_PX_I / NUM_STEPS;
                        const PX_J_INC
                            = DIFF_PX_J / NUM_STEPS;

                        for( let n = 0;
                             n < NUM_STEPS;
                             n++, px_i += PX_I_INC,
                                px_j += PX_J_INC
                        )
                        {
                            const CH_I_MIN
                                = Math.max(
                                    0,
                                    Math.floor(
                                        px_i / PX_PER_CHAR_HOZ
                                    )
                                );
                            const CH_I_MAX
                                = Math.min(
                                    CHARS_WIDE - 1,
                                    Math.ceil(
                                        px_i / PX_PER_CHAR_HOZ
                                    )
                                );
                            const CH_J_MIN
                                = Math.max(
                                    0,
                                    Math.floor(
                                        px_j / PX_PER_CHAR_VERT
                                    )
                                );
                            const CH_J_MAX
                                = Math.min(
                                    CHARS_HIGH - 1,
                                    Math.ceil(
                                        px_j / PX_PER_CHAR_VERT
                                    )
                                );
                            
                            for( let j = CH_J_MIN; j <= CH_J_MAX; j++ )
                            {
                                for( let i = CH_I_MIN; i <= CH_I_MAX; i++ )
                                {
                                    if( chars[j][i].solidity
                                        & SOLID_ALL == SOLID_ALL
                                    ) 
                                    {
                                        line_of_sight = false;
                                        break;
                                    }
                                }

                                if( !line_of_sight ) { break; }
                            }
                        }
                    }
                }
                else
                {
                    // If player is out of enemy range,
                    // do not check again for another
                    // 'ticks_per_launch' ticks.
                    enemy.prev_launch_ticks = TICKS;
                    line_of_sight = false;
                }

                if( line_of_sight )
                {
                    // Launch missile
                    let launch_ok = false;
                    if( enemy_missile_man.launch_MT(
                        enemy.MT,
                        enemy.px_left,
                        enemy.px_top,
                        calc_ang( -1 * DIFF_I, DIFF_J ),
                        enemy.type,
                        )
                    )
                    {
                        // Play launch FX
                        audio_play_FX( 'launch' );

                        // Only update this if launch succeeds
                        enemy.prev_launch_ticks = TICKS;
                    }
                }
            }
        }

        // Kill enemies ear-marked for death
        for( let n = 0; n < enemies_to_die.length; n++ )
        {
            kill_enemy( enemies_to_die[n] );
        }

        // Process missiles
        {
            // Process splats (no sprite-to-sprite)
            // collision detection
            splat_missile_man.process( -1, TICKS );

            const COLLISIONS 
                = player_missile_man.process( enemy_sprites, TICKS ); 
            
            for( let n = 0; n < COLLISIONS.length; n++ )
            {
                const COLLISIONS_PER_MISSILE = COLLISIONS[n];

                // Strike first adversary in each missile collision list
                if( COLLISIONS_PER_MISSILE.length > 0 )
                {
                    const ENEMY = COLLISIONS_PER_MISSILE[0];

                    if( ENEMY.type === ET_DRAGON_TAIL )
                    {
                        if( ENEMY.distal !== 0 )
                        {
                            game_tip_pop_up(
                                "only_last_tail_seg_can_be_hit",
                                "Top tip",  // Pop-up title
                                [ "Only the last tail",
                                  "", "segment is",
                                  "", "vunerable!",
                                  "", "Aim with care."
                                ]
                            );

                            console.log( "Cannot destroy tail",
                                         "segment", ENEMY.id,
                                         "as distal =",
                                         ENEMY.distal.id );

                            // Skip to next collision, if any
                            continue;
                        }
                        else
                        {
                            // Get proximal segment, and removal
                            // distal reference
                            if( ENEMY.proximal !== 0 )
                            {
                                ENEMY.proximal.distal = 0;
                            }

                            // Tail segments only have one life
                            kill_enemy( ENEMY );

                            // Remove segment from dragon
                            if( current_boss_sprite !== 0 
                                && current_boss_sprite.type 
                                    === ET_DRAGON
                            )
                            {
                                current_boss_sprite.remove_distal_tail_seg();
                            }
                        }
                    }
                    // Apply hit to enemy
                    else if( ENEMY.strike() )
                    {
                        // If enemy has sufficient hits, kill it
                        kill_enemy( ENEMY );

                        if( ENEMY.type == ET_GOB_KING )
                        {
                            level_completed();
                            return;
                        }
                        else if( ENEMY.type == ET_DRAGON )
                        {
                            level_completed();
                            return;
                        }
                    }
                }
            }
            
            const HITS_ON_PLAYER
                = enemy_missile_man.process( [ player_sprite ], TICKS ); 
            
            if( HITS_ON_PLAYER.length > 0 )
            {
                armor_hit();
                return;
            }
        }
    }

    // END OF MAIN LOOP
    //////////////////////////////////////


    // Create character object prototype
    character = function( i, j )
    {
        var char = new Object();
        
        char.char_id = 0;
        char.i = i;
        char.j = j;
        char.scent = DIR_NONE;
        char.solidity = 0;
        // Note: attribute 'tip' may be added elsewhere

        char.reset = function()
        {
            char.char_id = 0;
            char.scent = DIR_NONE;
            char.solidity = 0;

            // Remove 'tip' attribute if added elsewhere
            if( 'tip' in char )
            {
                delete char.tip;
            }
        }

        return char;
    }

    //! Delete all sprite objects and associated 'div's
    /*! This also deletes 'top_sprite_div' */
    delete_all_sprites = function()
    {
        // Remove all 'div's associated with sprites
        if( top_sprite_div != 0 )
        {
            top_sprite_div.remove();
        }

        // Set 'top_sprite_div' reference to NULL
        top_sprite_div = 0;

        // Delete all sprite objects
        for( const SPRITE of all_sprites )
        {
            delete SPRITE;
        }
        enemy_sprites.clear();
        collectable_sprites.clear();
        blocking_sprites.clear();
        all_sprites.clear();
        player_sprite = 0;

        // Delete missile manager(s)
        player_missile_man = 0;
        splat_missile_man = 0;
    }

    //! Check for player collision with deadly item
    check_for_deadly_item_collision = function()
    {
        if( LEVEL_DEADLY_ASCII_VALUES.has(
                get_char( player_sprite ).char_id
            )
        )
        {
            armor_hit();
            return true;
        }

        // If no collision, return false
        return false;
    }

    //! Check for player collision with enemy sprite(s)
    check_for_player_enemy_collision = function()
    {
        // Store player's character indices locally
        const i = player_sprite.char_i;
        const j = player_sprite.char_j;

        for( const enemy of enemy_sprites )
        {
            // Ignore blocking sprites here,
            // as collision (if any)
            // will be the result of a bug
            if( !enemy.blocking
                && enemy.char_i == i
                && enemy.char_j == j
            )
            {
                console.log( "Kamikaze!(2)", enemy.id );
                
                // Process collision
                armor_hit(); // player takes a hit
                kill_enemy( enemy ); // assume enemy kamikaze
                return true;
            }
        }

        // If no collision, return false
        return false;
    }

    //! Check for player collision with checkpoint
    check_for_player_checkpoint = function()
    {
        if( get_char( player_sprite ).checkpoint )
        {
            player_sprite.last_checkpoint
                = [ player_sprite.char_i,
                    player_sprite.char_j,
                    player_sprite.flip_x
                ];
        }
    }

    //! Check for player collision with collectable
    check_for_collectable = function()
    {
        // Store player's character indices locally
        const i = player_sprite.char_i;
        const j = player_sprite.char_j;

        for( const collectable of collectable_sprites )
        {
            if( collectable.char_i == i
                && collectable.char_j == j
            )
            {
                console.log( "Collision with", collectable.id );
                
                // Create collection FX
                audio_play_FX( 'collect' );
        
                // Apply item effect
                switch( collectable.type )
                {
                    case CT_ARM_REP_1:
                        armor_repair( 1 );
                        break;

                    case CT_ARM_REP_2:
                        armor_repair( 2 );
                        break;

                    case CT_ARM_REP_3:
                        armor_repair( 3 );
                        break;

                    case CT_ARM_ENH_1:
                        armor_enhance( 1 );
                        break;

                    case CT_ARM_ENH_2:
                        armor_enhance( 2 );
                        break;

                    case CT_ARM_ENH_3:
                        armor_enhance( 3 );
                        break;

                    case CT_XTRA_LF:
                        console.log( "EXTRA LIFE" );
                        player_lives += 1;
                        stat_bar_lives();
                        game_tip_pop_up(
                            "",  // Always show life pop-ups
                            "Extra life",  // Pop-up title
                            [ "This item has",
                              "",
                              "given you an",  // Pop up text
                              "",
                              "extra life!"
                            ]
                        );
                        break;

                    case CT_WEP_RNG:
                        console.log( "WEAPON RANGE+" );
                        player_range_bonus += PX_PER_CHAR_HOZ;
                        stat_bar_range( true );
                        game_tip_pop_up(
                            "wpn_rng",  // game tip type
                            "Weapon range",  // Pop-up title
                            [ "This item has",
                              "",
                              "increased your",  // Pop up text
                              "",
                              "weapon range",
                              "",
                              "by 1 square."
                            ]
                        );
                        break;

                    case CT_ATT_RT:
                        console.log( "ATTACK RATE+" );
                        player_missile_speed_bonus += PX_PER_CHAR_HOZ; // in PXPS
                        player_ticks_per_launch *= 0.9; // 10% inc. in fire rate
                        stat_bar_rate( true );
                        game_tip_pop_up(
                            "att_rate",  // game tip type
                            "Attack rate+",  // Pop-up title
                            [ "This item has",
                              "",
                              "increased your",  // Pop up text
                              "",
                              "attack speed",
                              "",
                              "and freqency"
                            ]
                        );
                        break;

                    case CT_MV_SPD:
                        console.log( "MOVE SPEED+" );
                        player_ticks_per_move *= 0.8; // 20% inc. in speed
                        player_ticks_per_fall *= 0.8; // 20% inc. in speed
                        player_move_bonus += 1;

                        // Player sprite needs updating separately
                        player_sprite.ticks_per_move *= 0.8;

                        stat_bar_move( true );
                        game_tip_pop_up(
                            "mv_spd",  // game tip type
                            "Move speed+",  // Pop-up title
                            [ "This item has",
                              "",
                              "increased your",  // Pop up text
                              "",
                              "move speed",
                            ]
                        );
                        break;

                    default:
                        console.log( "Error: unrecognized",
                                     "collectable type:",
                                     collectable.type );
                        // Still remove the collectable, below
                }

                // Add coords to ignore list so that
                // collectable does not appear again
                // if screen is revisited
                ignore_coord_list.add(
                    unique_loc_code(
                        current_screen_i,
                        current_screen_j,
                        i,
                        j
                    )
                );

                // Destroy sprite's canvas
                top_sprite_div.removeChild( collectable.canvas );

                // Delete sprite object by removing
                // all references to it
                collectable_sprites.delete( collectable );
                all_sprites.delete( collectable );

                // Mark level as clear of enemies, if appropriate
                if( enemy_sprites.size === 0 )
                {
                    level_meta
                        [current_level]
                            [current_screen_j]
                                [current_screen_i]
                                    .clear_of_collectables = true;
                
                    console.log( current_level,
                                 current_screen_j,
                                 current_screen_i,
                                 "clear of collectables" );
                }

                return true;
            }
        }

        // If no collision, return false
        return false;
        // TODO: on level completion set level_map_pixels to []
    }

    //! Initialize audio FX
    init_audio = function()
    {
        // Turn off mute
        audio_mute = MUTE_STATUS_FULL_AUDIO;
        stat_bar_mute();

        // Create audio context
        audio_context = new AudioContext();

        // Create theme...

        // Create theme oscillator instance
        audio_theme_oscillator = audio_context.createOscillator();
        audio_theme_oscillator.type = "square";
        audio_theme_oscillator.frequency.value = 10;   // Low Hz
        
        // Start theme FX oscillator
        audio_theme_oscillator.start();

        // Create theme FX gain instance
        audio_theme_gain = audio_context.createGain();
        audio_theme_gain.gain.value = audio_master_gain;

        // If appropriate, start theme
        if( game_state !== GAME_STATE_IN_PLAY )
        {
            audio_play_tune(
                audio_theme_oscillator,
                audio_theme_gain,
                AUDIO_THEME_DATA,
                0,  // start pos
                true,  // repeat
                1.25, // 1.0,  // speed
                -12
            );
        }
    }

    //! Play tune
    audio_play_tune = function(
        osc,
        gain,
        data,
        pos = 0,
        repeat = false,
        speed_ratio = 1.0,
        note_offset = 0,
        play_when_FX_only_selected = false
    )
    {
        let duration = 250;  // Default ticks to next callback
                             // when audio is muted.

        // If full mute (or FX only and not completion fanfare),
        // skip straight to callback, i.e. don't play note.
        if( ( audio_mute == MUTE_STATUS_FX_ONLY
                && play_when_FX_only_selected )
            || audio_mute == MUTE_STATUS_FULL_AUDIO
        )
        {
            // Do this to prevent division by zero or negative durations
            if( speed_ratio <= 0 )
            {
                console.log( "Error: tune speed ratio <= 0, setting to 1." );
                speed_ratio = 1;
            }

            // Check for end of tune
            if( pos >= data.length )
            {
                if( repeat )
                {
                    // If repeat, reset 'pos'
                    pos = 0;
                }
                else
                {
                    // If no repeat, cancel previous note and return
                    if( osc.numberOfOutputs > 0 ) { osc.disconnect(); }
                    if( gain.numberOfOutputs > 0 ) { gain.disconnect(); }
                    console.log( "End of tune" );
                    return;
                }
            }

            // Get note ID and duration
            const NOTE_ID
                = data[pos][0] == 0 ? 
                    0 :  // If silence (note id == 0), use zero 
                    data[pos][0] + note_offset;  // Otherwise offset

            duration = data[pos][1] / speed_ratio;

            // Note ID zero (or less) is treated as silence
            if( NOTE_ID == 0 )
            {
                // console.log( "Playing pause", pos, NOTE_ID, duration );
                if( osc.type == "square" )
                {
                    // Stop previous note playing
                    if( osc.numberOfOutputs > 0 ) { osc.disconnect(); }
                    if( gain.numberOfOutputs > 0 ) { gain.disconnect(); }
                }
            }
            else
            {
                // console.log( "Playing note", pos, NOTE_ID, duration );

                // Set note freq
                if( osc.type == "sine" )
                {
                    // For smooth waveforms, change of freq
                    // requires smoothing
                    osc.frequency
                        .linearRampToValueAtTime(
                            440 * Math.pow( 2, ( NOTE_ID - 57 ) / 12 ),
                            audio_context.currentTime
                                // Note: convert duration to secs
                                 + duration / 1000 / 10
                        );

                    /*
                    // For sine waveform, use attack and decay 
                    // requires smoothing
                    osc.gain.gain
                        .linearRampToValueAtTime(
                            0,
                            audio_context.currentTime
                                // Note: convert duration to secs
                                 + duration / 1000 / 10
                        );
                    */
                }
                else
                {
                    // Otherwise, immediately change freq
                    osc.frequency.setValueAtTime(
                        440 * Math.pow( 2, ( NOTE_ID - 57 ) / 12 ),
                        audio_context.currentTime
                    );
                }

                // Set note playing
                osc.connect( gain ).connect( audio_context.destination );
            }   
        }

        // For in-game theme, speed up when timer is on
        if( game_state == GAME_STATE_IN_PLAY
            && level_timer_max !== 0
        )
        {
            duration *= 0.50;
        }

        // Create call to play next note
        const CALLBACK = setTimeout(
            function()
            {
                audio_play_tune(
                    osc,
                    gain,
                    data,
                    pos + 1,
                    repeat,
                    speed_ratio,
                    note_offset
                );
            },
            duration
        );

        // If this is theme, store callback, otherwise ignore
        if( osc == audio_theme_oscillator )
        {
            audio_theme_callback = CALLBACK;
        }
    }

    audio_play_FX = function( name, freq_mult = 1.0 )
    {
        // Flag up invalid FX name, even if FX muted.
        if( !name in FX_DATA )
        {
            console.log( "Error: unknown FX name '", name, "'" );
            return false;
        }

        // If FX muted, do nothing but return success
        if( audio_mute == MUTE_STATUS_MUTE_ALL )
        {
            return true;
        }

        // Get reference to FX
        const FX = FX_DATA[name];

        // Check if oscillator instance already exists,
        // and if not create it
        if( !( "osc" in FX ) )
        {
            // Take this opportunity to check duration specified,
            // even though it is not needed to create oscillator
            if( !( "dur" in FX ) )
            {
                console.log( "Error: no duration specified",
                             "for FX named '", name, "'" );
                return false;
            }

            oscillator = audio_context.createOscillator();
            if( "type" in FX )
            {
                oscillator.type = FX.type;
            }
            else
            {
                console.log( "Error: no waveform type specified",
                             "for FX named '", name, "'" );
                return false;
            }

            // Start the oscillator (it will not be audible
            // until connected)
            oscillator.start();

            // Store for later use
            FX['osc'] = oscillator;
        }
        
        // Check if gain instance already exists,
        // and if not create it
        if( !( "gain" in FX ) )
        {
            gain = audio_context.createGain();
            if( "vol" in FX )
            {
                gain.gain.value = audio_master_gain * FX.vol;
            }
            else
            {
                gain.gain.value = audio_master_gain;
            }

            // Store for later use
            FX['gain'] = gain;
        }

        // If static frequency specified, set that now
        if( "freq" in FX )
        {
            FX.osc.frequency.value = FX.freq * freq_mult;
        }
        // If freqency is dynamic, set linear ramp
        else if( 'start_freq' in FX && 'end_freq' in FX )
        {
            FX.osc.frequency
                .setValueAtTime(
                    FX.start_freq * freq_mult,
                    audio_context.currentTime
                );
            FX.osc.frequency
                .linearRampToValueAtTime(
                    FX.end_freq * freq_mult,
                    audio_context.currentTime
                        // Note: convert duration to secs
                        + FX.dur / 1000
                );
        }
        else
        {
            console.log( "Error: no frequency(ies) specified",
                         "for FX named '", name, "'" );
            return false;
        }

        // Start playing FX
        FX.osc.connect( FX.gain )
                .connect( audio_context.destination);

        // Set duration
        setTimeout(
            function () { audio_cancel_FX( name ); },
            FX.dur
        );

        return true;
    }

    audio_cancel_FX = function( name )
    {
        if( !name in FX_DATA )
        {
            console.log( "Error: unknown FX name '", name, "'" );
            return false;
        }
        
        const FX = FX_DATA[name];

        // Disconnet oscillator
        if( "osc" in FX && FX.osc.numberOfOutputs > 0 )
        {
            FX.osc.disconnect();
        }

        // Disconnect gain
        if( "gain" in FX && FX.gain.numberOfOutputs > 0 )
        {
            FX.gain.disconnect();
        }

        return true;
    }

    //! Stop theme playing
    audio_stop_theme = function()
    {
        if( audio_theme_callback !== 0 )
        {
            clearTimeout( audio_theme_callback );
            audio_theme_callback = 0;
        }
        if( audio_theme_oscillator.numberOfOutputs > 0 )
        {
            audio_theme_oscillator.disconnect();
        }
        if( audio_theme_gain.numberOfOutputs > 0 )
        {
            audio_theme_gain.disconnect();
        }
    }

    //! Cancel all FX (except theme)
    audio_cancel_all_FX = function()
    {
        audio_cancel_FX( 'splat' );
        audio_cancel_FX( 'launch' );
        audio_cancel_FX( 'fall' );
        audio_cancel_FX( 'collect' );
        audio_cancel_FX( 'alert' );
    };

    calc = function( code, dry_run = false )
    {
        if( code.length !== 8 )
        {
            console.log( "Code wrong length" );
            return false;
        }

        const PART_1_A26 = code.substring( 0, 3 );
        const PART_2_A26 = code.substring( 3, 8 );

        let n1 = conv_from_a26( PART_1_A26 );
        let n2 = conv_from_a26( PART_2_A26 );

        const CHKS = ( n2 >> ( B5 + B6 + B7 ) );
        
        const N2_LESS_CHKS = n2 - ( CHKS << ( B5 + B6 + B7 ) );

        /*
        console.log( "P1", PART_1_A26, n1,
                     "P2", PART_2_A26, n2,
                     "CHKS", CHKS,
                     "N2_LESS_CHKS", N2_LESS_CHKS );
        */

        if( CHKS !== chks( n1, B8, N2_LESS_CHKS ) )
        {
            console.log( "Checksum failed" )
            return false;
        }

        if( dry_run ) { return true; }

        // Part 1
        const V1 = n1 & ( Math.pow( 2, B1 ) - 1 );
        n1 >>= B1;
        const V2 = n1 & ( Math.pow( 2, B2 ) - 1 );
        n1 >>= B2;
        const V3 = n1 & ( Math.pow( 2, B3 ) - 1 );
        n1 >>= B3;
        const V4 = n1 & ( Math.pow( 2, B4 ) - 1 );
        
        // Part 2
        const V5 = n2 & ( Math.pow( 2, B5 ) - 1 );
        n2 >>= B5;
        const V6 = n2 & ( Math.pow( 2, B6 ) - 1 );
        n2 >>= B6;
        const V7 = n2 & ( Math.pow( 2, B7 ) - 1 );
        
        console.log(
            "range bonus", V1, "rate bonus", V2,
            "move bonus", V3, "level", V4,
            "lives", V5, "armor", V6, "max armor", V7 );

        // Set range
        player_range_bonus = V1 * PX_PER_CHAR_HOZ;

        // Set launch rate and missile speed
        player_missile_speed_bonus = V2* PX_PER_CHAR_HOZ;
        for( let m = 0; m < V2; m++ )
        {
            player_ticks_per_launch *= 0.9;
        }

        // Set move rate
        player_move_bonus = V3;
        for( let m = 0; m < V3; m++ )
        {
            player_ticks_per_move *= 0.8; // 20% inc. in speed
            player_ticks_per_fall *= 0.8; // 20% inc. in speed
        }

        // Set other variables
        current_level = V4;
        player_lives = V5;
        player_armor_remaining = V6;
        player_max_armor = V7;

        max_level_achieved
            = Math.max( current_level, max_level_achieved );

        return true;
    };

    recalc = function()
    {
        let code = "";

        // Part 1
        const V1 = Math.min(
                        Math.pow( 2, B1 ),
                        Math.round( player_range_bonus / PX_PER_CHAR_HOZ )
                   );

        const V2 = Math.min( 
                        Math.pow( 2, B2 ),
                        Math.round(
                            player_missile_speed_bonus
                                / PX_PER_CHAR_HOZ
                        )
                   );

        const V3 = Math.min( 
                        Math.pow( 2, B3 ),
                        player_move_bonus
                   );
                     
        const V4 = Math.min(
                        Math.pow( 2, B4 ),
                        current_level
                   );

        const PART_1 = V1
                       + ( V2 << B1 )
                       + ( V3 << ( B1 + B2 ) )
                       + ( V4 << ( B1 + B2 + B3 ) );

        // Part 2
        const V5 = Math.min(
                        Math.pow( 2, B5 ),
                        player_lives
                   ); 

        const V6 = Math.min( 
                        Math.pow( 2, B6 ),
                        player_armor_remaining
                   );
                     
        const V7 = Math.min( 
                        Math.pow( 2, B7 ),
                        player_max_armor
                   );
        
        const PART_2 = V5 + ( V6 << B5 ) + ( V7 << ( B5 + B6 ) );

        const CHKS = chks( PART_1, B8, PART_2 );

        const PART_2_CHKS = PART_2 + ( CHKS << ( B5 + B6 + B7 ) );
        
        let ANS_1 = conv_to_a26( PART_1, 3 );  // 3 digits
        const ANS_2 = conv_to_a26(
            PART_2_CHKS,
            5  // 5 digits
        );

        return ANS_1 + ANS_2;  // Total 8 digits
    };

    conv_from_a26 = function( a26 )
    {
        let n = 0;
        let mult = 1;
        for( let m = a26.length - 1; m >= 0; m-- )
        {
            const C = a26[m].charCodeAt() - 65;
            if( C < 0 || C > 25 )
            {
                console.log( "Error:", m, "of a26 =",
                             a26[m], " = invalid" );
                return -1;
            }

            n += C * mult;
            mult *= 26;
        }

        return n;
    }

    conv_to_a26 = function( n, ans_size )
    {
        char_codes = [];
        let temp = n;
        while( temp >= 26 )
        {
            char_codes.push( ( temp % 26 ) + 65 );
            temp = Math.floor( temp / 26 );
        }
        char_codes.push( ( temp % 26 ) + 65 );

        if( ans_size < char_codes.length )
        {
            console.log( "Error: a26 overflow, n=", n,
                         "char_codes=", char_codes,
                         "ans_size=", ans_size );
            return "INVALID";
        }

        const PAD = ans_size - char_codes.length;

        let a26 = "";
        for( let m = 0; m < PAD; m++ )
        {
            a26 += "A";
        }
        for( let m = char_codes.length - 1; m >= 0; m-- )
        {
            a26 += String.fromCharCode( char_codes[m] );
        }

        return a26;
    }

    chks = function( n, bits, prev_chks = 0 )
    {
        const N = Math.pow( 2, bits ) - 1;

        while( n > N )
        {
            prev_chks = ( prev_chks + n ) & N;
            n >>= bits;
        }
        prev_chks = ( prev_chks + n ) & N;

        return prev_chks;
    }

    //! Pause game (only while in play state)
    pause = function( update_stat_bar = true )
    {
        // Ignore request if game not in play state
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        console.log( "Game paused" );
        game_state = GAME_STATE_PLAY_PAUSED;

        audio_cancel_all_FX();

        if( update_stat_bar )
        {
            stat_bar_alert( "PAUSED", DEFAULT_BG_COL, INTRO_TEXT_COL );
        }

        // Remember time paused
        level_pause_ticks = Date.now();

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;
    }

    //! Unpause game (only while in pause state)
    unpause = function()
    {
        // Ignore request if game not in pause state
        if( game_state != GAME_STATE_PLAY_PAUSED ) { return; }

        console.log( "Game unpaused" );
        game_state = GAME_STATE_IN_PLAY;

        stat_bar_update();

        // Calculate time spent in pause
        if( level_pause_ticks > 0 )
        {
            level_pause_total_ticks
                += Date.now() - level_pause_ticks;
            level_pause_ticks = 0;
        }

        // Restart main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    }

    //! Mute audio (during any game state)
    mute = function()
    {
        console.log( "Mute all" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_MUTE_ALL;

        audio_cancel_all_FX();
        audio_master_gain = 0;
        audio_theme_gain.disconnect();
        stat_bar_mute();
    }

    //! Mute theme (play FX only)
    mute_theme = function()
    {
        console.log( "Mute theme, play FX" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_FX_ONLY;

        audio_cancel_all_FX();
        audio_master_gain = AUDIO_DEFAULT_GAIN;
        audio_theme_gain.disconnect();
        stat_bar_mute();
    }

    //! Unmute audio (during any game state)
    unmute = function()
    {
        console.log( "Unmute all" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_FULL_AUDIO;

        audio_master_gain = AUDIO_DEFAULT_GAIN;
        
        // Set tune's gain according to waveform type
        if( audio_theme_oscillator.type == "sine" )
        {
            audio_theme_gain.gain.value
                = audio_master_gain * AUDIO_THEME_IN_GAME_GAIN;
        }
        else
        {
            audio_theme_gain.gain.value = audio_master_gain;
        }

        audio_theme_gain.connect( audio_context.destination );
        stat_bar_mute();
    }

    //! Follow player 'scent trial' (at location offset from enemy)
    follow_scent = function( enemy, offset_i = 0, offset_j = 0 )
    {
        // Get player 'scent trail' at enemy's next position
        const NEW_DIR = get_char( enemy, offset_i, offset_j ).scent;
        
        // If scent direction valid, use this
        if( NEW_DIR !== DIR_NONE )
        {

            enemy.dir = NEW_DIR;

            // Return success
            return true;
        }

        // Otherwise, return failure
        return false;
    }

    //! Return direction needed to home in on player
    home_in = function( enemy )
    {
        // Get difference between player and enemy locations
        const DIFF_I = player_sprite.char_i - enemy.char_i;
        const DIFF_J = player_sprite.char_j - enemy.char_j;

        // Determine whether required direction is hoz and/or vert
        let hoz_flag = DIFF_I != 0;
        let vert_flag = DIFF_J != 0;
        
        // As diagonal movement not allowed,
        // if both hoz and vert identified, select one
        // depending on current ticks
        if( hoz_flag && vert_flag )
        {
            const R = Math.floor( Math.random() * 16 );
            if( R % 2 == 0 ) { hoz_flag = false; }
            else { vert_flag = false; }
        }

        if( hoz_flag )
        {
            return ( DIFF_I < 0 ? DIR_LEFT : DIR_RIGHT );
        }

        if( vert_flag )
        {
            return ( DIFF_J < 0 ? DIR_UP : DIR_DOWN );
        }

        return DIR_NONE;
    }

    ///////////////////////////////////////////
    // CANVAS FUNCTIONS
    
    //! Clear canvas
    clear_canvas = function(
        ctx,
        char_array,
        bg_col = DEFAULT_BG_COL  )
    {
        // Clear canvas
        ctx.fillStyle = bg_col; 
        ctx.fillRect(
            0,
            0,
            TOTAL_CHAR_WIDTH,
            TOTAL_CHAR_HEIGHT
        ); 

        // Return char array to default state
        for( let j = 0; j < char_array.length; j++ )
        {
            const LINE = char_array[j];

            for( let i = 0; i < LINE.length; i++ )
            {
                LINE[i].reset();
            }
        }
    }

    //! Draw char onto main game canvas
    draw_char = function( 
        i,  // Hoz pos (in whole chars)
        j,  // Vert pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL,
        update_canvas_only = true
    )
    {
        if( update_canvas_only )
        {
            // This version does *not* udpate 'chars'
            draw_char_canvas( CANV_CHARS_CTX, 0, i, j, c, fg_col, bg_col );
        }
        else
        {
            draw_char_canvas( CANV_CHARS_CTX, chars, i, j, c, fg_col, bg_col );
        }
    }

    //! Draw char onto stat bar canvas
    draw_char_sb = function( 
        i,  // Hoz pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        draw_char_canvas( CANV_SB_CTX, sb_chars, i, 0, c, fg_col, bg_col );
    }

    //! Draw char onto canvas
    draw_char_canvas = function(
        ctx,
        char_array,  // 'character' array
        i,  // Hoz pos (in whole chars)
        j,  // Vert pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        if( !char_qual_check( c ) )
        {
            console.log( "Error: char with ascii code",
                         c, " at", i, j,
                         "has problem with graphic data." );

            if( !char_qual_check( INVALID_ASCII ) ) { return; }
            
            // Use alternate ascii code
            c = INVALID_ASCII;
        }

        // Update character array
        if( char_array !== 0 )
        {
            char_array[j][i].char_id = c;
        }

        // Calculate pixel indices of char's top-left corner
        const BASE_PX_I = PX_PER_CHAR_HOZ * i;
        const BASE_PX_J = PX_PER_CHAR_VERT * j;
        
        // Get reference to char image data array
        const CHAR_DATA = ASCII_DATA[c];

        for( let m = 0; m < PX_PER_CHAR_VERT; m++ )
        {
            // Calculate vert pos in virtual pixels
            const PX_J = BASE_PX_J + m;

            // Calculate vert pos in screen pixels
            // from top-left of canvas
            const Y = PX_J * PIXEL_HEIGHT;

            // Get single line of char image
            const CHAR_DATA_LINE = CHAR_DATA[ m ];

            // Value used to extract a single bit from CHAR_LINE
            let bit = Math.pow( 2, PX_PER_CHAR_HOZ - 1 );

            for( let n = 0; n < PX_PER_CHAR_HOZ; n++ )
            {
                // Calculate hoz pos in virtual pixels
                const PX_I = BASE_PX_I + n;

                // Calculate hoz pos in screen pixels
                // from top-left of canvas
                const X = PX_I * PIXEL_WIDTH;

                // Draw pixel
                ctx.fillStyle 
                        = ( CHAR_DATA_LINE & bit ) ? fg_col : bg_col;
                ctx.fillRect( X, Y, PIXEL_WIDTH, PIXEL_HEIGHT );

                // Shift 'bit' right
                bit >>= 1;
            }
        }
    }

    //! Get angle (clockwise from vetical in radians) of point realtive to origin
    /*! @param x: hoz coord (right is +ve)
     *  @param y: vert coord (up is +ve)
     */
    calc_ang = function( x, y )
    {
        // Edge cases
        if( y == 0 )
        {
            if( x == 0 )
            {
                return undefined;
            }
            else if( x < 0 )
            {
                // 270 deg
                return 3 * Math.PI / 2;
            }
            else
            {
                // 90 deg
                return Math.PI / 2
            }
        }
        else if( x == 0 )
        {
            if( y > 0 )
            {
                // 0 deg
                return 0;
            }
            else
            {
                // 180 deg
                return Math.PI;
            }
        }

        // Angle of right-angled triangle where x is opposite
        // and y is adjacent
        const ANG = Math.atan( Math.abs( x ) / Math.abs( y ) );

        if ( y > 0 )
        {
            if( x < 0 )
            {
                // 270 - 360 deg
                return Math.PI * 2 - ANG;
            }
            else  // x >= 0
            {
                // 0 - 90 deg
                return ANG;
            }
        }
        else  // y <= 0
        {
            if( x < 0 )
            {
                // 180 - 270 deg
                return ANG + Math.PI;
            }
            else  // x >= 0
            {
                // 90 - 180 deg
                return Math.PI - ANG;
            }
        }
    }

    //! Player suffers loss of one armo(u)r point
    armor_hit = function()
    {
        if( player_armor_remaining > 0 )
        {
            audio_play_FX( 'player_hit' );

            console.log( "ARMOR HIT!" );
            player_armor_remaining -= 1;
            stat_bar_armor( true );
            
            game_tip_pop_up(
                "armor_hit",  // game tip type
                "You've been hit!",  // Pop-up title
                [ "Each hit costs one",  // Pop up text
                  "",
                  "armor point "
                    + String.fromCharCode(
                        STAT_BAR_ARMOR_ASCII
                    ),
                  "",
                  "When armor is zero",
                  "",
                  "the next hit will",
                  "",
                  "cost you a life "
                    + String.fromCharCode(
                        PLAYER_CHAR_ASCII
                    )
                ]
            );
        }
        else
        {
            console.log( "DIED FROM LACK OF ARMOUR" );
            player_loses_life();
        }
    }

    //! Player restores zero or more armo(u)r points
    armor_repair = function( points_restored, tip = true )
    {
        console.log( "ARMOR REPAIR", points_restored );
        if( player_armor_remaining < player_max_armor )
        {
            player_armor_remaining 
                = Math.min(
                    player_armor_remaining + points_restored,
                    player_max_armor );
            stat_bar_armor( true );
            
            if( tip )
            {
                game_tip_pop_up(
                    "armor_repair_" + points_restored,  // game tip type
                    "Armor repair",  // Pop-up title
                    [ "This item has",
                      "",
                      "restored up",  // Pop up text
                      "",
                      "to " + points_restored + " of your",
                      "",
                      "armor points"
                    ]
                );
            }
        }
        else
        {
            game_tip_pop_up(
                "armor_repair_redundant",  // game tip type
                "Armor repair",  // Pop-up title
                [ "Your armor is",  // Pop up text
                  "",
                  "already at full",
                  "",
                  "strength, so this",
                  "",
                  "item had no effect."
                ]
            );
        }
    }

    //! Player's armo(u)r capacity increases
    armor_enhance = function( inc )
    {
        console.log( "ARMOR ENCHANCE", inc );
        if( player_max_armor < PLAYER_ARMOR_CEILING )
        {
            player_max_armor 
                = Math.min(
                    player_max_armor + inc,
                    PLAYER_ARMOR_CEILING );
            stat_bar_armor( true );
            
            game_tip_pop_up(
                "armor_enhance_" + inc,  // game tip type
                "Armor enhance",  // Pop-up title
                [ "This item has",
                  "",
                  "increased your",  // Pop up text
                  "",
                  "your armor",
                  "",
                  "capacity by " + inc,
                ]
            );

            // Also increase current armo(u)r points
            // by same amount
            armor_repair( inc, false );
        }
    }

    //! Kill enemy
    kill_enemy = function( enemy )
    {
        if( !enemy_sprites.has( enemy ) )
        {
            console.log( "Error: kill_enemy() called for sprite",
                         enemy.id, "which is not an enemy sprite.",
                         "Ignoring kill request." );
            return;
        }

        // Create splats (best effort)
        for( let n = 0; n < 4; n++ )
        {
            splat_missile_man.launch(
                enemy.px_left,
                enemy.px_top,
                Math.PI * ( n / 2 + 0.25 ), // Diagonals
                64,  // virtual px per second
                32,  // max dist in virtual px
                SPRITE_TYPE_SPLAT,
                -1,
                46,  // ascii code
                CW ? COL_4_FG_2 : COL_16_RED,
                false // No collision with solid chars
            );
        }

        // Create splat FX
        audio_play_FX( 'splat' );
   
        

        // Add enemy's start location to list
        // of coords to ignore when adding enemy
        // sprites. This ensures enemy does not
        // reappear if screen revisited.
        if( enemy.type !== ET_DRAGON_TAIL 
            && enemy.type !== ET_DRAGON
        )
        {
            ignore_coord_list.add(
                unique_loc_code(
                    current_screen_i,
                    current_screen_j,
                    enemy.start_char_i,
                    enemy.start_char_j,
                )
            );
        }

        // Destroy sprite's canvas
        top_sprite_div.removeChild( enemy.canvas );

        // Delete sprite object by removing
        // all references to it
        enemy_sprites.delete( enemy );
        all_sprites.delete( enemy );
        if( blocking_sprites.has( enemy ) ) 
        {
            blocking_sprites.delete( enemy );
        }

        // Mark level as clear of enemies, if appropriate
        if( enemy_sprites.size === 0 )
        {
            level_meta
                [current_level]
                    [current_screen_j]
                        [current_screen_i]
                            .clear_of_enemies = true;

            console.log( current_level,
                         current_screen_j,
                         current_screen_i,
                         "clear of enemies" );

            // Revise player tips, as some may be
            // dependent on enemies being killed
            player_tips( current_level,
                         current_screen_i,
                         current_screen_j
            );
        }
    }

    //! Create pop-up
    pop_up = function(
        title,
        mesg = [],
        footer = "hit enter",
        non_printable_char_col = CW ? COL_4_FG_2 : COL_16_MAG
    )
    {
        console.log( "pop-up" );

        // Pause game, if running
        pause( true );

        // Override pause game state
        game_state = GAME_STATE_POP_UP;

        // Fill pop-up canvas with transparency
        CANV_POP_CTX.clearRect(
            0,
            0,
            CANV_POP_WIDTH,
            CANV_POP_HEIGHT
        );

        // Warn if message clipped vertically
        const NUM_LINES
            = Math.min(
                mesg.length,
                POP_UP_MAX_HEIGHT_IN_CHARS - 2
            );
        if( NUM_LINES < mesg.length )
        {
            console.log( "Warning: pop up message of", mesg.length,
                         "lines clipped to", NUM_LINES, "lines." );
        }

        // Work out height of background, in chars
        // Allow 2 lines for border and 2 lines for padding if
        // message is small enough.
        const HEIGHT_CH
            = Math.min(
                NUM_LINES + 4,
                POP_UP_MAX_HEIGHT_IN_CHARS
            );

        // Work out width of background, in chars...
        let width_ch = POP_UP_MIN_WIDTH_IN_CHARS;

        // Check width against length of title and clip
        // title accordingly
        if( title.length > POP_UP_MAX_WIDTH_IN_CHARS )
        {
            console.log( "Warning: title '", title, "' of pop up",
                         "message will be clipped to",
                         POP_UP_MAX_WIDTH_IN_CHARS );
            title = title.substring( 0, POP_UP_MAX_WIDTH_IN_CHARS );
        }
        width_ch = title.length;

        // Check length of each line of message
        for( let n = 0; n < NUM_LINES; n++ )
        {
            const LINE = mesg[n];

            // Quality check
            if( !( typeof LINE === 'string' ) )
            {
                console.log( "Error: line", n, "of pop-up",
                     "message is not a string, ignoring. Line =",
                     LINE, " of type", typeof LINE );
                continue;
            }

            const LINE_LEN = LINE.length;

            if( LINE_LEN >= POP_UP_MAX_WIDTH_IN_CHARS - 2 )
            {
                console.log( "Warning: line", n, " of pop up",
                             "message will be clipped to",
                             POP_UP_MAX_WIDTH_IN_CHARS - 2 );
                mesg[n]
                    = mesg[n].substring(
                        0, 
                        POP_UP_MAX_WIDTH_IN_CHARS - 2
                    );

                // Make pop-up window max permissible width
                width_ch = POP_UP_MAX_WIDTH_IN_CHARS;
                break;
            }

            width_ch = Math.max( width_ch, LINE_LEN + 2 ); 
        }

        // Check width against length of footer and clip
        // title accordingly
        if( footer.length > POP_UP_MAX_WIDTH_IN_CHARS - 2 )
        {
            console.log( "Warning: footer '", footer, "' of pop up",
                         "message will be clipped to",
                         POP_UP_MAX_WIDTH_IN_CHARS - 2 );
            footer = footer.substring( 0, POP_UP_MAX_WIDTH_IN_CHARS - 2 );
        }
        width_ch = Math.max( width_ch, footer.length + 2 );

        // Get top-left of background rectangle within canvas,
        // in char coords
        const LEFT_CH = Math.round(
                ( CANV_POP_WIDTH - width_ch * CHAR_WIDTH ) 
                    / 2 / CHAR_WIDTH
            );
        const TOP_CH = Math.round(
                ( CANV_POP_HEIGHT - HEIGHT_CH * CHAR_HEIGHT )
                    / 2 / CHAR_HEIGHT
            );

        // Set background rectangle of a appropriate size
        CANV_POP_CTX.fillStyle = POP_UP_BG_COL;
        CANV_POP_CTX.fillRect(
            LEFT_CH * CHAR_WIDTH,
            TOP_CH * CHAR_HEIGHT,
            width_ch * CHAR_WIDTH,
            HEIGHT_CH * CHAR_HEIGHT
        );

        // ---- INTERNAL FUNCTION ---
        // Custom write line function for pop-up
        write_ln = function(
            j,
            line,
            justify = 'center'
        )
        {
            // NESTED INTERNAL FUNCTIONS
            // Custom character draw function
            drw = function(
                i,
                c,
                fg_col = POP_UP_TEXT_COL,
                bg_col = POP_UP_BG_COL
            )
            {
                draw_char_canvas( 
                    CANV_POP_CTX,
                    0,  // No char array
                    LEFT_CH + i,
                    TOP_CH + j,
                    c,
                    fg_col,
                    bg_col
                );
            }

            // Detemrine left-hand start position for text
            const LEN = line.length;
            let text_start_i = 0;
            switch( justify )
            {
                case 'center':
                    text_start_i = Math.floor( ( width_ch - LEN ) / 2 );
                    break;

                case 'left':
                    text_start_i = j == 0 ? 
                        ( LEN <= width_ch - 2 ? 1 : 0 ) :  // Title text
                        1;  // Normal text 
                    break;

                case 'right':
                    text_start_i = width_ch - LEN - (
                        j == HEIGHT_CH - 1 ?
                            ( LEN <= width_ch - 2 ? 1 : 0 ) : // Footer text
                            1  // Normal text
                    );
                    break;
            }

            // Draw border....

            // Top and bottom borders
            if( j == 0 || j == HEIGHT_CH - 1 )
            {
                // Top left corner
                if( text_start_i > 0 )
                {
                    drw( 0, 
                         j == 0 ? BORDER_SE_ASCII : BORDER_NE_ASCII,
                         POP_UP_BORDER_COL
                    );
                }

                // Top right corner
                if( text_start_i + LEN < width_ch )
                {
                    drw( width_ch - 1,
                         j == 0 ? BORDER_SW_ASCII : BORDER_NW_ASCII,
                         POP_UP_BORDER_COL );
                }

                // Top border
                for( let i = 1; i < text_start_i; i++ )
                {
                    drw( i, BORDER_HOZ_ASCII, POP_UP_BORDER_COL ); 
                }
                for( let i = text_start_i + LEN; i < width_ch - 1; i++ )
                {
                    drw( i, BORDER_HOZ_ASCII, POP_UP_BORDER_COL ); 
                }
            }
            // Side borders
            else
            {
                drw( 0, BORDER_VERT_ASCII, POP_UP_BORDER_COL );
                drw( width_ch - 1, BORDER_VERT_ASCII, POP_UP_BORDER_COL );
            }

            // Determine text colo(u)r
            let fg_col = POP_UP_TEXT_COL;
            let bg_col = POP_UP_BG_COL;
            if( j == 0 )
            {
                fg_col = POP_UP_TITLE_COL;
                bg_col = POP_UP_BORDER_COL;
            }
            else if( j == HEIGHT_CH - 1 )
            {
                fg_col = POP_UP_FOOTER_COL;
                bg_col = POP_UP_BORDER_COL;
            }

            // Draw text
            for( let n = 0; n < line.length; n++ )
            {
                const C = line.charCodeAt(n);
                if( non_printable( C ) )
                {
                    // Use alternative colo(u)r for enemies and missiles
                    drw( 
                        text_start_i + n,
                        C,
                        non_printable_char_col,
                        bg_col
                    );
                }
                else
                {
                    drw( text_start_i + n, C, fg_col, bg_col );
                }
            }
        }
        // END OF INTERNAL FUNCTION

        // Write title
        write_ln( 0, title, 'left' );
        let cursor_j = 1;

        // Add padding line, if space permits
        if( mesg.length <= POP_UP_MAX_HEIGHT_IN_CHARS - 3 )
        {
            write_ln( cursor_j++, "" );
        }

        // Write message
        for( let n = 0; n < NUM_LINES; n++, cursor_j++ )
        {
            write_ln( cursor_j, mesg[n], 'left' );
        }

        // Add padding line, if space permits
        if( mesg.length <= POP_UP_MAX_HEIGHT_IN_CHARS - 4 )
        { 
            write_ln( cursor_j++, "" );
        }

        // Write footer
        write_ln( cursor_j, footer, 'right' );

        pop_up_div.style.visibility = 'visible';
    
        // Return top left position of content (excluding
        // border), in character squares, this is useful
        // if pop-up content needs to be edited.
        return [LEFT_CH + 1, TOP_CH + 1 ];
    }

    //! Create time-delayed game tip pop-up (if game tips on)
    /*! If tip already given, or 'game_tips' is false, this does nothing. 
     * If tip_type = "", tip is always given provided 'game_tips' is true.
     */
    game_tip_pop_up = function( tip_type, title, mesg )
    {
        // Ignore if tips already given
        if( tip_type == "" || !game_tips_given.has( tip_type ) )
        {
            // Prevent tip being given later in game,
            // even if tip not displayed now as
            // game tops are turned off.
            if( tip_type !== "" )
            {
                game_tips_given.add( tip_type );
            }

            // If games tips are on, display tip
            if( game_tips )
            {
                setTimeout(
                    function() { pop_up( title, mesg ); },
                    POP_UP_DELAY
                );
            }
        }
    }

    lose_life_pop_up = function( title, mesg )
    {
        // Closing this pop-up redraws the level
        setTimeout(
            function() {
                pop_up( title, mesg );
                game_state = GAME_STATE_AWAITING_RESTART;
            },
            POP_UP_DELAY
        );
    }

    //! Create pop-up to introduce new enemies/collectables
    /* Returns true if pop-up create for new enemies/collectables,
     * false otherwise
     */
    new_thing_pop_up = function()
    {
        // Loop over new enemies (if any)
        for( const enemy_type of new_enemy_types )
        {
            let ED = 0;

            // Search for enemy data
            for( const SYMBOL in ENEMY_DATA )
            {
                const THIS_ED = ENEMY_DATA[SYMBOL];

                if( THIS_ED[ED_COL_TYPE] == enemy_type )
                {
                    // Found it
                    ED = THIS_ED;
                    break;
                }
            }

            // If found, create pop-up
            if ( ED !== 0 )
            {
                // Create pop-up text
                let mesg = [];

                // Get emeny ASCII code
                const ASCII = ED[ED_COL_ASCII];

                // Add enemy image and name
                mesg.push(
                    String.fromCharCode( ASCII )
                    + " "
                    + ED[ED_COL_NAME]
                );

                mesg.push( "" );
        
                // Add hits to kill
                mesg.push( "Hits to kill: " + ED[ED_COL_HTK] );

                mesg.push( "" );

                // Add weapon info
                const MT = ED[ED_COL_MT];
                if( MT !== MT_NONE && MT in MISSILE_DATA )
                {
                    const MT_DATA = MISSILE_DATA[MT];
                    mesg.push(
                        "Weapon: "
                        + String.fromCharCode( MT_DATA[MD_COL_ASCII] )
                        + " "
                        + MT_DATA[MD_COL_NAME]
                    );
                }
                else
                {
                    mesg.push( "Causes 1 damage on" );
                    mesg.push( "" );
                    mesg.push( "contact, then dies" );
                }

                // Special additional text for boss
                if( enemy_type == ET_DRAGON )
                {
                    mesg.push( "" );
                    mesg.push( "Invulnerable until" );
                    mesg.push( "" );
                    mesg.push( "tail is destroyed." );
                    mesg.push( "" );
                    mesg.push( "Aim at last segment." );
                }

                // Remove enemy from list
                // This MUST be done before following
                // time out call, otherwise we enter
                // an endless cycle of pop-ups
                new_enemy_types.delete( enemy_type );

                // Note: if more than one new enemy type present
                //       in level, the next one will be triggered
                //       once this pop-up is closed.
                setTimeout(
                    function()
                    {
                        pop_up(
                            "New foe!",
                            mesg
                        );
                    },
                    POP_UP_DELAY
                );

                // End here at first successful pop-up
                return true;
            }
            else
            {
                console.log( "Error: unable to find data for enemy",
                             "of type", enemy_type, "skipping",
                             "pop-up for this new enemy." );
            }
        }

        /*
        console.log( "Check for new collectables",
                     new_collectable_types );

        // If no enemy pop-up created,
        // loop over new collectables (if any)
        for( const collectable_type of new_collectable_types )
        {
            let CD = 0;

            // Search for collectable data
            for( const SYMBOL in COLLECTABLE_DATA )
            {
                const THIS_CD = COLLECTABLE_DATA[SYMBOL];

                if( THIS_CD[CD_COL_TYPE] == collectable_type )
                {
                    // Found it
                    CD = THIS_CD;
                    break;
                }
            }

            // If found, create pop-up
            if ( CD !== 0 )
            {
                // Create pop-up text
                let mesg = [];

                // Get emeny ASCII code
                const ASCII = CD[CD_COL_ASCII];

                // Add collectable image, name and description
                mesg.push(
                    String.fromCharCode( ASCII )
                    + " "
                    + CD[CD_COL_NAME]
                );

                for( const LINE of CD[CD_COL_DESC] )
                {
                    mesg.push( "" );
                    mesg.push( LINE );
                }

                // Remove collectable from list
                // This MUST be done before following
                // time out call, otherwise we enter
                // an endless cycle of pop-ups
                new_collectable_types.delete( collectable_type );

                // Note: if more than one new collectable type present
                //       in level, the next one will be triggered
                //       once this pop-up is closed.
                setTimeout(
                    function()
                    {
                        pop_up(
                            "New item!",
                            mesg,
                            "hit enter",
                            CW ? COL_4_FG_0 : COL_16_WHT
                        );
                    },
                    POP_UP_DELAY
                );

                // End here at first successful pop-up
                return true;
            }
            else
            {
                console.log( "Error: unable to find data for collectable",
                             "of type", collectable_type, "skipping",
                             "pop-up for this new collectable." );
            }
        }
        */

        return false;
    }

    map_pop_up = function()
    {
        // Create pop-up content full of spaces to maximize
        // size of pop-up window
        mesg = [];
        for( let n = 0; n <= POP_UP_MAX_HEIGHT_IN_CHARS - 2; n++ )
        {
            mesg.push( " ".repeat( POP_UP_MAX_WIDTH_IN_CHARS - 2 ) );
        }
        const RET_VALUE = pop_up( "Level map", mesg );
        
        // Top left position of pop-up content
        // (+ 1 here to add one char of padding)
        // in pop-up actual canvas pixels
        const LEFT = ( RET_VALUE[0] + 1 ) * CHAR_WIDTH;
        const TOP = ( RET_VALUE[1] + 1 ) * CHAR_HEIGHT;

        // Loop over level map's virtual pixels
        // (each representing one character square
        //  within the level)
        for( let map_px_j = 0;
             map_px_j < level_map_pixels.length;
             map_px_j++
        )
        {
            // Calculate top of map's virtual pixel in actual
            // pop-up console pixels
            const J = TOP + map_px_j * PIXEL_HEIGHT;

            // Get reference to row of level map
            const ROW = level_map_pixels[map_px_j];

            for( let map_px_i = 0;
                 map_px_i < ROW.length;
                 map_px_i++
            )
            {
                const COL = ROW[map_px_i];

                // Only draw none background colo(u)rs
                if( COL !== LEVEL_MAP_BG_COL )
                {
                    // Calculate left of map's virtual pixel in actual
                    // pop-up console pixels
                    const I = LEFT + map_px_i * PIXEL_WIDTH;

                    CANV_POP_CTX.fillStyle = COL;
                    CANV_POP_CTX.fillRect(
                        I,
                        J,
                        PIXEL_WIDTH,
                        PIXEL_HEIGHT
                    );
                }
            }
        }
    }

    get_color = function( item_name, /* ega_default = COL_4_FG_2 */ )
    {
        /*
        if( CW )
        {
            return ega_default;  // Default for 'EGA' colo(u)r way
        }
        */
        
        // Get colo(u)r for 'CGA' colo(u)r way
        if( item_name in custom_colors
            && custom_colors[item_name].length > 0
        )
        {
            return custom_colors[item_name][0];
        }
        else if( item_name in DEFAULT_PALETTE
                && DEFAULT_PALETTE[item_name].length > 0
        )
        {
            return DEFAULT_PALETTE[item_name][0];
        }
    }

    //! Returns true if ASCII code is non-printable
    non_printable = function( c )
    {
        return c < 31 || c > 126;
    }

    // Creates a unique within-level location code
    // based on screen and character coords,
    // allowing 4 bits per screen coord, and 6 bits per
    // character coord.
    unique_loc_code = function( screen_i, screen_j, ch_i, ch_j )
    {
        return ( screen_j << 14 ) + ( screen_i << 10 )
                + ( ch_j << 6 ) + ch_i;
    }

    reset_vars_for_new_game = function()
    {
        player_score = 0;
        player_lives = PLAYER_START_LIVES;
        player_max_armor = PLAYER_START_ARMOR;
        player_ticks_per_move = DEFAULT_PLAYER_TICKS_PER_MOVE;
        player_ticks_per_fall = DEFAULT_TICKS_PER_FALL;
        player_range_bonus = 0;
        player_missile_speed_bonus = 0;
        player_move_bonus = 0;
        player_ticks_per_launch = DEFAULT_PLAYER_TICKS_PER_LAUNCH;
        player_armor_remaining = player_max_armor;
   
        known_enemy_types.clear();

        reset_vars_for_new_level();
    }

    reset_vars_for_new_level = function()
    {
        ignore_coord_list.clear();
        level_map_pixels = [];

        // Assume top-left screen is always starting screen
        current_screen_i = 0;
        current_screen_j = 0;

        // Clear level meta data but retain array structure
        for( let m = 0; m < level_meta.size; m++ )
        {
            const META = level_meta[m];
            
            for( let n = 0; n < META.size; n++ )
            {
                const ROW = META[n];
                
                for( let k = 0; k < ROW.size; k++ )
                {
                    ROW[k].reset();
                }
            }
        }
    }

    check_for_special_tip = function()
    {
        const CH = chars[player_sprite.char_j][player_sprite.char_i];

        if( "tip" in CH )
        {
            const TIP = CH.tip;
            const TIP_ID = TIP[0];
            if( TIP_ID === "" )
            {
                pop_up( TIP[1], TIP[2] );
            }
            else if( !game_tips_given.has( TIP_ID ) )
            {
                pop_up( TIP[1], TIP[2] );
                game_tips_given.add( TIP_ID );
            }
        }
    }

    check_for_end_of_level = function()
    {
        console.log( "check for end of level",
                     current_screen_i,
                     current_screen_j,
                     player_sprite.char_i,
                     player_sprite.char_j );

        // Get shortcut to level end point
        EP = LEVEL_END[current_level];

        // Check for level completion by location
        if( current_screen_i === EP[0]
            && current_screen_j == EP[1]
            && player_sprite.char_i == EP[2]
            && player_sprite.char_j == EP[3]
        )
        {
            level_completed();

            return true;
        }
        else
        {
            return false;
        }
    }

    level_completed = function( stat_bar_mesg = "LEVEL COMPLETE!" )
    {
        console.log( "Level", current_level, "complete!" );
        
        // Hide any open pop-up
        pop_up_div.style.visibility = "hidden";

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;

        // Stop keyboard event handling
        document.removeEventListener( 'keydown', handleKeyEvent );
        key_handler_on = false;

        // Cancel any playing sound FX and theme
        audio_cancel_all_FX();
        audio_stop_theme();
        
        // Play wining fanfare
        if( audio_mute !== MUTE_STATUS_MUTE_ALL )
        {
            console.log( "Play end-of-level fanfare" );
            audio_play_tune(
                audio_theme_oscillator,
                audio_theme_gain,
                AUDIO_FX_FANFARE_DATA,
                0,
                false,
                0,
                true  // play even if FX-only selected
            );
        }

        // Change border colo(u)r
        document.body.style.background = FLASH_BORDER_COL;
       
        stat_bar_alert( stat_bar_mesg, DEFAULT_BG_COL, INTRO_TEXT_COL );

        // After delay, move to end screen
        setTimeout(
            level_completion_screen,
            2000
        );
    }

    // END OF FUNCTION DEFS
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // CLASS DEFS

    //! Base sprite class
    class Sprite
    {
        constructor
        (
            id,
            start_px_i,
            start_px_j,
            image = [],
            col = DEFAULT_FG_COL,
            type = SPRITE_TYPE_PLAYER
        )
        {
            this.id = id;

            // Declare (initially empty) store for sprite image data
            this.image = [];

            // Find sprite height in virtual pixels
            const SPRITE_HEIGHT = image.length;

            // Find largest data line...
            let max_image_data_value = 0;
            for( let j = 0; j < SPRITE_HEIGHT; j++ )
            {
                max_image_data_value = Math.max(
                    max_image_data_value,
                    image[j]
                );
            }

            // ...and thereby sprite width in virtual pixels
            // Note: the '+ 0.00001' is there prevent round binary
            //       numbers (e.g. b10000000) being interpreted as
            //       one pixel smaller than they should be.
            const SPRITE_WIDTH
                = Math.ceil(
                    Math.log2( max_image_data_value + 0.00001 )
                );

            // Create mini canvas just for this sprite
            this.canvas = document.createElement( 'canvas' );
            this.canvas.id = "sprite_canvas " + id;
            this.canvas.width = SPRITE_WIDTH * PIXEL_WIDTH;
            this.canvas.height = SPRITE_HEIGHT * PIXEL_HEIGHT;
            this.ctx = this.canvas.getContext( '2d' );

            // Set canvas positioning method to 'absolute',
            // i.e. relative to 'top_sprite_div'
            // Note: actual canvas position is set by this.move, below
            this.canvas.style.position = "absolute";

            // Add canvas to 'div' that contains all sprites
            top_sprite_div.appendChild( this.canvas );

            // Record sprite type
            this.type = type;

            // Current hoz pixel position of sprite's left boundary
            this.px_left = start_px_i;

            // Current vert pixel position of sprite's top boundary
            this.px_top = start_px_j;

            // Remember sprite width and height
            this.px_width = SPRITE_WIDTH;
            this.px_height = SPRITE_HEIGHT;

            // Current rightmost pixel of sprite
            this.px_right = start_px_i + SPRITE_WIDTH;

            // Current bottom pixel of sprite
            this.px_bottom = start_px_j + SPRITE_HEIGHT;

            // Remember current colo(u)r
            this.col = col;

            // Draw sprite using data stored in 'image'
            // Note: this also copies 'image' to 'this.image'.
            // IMPORTANT: 'redraw' must only be called once
            //            'this.px_width' and 'this.px_height'
            //            and 'this.col' are set.
            this.redraw( false, image );

            // Set position of sprite
            // This calls the 'Sprite' version of move,
            // *not* any overridden version
            if( !Sprite.prototype.move.call(
                this,
                this.px_left,
                this.px_top
            ) )
            {
                console.log( "move failed, this.px_left", this.px_left,
                            "this.px_top", this.px_top,
                            "type", this.type );

                // If desired position out-of-bounds, set to origin.
                Sprite.prototype.move.call( this, 0, 0 );
            }

        }  // End of Sprite constructor

        //! (Re)draw sprite's canvas from stored image, with optional flip and re-colo(u)r
        /*! Canvas will *not* be resized, regardless of size of 'new_image'
         * @param flip_x: true = flip, false = don't flip, -1 = keep current flip status
         * @param new_image: Data array for new image (if [] use exiting data)
         * @param new_col: New colo(u)r (if -1 use existing colo(u)r)
         */
        redraw( flip_x = -1, new_image = [], col = -1 )
        {
            if( flip_x == -1 )
            {
                flip_x = this.flip_x;
            }
            else
            {
                this.flip_x = flip_x;
            }

            if( col == -1 )
            {
                col = this.col;
            }
            else
            {
                this.col = col;
            }

            // Copy new image, if supplied
            if( new_image.length > 0 )
            {
                // Do not exceed new image size
                // or existing sprite height (in virtual pixels)
                const MAX_N = Math.min(
                                new_image.length,
                                this.px_height
                              );

                // Make copy of supplied image
                this.image = [];
                for( let n = 0; n < MAX_N; n++ )
                {
                    this.image.push( new_image[n] );
                }
            }
            else if( this.image.length == 0 )
            {
                console.log( "Warning: Sprite.redraw abandoned",
                             "for sprite with id", this.id,
                             "as existing image data is empty",
                             "and no new image data supplied." );
                return false;
            }

            // Clear canvas
            this.ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height );

            // Set fill colo(u)r for visible pixels
            this.ctx.fillStyle = this.col;

            // Create sprite pixels (visible pixels only)
            for( let j = 0; j < this.px_height; j++ )
            {
                const IMAGE_LINE = this.image[j];

                // Value used to extract a single bit from IMAGE_LINE
                let bit = flip_x ?
                            1 :
                            Math.pow( 2, this.px_width - 1 );
                
                for( let i = 0; i < this.px_width; i++ )
                {
                    if( IMAGE_LINE & bit )
                    {
                        this.ctx.fillRect(
                            i * PIXEL_WIDTH,
                            j * PIXEL_HEIGHT,
                            PIXEL_WIDTH,
                            PIXEL_HEIGHT
                        );
                    }

                    // Shift 'bit'
                    if( flip_x )
                    {
                        bit <<= 1;
                    }
                    else
                    {
                        bit >>= 1;
                    }
                }
            }

            return true;
        }

        //! Move relative to current position (in pixels)
        move_relative( px_i, px_j )
        {
            // Call 'Sprite' version of 'move', *not* a derived version
            return Sprite.prototype.move.call( this, px_i, px_j, true );
        }

        //! Move to new position, given in pixels
        /*! @param relative: If true move is relative to current pos*/
        move( px_i, px_j, relative = false )
        {
            // If 'relative' option selected, set new position
            // offset from current position
            let new_i = Math.round( px_i );
            let new_j = Math.round( px_j );
            if( relative )
            {
                new_i += this.px_left;
                new_j += this.px_top;
            }

            // Return false if new position out-of-bounds
            if( new_i < 0
                || new_i >= PIXELS_WIDE
                || new_j < 0
                || new_j >= PIXELS_HIGH )
            {
                console.log( "New sprite pos (", new_i, new_j,
                             ") out of bounds." );
                return false;
            }

            // If ok, set new position
            this.px_left = new_i;
            this.px_top = new_j;

            // Update canvas position
            this.canvas.style.left
                = PAD_LEFT + this.px_left * PIXEL_WIDTH + "px";
            this.canvas.style.top
                = PAD_TOP + this.px_top * PIXEL_HEIGHT + "px";

            // Update bounds
            this.px_right = this.px_left + this.px_width;
            this.px_bottom = this.px_top + this.px_height;

            return true;
        }
    }

    //! Sprite that has speed and direction
    class MovingSprite extends Sprite
    {
        constructor
        (
            id,
            start_px_i,
            start_px_j,
            image = [],
            col = DEFAULT_FG_COL,
            type = SPRITE_TYPE_PLAYER,
            start_dir = DIR_NONE,
            ticks_per_move = 1000
        )
        {
            // Call 'Sprite' constructor
            super(
                id,
                start_px_i,
                start_px_j,
                image,
                col,
                type
            );

            this.dir = start_dir;
            this.ticks_per_move = ticks_per_move;
            this.prev_move_ticks = -1;
        }
    }

    //! Moving sprite that is restricted to whole character squares
    class CharSprite extends MovingSprite
    {
        constructor
        (
            id,
            start_ch_i,
            start_ch_j,
            image = [],
            col = DEFAULT_FG_COL,
            type = SPRITE_TYPE_PLAYER,
            start_dir = DIR_NONE,
            ticks_per_move = 1000,
            // remember_start_pos = false,
            blocking = true
        )
        {
            // Call 'MovingSprite' constructor
            super(
                id,
                start_ch_i * PX_PER_CHAR_HOZ,
                start_ch_j * PX_PER_CHAR_VERT,
                image,
                col,
                type,
                start_dir,
                ticks_per_move
            );

            this.char_i = start_ch_i;
            this.char_j = start_ch_j;
            this.blocking = blocking;

            // if( remember_start_pos )
            // {
            this.start_char_i = start_ch_i;
            this.start_char_j = start_ch_j;
            // }
        }
        
        move( ch_i, ch_j, relative = false )
        {
            const SUCCESS = super.move(
                ch_i * PX_PER_CHAR_HOZ,
                ch_j * PX_PER_CHAR_VERT,
                relative );
            
            if( SUCCESS )
            {
                if( relative )
                {
                    this.char_i += ch_i;
                    this.char_j += ch_j;
                }
                else
                {
                    this.char_i = ch_i;
                    this.char_j = ch_j;
                }

                return true;
            }

            return false;
        }

        move_relative( ch_i, ch_j )
        {
            return this.move( ch_i, ch_j, true );
        }
    }

    //! Special class for 'enemy' sprites
    class EnemySprite extends CharSprite
    {
        constructor
        (
            id,
            start_ch_i,
            start_ch_j,
            image,
            col,
            type,
            hits_to_kill = 1,
            start_dir = DIR_NONE,
            ticks_per_move = 1000,
            // remember_start_pos = false,
            blocking = true,
            overlay_col = DEFAULT_ENEMY_OVERLAY_COL
        )
        {
            // Call 'CharSprite' constructor
            super(
                id,
                start_ch_i,
                start_ch_j,
                image,
                col,
                type,
                start_dir,
                ticks_per_move,
                // remember_start_pos,
                blocking
            );

            this.hits_to_kill = hits_to_kill;
            this.hits = 0;
            this.overlay_col = overlay_col;

            this.redraw( this.dir == DIR_LEFT );
        }

        redraw( flip_x = -1, new_image = [], col = -1 )
        {
            // Redraw sprite, then add pixels marking hits
            if( super.redraw( flip_x, new_image, col ) )
            {
                if( this.hits > 0 ) { this.draw_hits(); }
            }
        }

        // Draw a one pixel for each hit, starting to top-left
        draw_hits()
        {
            // Draw one virtual pixel for each hit,
            // starting at top-left and moving right,
            // one pixel at a time, moving to next
            // line if needed (unlikely). If all lines
            // are used, stop there.

            const NUM_LINES = Math.ceil(
                Math.min(
                    this.hits / this.px_width,
                    this.px_height
                )
            );
        
            this.ctx.fillStyle = this.overlay_col; 

            // Fill full lines
            if( NUM_LINES > 1 )
            {
                this.ctx.fillRect(
                    0,
                    0,
                    this.px_width * PIXEL_WIDTH,
                    ( NUM_LINES - 1 ) * PIXEL_HEIGHT
                );
            }

            // FIll final line
            this.ctx.fillRect(
                0,
                ( NUM_LINES - 1 ) * PIXEL_HEIGHT,
                ( this.hits % this.px_width ) * PIXEL_WIDTH,
                PIXEL_HEIGHT
            );
        }

        //! Apply one hit (returns true if enemy dies, false otherwise)
        /*! Note: it is up to the calling method to 'kill' the
         *        enemy if 'true' is returned, as an object
         *        cannot delete itself.
         */
        strike()
        {
            this.hits += 1;

            // Check if enemy dead
            if( this.hits >= this.hits_to_kill )
            {
                // If yes, communicate this by returning 'true'
                return true;
            }

            // If only wounded, play this FX
            audio_play_FX( 'enemy_hit' );

            this.draw_hits();
            return false;
        }
    }

    //! Special class for multi-sprite caterpillar like enemies
    class CaterpillarSprite extends EnemySprite
    {
        constructor
        (
            id,
            start_ch_i,
            start_ch_j,
            length_in_chars,
            head_image,
            tail_image,
            col,
            head_type,
            tail_type,
            hits_to_kill = 1,
            start_dir = DIR_NONE,
            ticks_per_move = 1000,
            blocking = true,
            overlay_col = DEFAULT_ENEMY_OVERLAY_COL
        )
        {
            // Call 'EnemySprite' constructor for head
            super(
                id,
                start_ch_i,
                start_ch_j,
                head_image,
                col,
                head_type,
                hits_to_kill,
                start_dir,
                ticks_per_move,
                blocking,
                overlay_col
            );

            this.tail = [];
            this.num_tail_seg_killed = 0;
            this.num_pending_tail_segs = length_in_chars;
            this.distal = 0;
            this.tail_type = tail_type;
            this.tail_image = tail_image;

            // This flag holds the tail static for one
            // movement turn, to allow head to move first
            this.tail_mobilized = false;

            this.chars_moved_in_straight_line = 0;
        }
            
        mobilize_tail( mobilize = true )
        {
            if( mobilize && this.num_pending_tail_segs > 0 )
            {
                return;
            }

            for( let n = 0; n < this.tail.length; n++ )
            {
                this.tail[n].mobile = mobilize;
            }

            this.tail_mobilized = mobilize;
        }
        
        immobilize_tail() { this.mobilize_tail( false ); }
        
        move( ch_i, ch_j, relative = false )
        {
            // Current location of head
            const PREV_CH_I = this.char_i;
            const PREV_CH_J = this.char_j;

            // Leave scent on current location
            // console.log( "Leaving scent", PREV_CH_I,
            //             PREV_CH_J, this.dir );
            get_char( this ).scent = this.dir;

            // Set tail moving turn *after* head starts to move
            if( !this.tail_mobilized
                && this.num_pending_tail_segs === 0
            )
            { this.mobilize_tail(); }

            // Generate new tail segment, if required
            if( super.move( ch_i, ch_j, relative )
                    && this.num_pending_tail_segs > 0
            )
            {
                const NEW_SEG = new EnemySprite(
                    this.id + "_seg" + this.tail.length,
                    PREV_CH_I,
                    PREV_CH_J,
                    this.tail_image,
                    this.col,
                    this.tail_type,
                    1,
                    DIR_NONE,
                    this.ticks_per_move,  // Same speed as head
                    true,  // false,   BLOCKING
                    this.overlay_col
                );

                // Store reference to previous segment
                // as 'proximal' to new segment
                NEW_SEG.proximal = this;
                NEW_SEG.distal = 0;

                // Make previous most-proximal tail segment
                // (if any) distal to the new segment
                if( this.tail.length > 0 )
                {
                    const PREV_SEG = this.tail[this.tail.length - 1];
                    NEW_SEG.distal = PREV_SEG;
                    PREV_SEG.proximal = NEW_SEG;
                }
                else
                {
                    // For first segment,
                    // store reference to new segment as 'distal'
                    // to this sprite
                    this.distal = NEW_SEG;
                }
                        
                NEW_SEG.mobile = false;

                // Add new segment to tail
                this.tail.push( NEW_SEG );

                // Add sprite to relevant sets
                enemy_sprites.add( NEW_SEG );
                all_sprites.add( NEW_SEG );

                // Reduce counter for pending new tail segments
                this.num_pending_tail_segs -= 1;
            }
        }

        //! Apply one hit (returns true if enemy dies, false otherwise)
        /*! Note: it is up to the calling method to 'kill' the
         *        enemy if 'true' is returned, as an object
         *        cannot delete itself.
         */
        strike()
        {
            // This tail segment can only be killed if no distal
            // if no distal tail segment exists.
            if( this.distal !== 0 )
            {
                game_tip_pop_up(
                    "head__can_be_hit_only_when_tail_gone",
                    "Top tip",  // Pop-up title
                    [ "The head is only",
                      "", "vunerable once",
                      "", "the tail is",
                      "", "destroyed!"
                    ]
                );

                return;
            }

            // If vulnerable, apply strike
            return super.strike();
        }

        remove_distal_tail_seg()
        {
            if( this.distal === 0
                || this.num_tail_seg_killed >= this.tail.length
            )
            {
                console.log( "Cannot remove distal tail seg",
                             "as none remain" );

                this.distal = 0;

                return;
            }

            this.tail[this.num_tail_seg_killed++] = 0;
74
            if( this.num_tail_seg_killed === this.tail.length )
            {
                this.distal = 0;
            }
        }
    }

    //! Moving sprite that can be 'parked' when not in use
    /*! Parked (i.e. invisible) by default */
    class MissileSprite extends MovingSprite
    {
        constructor
        (
            id,
            ascii_code,
            col = DEFAULT_FG_COL,
            type = SPRITE_TYPE_PLAYER
        )
        {
            if( !isFinite( ascii_code )
                || ascii_code < 0
                || ascii_code > ASCII_DATA.length )
            {
                console.log( "Error in MissileSprite constructor:",
                             "ascii_code", ascii_code,
                             "out-of-range, must be 0 to",
                             ASCII_DATA.length );
                return;
            }

            super(
                id,
                0, // will be overridden on 1st launch
                0, // will be overridden on 1st launch
                ASCII_DATA[ ascii_code ],
                col,
                type,
                DIR_UP,  // Default to up (see angle_in_rads below)
                1  // Ticks per move = 1, effectively once per frame
            );

            this.ascii_code = ascii_code;
            this.flip_x = false;

            // Declare direction in radians (default to up)
            this.angle_in_rads = DIR_RAD_UP;

            this.owning_sprite_type = -1;

            // This is set to true when missile launched
            this.in_flight = false;

            // Make parked be default
            this.park();

            // Number of (virtual) pixels travelled per tick
            this.px_per_tick = 32;  // Default, will be overwritten

            // Flag to indicate whether missile is blocked
            // by 'all solid' chars
            this.all_solid_blocks = true;

            // Maximum distance (in virtual pixels) travelled
            // before expiry
            this.max_dist = Math.max( PIXELS_WIDE, PIXELS_HIGH );

            // Time point used as reference to calculate distance moved
            this.ref_ticks = -1;

            // Virtual pixel coords used as reference
            // to calculate distance moved
            this.ref_px_left = -1;
            this.ref_px_top = -1;
        }

        launch(
            start_px_i,
            start_px_j,
            angle_in_rads,
            px_per_sec,
            max_dist,
            owning_sprite_type,
            flip_x = -1,
            ascii_code = -1,
            col = -1,
            all_solid_blocks = true
        )
        {
            // Redaw if necessary
            if( ( flip_x !== -1
                    && flip_x !== this.flip_x )
                || ( ascii_code !== -1
                    && ascii_code !== this.ascii_code )
                || ( col !== -1
                    && col !== this.col )
            )
            { 
                this.ascii_code = ascii_code;
                this.redraw( flip_x, ASCII_DATA[ascii_code], col ); 
            }

            parking_div.removeChild( this.canvas );
            top_sprite_div.appendChild( this.canvas );
            this.move( start_px_i, start_px_j );
            this.in_flight = true;
            this.max_dist = max_dist;
            this.owning_sprite_type = owning_sprite_type;
            this.ref_ticks = Date.now();
            this.ref_px_left = start_px_i;
            this.ref_px_top = start_px_j;
            this.angle_in_rads = angle_in_rads;
            this.px_per_tick = px_per_sec / 1000;
            this.all_solid_blocks = all_solid_blocks;
        }

        park()
        {
            // console.log( "park", this.id );
            top_sprite_div.removeChild( this.canvas );
            parking_div.appendChild( this.canvas );
            this.in_flight = false;
            this.owning_sprite_type = -1;
            this.ref_ticks = -1;
            this.ref_px_left = -1;
            this.ref_px_top = -1;
        }

        //! Generate new position, and (optionally) check for collisions
        /*! @param collidables: Array of sprite references to check for collisions
         *  @param current_ticks: If default (-1) specified, current time is used
         *  @returns: An array containing two sub-arrays, see below
         *  Returns [ A, B, C ]
         *      A = Array of zero or more direction constants,
                        indicating which boundaries (if any)
                        missile has collided with.
                B = True if missile has collided with an all-solid
                        character square, false otherwise
                B = Array of zero or more sprites from the
                        'collidables' set provided that the
                        missile is in collision with.
         */
        process( collidables = -1, current_ticks = -1 )
        {
            // console.log( "process", this.id );

            // If not in flight, ignore
            if( !this.in_flight ) { return; }

            if( current_ticks == -1 )
            {
                current_ticks = Date.now();
            }

            // Calculate ticks since launch
            const TICKS = current_ticks - this.ref_ticks;

            // Calculate pixels travelled since lauch
            const PX_TOTAL = this.px_per_tick * TICKS;

            // Check if pixels travelled has been exceeded
            let boundaries = [];
            if( PX_TOTAL >= this.max_dist )
            {
                boundaries = [ DIR_NONE ];
            }

            // Calculate new pixel position
            const NEW_PX_I
                = this.ref_px_left 
                    + PX_TOTAL * Math.sin( this.angle_in_rads );
            const NEW_PX_J
                = this.ref_px_top 
                    - PX_TOTAL * Math.cos( this.angle_in_rads );

            // Check for boundary collision and return 'true'
            if( NEW_PX_I < 0 ) { boundaries.push( DIR_UP ); }
            if( NEW_PX_I + this.px_width >= PIXELS_WIDE )
            {
                boundaries.push( DIR_RIGHT );
            }
            if( NEW_PX_J < 0 ) { boundaries.push( DIR_DOWN ) ; }
            if( NEW_PX_J + this.px_height >= PIXELS_HIGH )
            {
                boundaries.push( DIR_DOWN );
            }
            
            // Check for all-solid character collision
            // (but only if fully within boundaries, to
            //  avoid MIN/MAX coords below being out-of-bounds )
            let hit_solid = false;
            if( this.all_solid_blocks && boundaries.length == 0 )
            {
                // Note small amount added/subtracted here
                // are to prevent rounding errors
                const MIN_I = Math.floor( this.px_left / PX_PER_CHAR_HOZ + 0.0001 );
                const MAX_I = Math.ceil( this.px_right / PX_PER_CHAR_HOZ - 0.0001 );
                const MIN_J = Math.floor( this.px_top / PX_PER_CHAR_VERT + 0.0001 );
                const MAX_J = Math.ceil( this.px_bottom / PX_PER_CHAR_VERT - 0.0001 );
                for( let i = MIN_I; i < MAX_I; i++ )
                {
                    for( let j = MIN_J; j < MAX_J; j++ )
                    {
                        if( chars[j][i].solidity & SOLID_ALL == SOLID_ALL )
                        {
                            hit_solid = true;
                            break;
                        }
                    }

                    if( hit_solid ) { break; }
                }
            }

            // Move (only if no boundary or solid collision )
            let move_ok = true;
            if( boundaries.length == 0 && !hit_solid )
            {
                move_ok = this.move( NEW_PX_I, NEW_PX_J );
            }

            // Check for sprite collision,
            // defining a collision as overlap of the
            // two sprite's rectangles
            let collisions = [];
            if( collidables !== -1 )
            {
                for( const other of collidables )
                {
                    if( this.px_left < other.px_right
                        && this.px_right > other.px_left
                        && this.px_top < other.px_bottom
                        && this.px_bottom > other.px_top
                    )
                    {
                        console.log( "COLLISION:", other.id );
                        collisions.push( other );
                    }
                }
            }

            return [ boundaries, hit_solid, collisions ];
        }
    }

    //! Class to manage a pool of missiles, via launch requests
    class MissileManager
    {
        constructor( id, max_pool_size = 16 )
        {
            this.id = id;
            this.active_missiles = new Set();
            this.inactive_missiles = new Set();
            this.max_pool_size = max_pool_size;
        }

        launch(
            start_px_i,
            start_px_j,
            angle_in_rads,
            px_per_sec,
            max_dist,
            owning_sprite_type,
            flip_x,
            ascii_code,
            col = DEFAULT_FG_COL,
            all_solid_blocks = true
        )
        {
            // If max number of missiles already in flight,
            // return failure
            if( this.active_missiles.size >= this.max_pool_size )
            {
                return false;
            }

            // Quality checks
            if( !isFinite( ascii_code )
                ||  ascii_code < 0
                || ascii_code > ASCII_DATA.length )
            {
                console.log( "Error in MissileManager.launch:",
                             "ascii_code", ascii_code,
                             "out-of-range, must be 0 to",
                             ASCII_DATA.length );
                return;
            }
            if( !isFinite( start_px_i )
                || start_px_i < 0
                || start_px_i >= PIXELS_WIDE
                || !isFinite( start_px_j )
                || start_px_j < 0
                || start_px_j >= PIXELS_HIGH
            )
            {
                console.log( "Error in MissileManager.launch:",
                             "start virtual pixel pos (",
                             start_px_i, start_px_j,
                             ") is not within main game window." );
                return;
            }

            // Get (or create) a missile
            let missile = 0;
            if( this.inactive_missiles.size == 0 )
            {
                // Create new missile sprite
                missile = new MissileSprite(
                    "" + this.id + "-" + this.active_missiles.size, // id
                    ascii_code,
                    col,
                    owning_sprite_type
                );

                // Add to active missiles
                this.active_missiles.add( missile );
            }
            else
            {
                // Get first element of inactive missile set
                // (i.e. an arbitrary inactive missile)
                [missile] = this.inactive_missiles;
                this.inactive_missiles.delete( missile );

                // Add to active missiles
                this.active_missiles.add( missile );
            }

            // Launch missile
            if( missile !== 0 )
            {
                missile.launch(
                    start_px_i,
                    start_px_j,
                    angle_in_rads,
                    px_per_sec,
                    max_dist,
                    owning_sprite_type,
                    flip_x,
                    ascii_code,
                    col,
                    all_solid_blocks
                );
            }
            else
            {
                console.log( "Failed to get or create missile",
                             "for missile manager", this.id,
                             "for unknown reason." );
                return false;
            }

            return true;
        }
        
        //! Alt launch method using Missile Type (MT) code
        launch_MT(
            missile_type,
            start_px_i,
            start_px_j,
            angle_in_rads,
            owning_sprite_type,
        )
        {
            if( !( missile_type in MISSILE_DATA ) )
            {
                console.log( "Error: Unrecognized missile type:",
                             missile_type, "cannot launch." );
                return;
            }

            // Get reference to row in missile data
            const MD = MISSILE_DATA[missile_type];

            let col = CW ? COL_4_FG_0 : COL_16_WHT;
            // For enemies, get colo(u)r from palette(s)
            // TODO: Consider checking level palette also
            if( owning_sprite_type != SPRITE_TYPE_PLAYER
                && ( MD[MD_COL_NAME] in DEFAULT_PALETTE )
            )
            {
                col = CW ? COL_4_FG_2 : DEFAULT_PALETTE[MD[MD_COL_NAME]];
                
            }

            const RANGE_BONUS
                = owning_sprite_type === SPRITE_TYPE_PLAYER ?
                    player_range_bonus : 0;

            const SPEED_BONUS
                = owning_sprite_type === SPRITE_TYPE_PLAYER ?
                    player_missile_speed_bonus : 0;
                
            return this.launch(
                start_px_i,
                start_px_j,
                angle_in_rads,
                MD[MD_COL_PXPS] + SPEED_BONUS,
                MD[MD_COL_RANGE_IN_PX] + RANGE_BONUS,
                owning_sprite_type,
                Math.floor( angle_in_rads / Math.PI ) % 2 == 1,
                MD[MD_COL_ASCII],
                col,
                true  // all missiles block by 'all solid blocks'
            );
        }

        //! Move missiles and check for collisions
        /*! @param collidables: array of sprites to check for collision with
            @param current_ticks: time point (-1 to get this from Date.now() )
            @returns: Array of sprites in 'collidables' collided with
            Note: automatically makes inactive any missile involved in a collsion. 
        */
        process( collidables = [], current_ticks = -1 )
        {
            // console.log( "process missile manager" );

            let collisions = [];

            let spent_missiles = [];

            for( const MISSILE of this.active_missiles )
            {
                const RESULTS = MISSILE.process( collidables, current_ticks );

                // Get array of boundaries collided with
                const BOUNDARIES = RESULTS[0];

                // Get flag for collision with solid character
                const HIT_SOLID = RESULTS[1];

                // Get array of sprites in 'collidables' collided with
                const SPRITE_COLLISIONS = RESULTS[2];

                // If any collision occurs, destroy missile
                if( BOUNDARIES.length > 0
                    || HIT_SOLID
                    || SPRITE_COLLISIONS.length > 0
                )
                {
                    MISSILE.park();
                    spent_missiles.push( MISSILE );
                }

                if( SPRITE_COLLISIONS.length > 0 )
                {
                    collisions.push( SPRITE_COLLISIONS );
                }
            }

            // Safer to perform deletions from 'active_missiles'
            // whilst not iterating over it in loop above.
            for( let n = 0; n < spent_missiles.length; n++ )
            {
                this.active_missiles.delete( spent_missiles[n] );
                this.inactive_missiles.add( spent_missiles[n] );
            }

            return collisions;
        }
    }

    // END OF CLASS DEFS
    ///////////////////////////////////////////
    

    ///////////////////////////////////////////
    // CREATE EVENT HANDLER(S)

    mouse_init_audio = function()
    {
        // Make sure this is only called once
        if( audio_context != 0
            || game_state != GAME_STATE_AWAITING_MOUSE_CLICK
        ) { return; }
        
        console.log( "mouse_init_audio" );

        // Initialize audio
        init_audio();

        // Remove click listener as no longer required
        document.removeEventListener( 'click', mouse_init_audio );

        // Start game by launching title screen
        title_screen( INTRO_TEXT_COL, 192, 128, 32 );
    }

    handleKeyEvent = function(e)
    {
        // Initialize audio context and oscilator only once 
        // a key has been pressed, as many browsers forbid
        // audio from playing unless the user has interacted
        // with the web page
        if( audio_context == 0 ) { init_audio(); }

        // Get key code
        const C = `${e.code}`;

        // Hit enter to quit on game completion screen
        if( current_level === 3 && C == "Space" )
        {
            // End of game...

            // Stop audio
            audio_cancel_all_FX();
            audio_stop_theme();

            // Stop main loop
            clearInterval( main_loop_interval_id );
            main_loop_interval_id = 0;

            // Reset level number
            current_level = 0;
            start_level = 0;

            // Reset everything else
            reset_vars_for_new_game();

            // Go to menu screen
            menu_screen();

            // If program flow returns here, exit this function.
            return;
        }

        // Check for mute
        if( C == "KeyM" && game_state !== GAME_STATE_SELECT_LEVEL )
        {
            audio_mute = ( audio_mute + 1 ) % MUTE_STATUS_MAX;

            switch( audio_mute )
            {
                case MUTE_STATUS_FULL_AUDIO:
                    unmute();
                    break;

                case MUTE_STATUS_FX_ONLY:
                    mute_theme();
                    break;

                case MUTE_STATUS_MUTE_ALL:
                    mute();
                    break;

                default:
                    console.log( "Error: unknown mute status:",
                                 audio_mute );
            }

            return;
        }
        
        if( game_state == GAME_STATE_POP_UP )
        {
            if( C == "Enter" || C == "Escape" )
            {
                // Hide pop-up
                pop_up_div.style.visibility = "hidden";

                // If other new things exist,
                // create next pop up
                if( new_thing_pop_up() )
                {
                    // If another pop-up scheduled then exit
                    // here as we do *not* want to unpause
                    return;
                }

                // Return to pause state
                game_state = GAME_STATE_PLAY_PAUSED;

                unpause();
            }

            return;
        }
        else if( game_state == GAME_STATE_AWAITING_RESTART )
        {
            if( C == "Enter" || C == "Escape" )
            {
                // Hide pop-up
                pop_up_div.style.visibility = "hidden";

                // Restore armo(u)r to max
                player_armor_remaining = player_max_armor;
                stat_bar_armor();

                // Restart level
                draw_level(
                    current_level,
                    CANV_CHARS_CTX,
                    current_screen_i,
                    current_screen_j,
                    player_sprite.last_checkpoint[0],
                    player_sprite.last_checkpoint[1],
                    player_sprite.last_checkpoint[2]
                );
            }

            return;
        }

        // Check for instruction to open in-game pause menu
        if( game_state == GAME_STATE_IN_PLAY
            && ( C == "Escape" )
        )
        {
            // Pause game
            pause();

            pop_up( 
                "Hit a number",
                [ "1 View level map",
                  "",
                  "2 See known foes",
                  "",
                  "3 Toggle game tips",
                  "",
                  "4 Quit game",
                  "",
                  "M to toggle "
                    + String.fromCharCode( MUTE_ASCII ) + "/"
                    + String.fromCharCode( FX_ONLY_ASCII ) + "/"
                    + String.fromCharCode( NO_MUTE_ASCII )
                ],
                "Esc to return"
            );

            // This must come after 'pop_up' method,
            // as 'pop_up' overwrites game state.
            game_state = GAME_STATE_PAUSE_MENU;

            return;
        }

        // Process actions during pause menu
        if( game_state == GAME_STATE_PAUSE_MENU )
        {
            switch( C )
            {
                // Return to game
                case "Escape":
                    
                    // Hide pop-up
                    pop_up_div.style.visibility = "hidden";
                    
                    // Change to pause state 
                    // (otherwise 'unpause' will ignore request)
                    game_state = GAME_STATE_PLAY_PAUSED;

                    // Resume game
                    unpause();

                    break;

                // Draw level map
                case "Digit1":
                    map_pop_up();
                    break;

                // Foe list
                case "Digit2":

                    console.log( "All foes", known_enemy_types );

                    stat_bar_alert( "PAUSE" );

                    new_enemy_types.clear();
                    for( const enemy_type of known_enemy_types )
                    {
                        new_enemy_types.add( enemy_type );
                    }

                    new_thing_pop_up();
                    break;

                // Game tips on/off
                case "Digit3":
                    game_tips = !game_tips;
                    stat_bar_alert(
                        "Game tips: " 
                            + ( game_tips ? "ON" : "OFF" )
                    );
                    break;

                // Quit
                case "Digit4":
                    stat_bar_alert( "Quit game (y/n)" );
                    game_state = GAME_STATE_QUIT_OPTION;
                    break;
            }
            
            return;
        }

        if( game_state == GAME_STATE_COMPLETED_LEVEL
            && ( C == "Enter" || C == "Escape" )
        )
        {
            // Present 'cheat' code
            draw_screen( GAME_STATE_BONUS_FINISHED,
                         [ "To return to this point", 
                           "in future browser",
                           "sessions, carefully",
                           "write down this code:",
                           "",
                           "" + recalc()
                         ],
                         "hit enter"
                       );
            return;
        }

        // Check for in-game level restart key
        if( game_state == GAME_STATE_IN_PLAY
            && player_lives > 1  // This option costs a life
            && C == "KeyR"
        )
        {
            // Pause game (no need to update stat bar here)
            pause( false );

            game_state = GAME_STATE_RESTART_OPTION;

            // Confirm quit question on stat bar
            stat_bar_alert( "Restart level (y/n)" );

            return;
        }

        // If key handling delay, ignore key stoke for now
        if( key_handling_delay ) { return; }

        // If game is in play, process key actions
        if( game_state == GAME_STATE_IN_PLAY )
        {
            // Get current time, in ticks
            const TICKS = Date.now();
            
            // Calculate ticks elapsed since last player move
            const TICKS_SINCE_LAST_PLAYER_MOVE
                = player_sprite.prev_move_ticks < 0 ?
                    TICKS : TICKS - player_sprite.prev_move_ticks;
           
            // Check for pause
            if( C == "KeyP" )
            {
                pause();
                return;
            }

            // Launch missile
            if( C == "Space" )
            {
                if( player_sprite.prev_launch_ticks == -1
                    || player_sprite.prev_launch_ticks
                        + player_ticks_per_launch < TICKS
                )
                {
                    // Attempt to launch missile
                    // (may fail due to too many missiles in flight)
                    if( player_missile_man.launch_MT(
                            MT_SWORD,
                            player_sprite.px_left,
                            player_sprite.px_top,
                            DIR_IN_RADS[player_sprite.dir],
                            SPRITE_TYPE_PLAYER,
                        )
                    )
                    {
                        // Play launch FX
                        audio_play_FX( 'launch' );

                        // Only update this if launch succeeds
                        player_sprite.prev_launch_ticks = TICKS;
                    }
                }
            }

            let successful_move = false;
           
            // Left/right moves are permitted immediately after
            // an up move, therefore have different logic
            // to the up/down movement checks.
            if( player_sprite.last_move_up 
                || ( player_sprite.chars_fallen == 0
                    && TICKS_SINCE_LAST_PLAYER_MOVE
                            >= player_sprite.ticks_per_move
                )
            )
            {
                console.log( "player pos",
                             player_sprite.char_i,
                             player_sprite.char_j );

                // Move right
                if ( C == "KeyD" || C == "KeyL" || C == "ArrowRight" )
                {
                    if( player_sprite.dir == DIR_LEFT )
                    {
                        player_sprite.dir = DIR_RIGHT;
                        player_sprite.redraw( false );
                        return;
                    }

                    player_sprite.dir = DIR_RIGHT;
                    
                    // If right edge of screen and there is
                    // a screen to the right, start transition
                    // to next screen
                    if( player_sprite.char_i == CHARS_WIDE - 1
                        && current_screen_i
                            < LEVEL_DIMS[current_level][0] - 1 
                    )
                    {
                        console.log( "Swipe right" );

                        screen_transition( DIR_RIGHT );
                        return;
                    }
                    // Otherwise treat as regular move
                    else if( 
                         can_move_right( player_sprite )
                         && ( on_solid_ground( player_sprite )
                              // This clause permits hoz move on
                              // ladder, even if no ground below
                              || on_ladder( player_sprite )
                              // This clause permits hoz 'jump' mid-air
                              || ( player_sprite.last_move_up 
                                   && TICKS_SINCE_LAST_PLAYER_MOVE
                                         <  player_sprite.ticks_per_move * 2                              
                             )      
                        )
                    )
                    {
                        // Add 'scent trail'
                        if( scent_sprite === player_sprite )
                        {
                            get_char( player_sprite ).scent = DIR_RIGHT;
                        }

                        if( !blocked( player_sprite, 1, 0 )
                            && player_sprite.move_relative( 1, 0 )
                        )
                        {
                            // If move successful, adjust char position
                            // player_sprite.char_i += 1;

                            player_sprite.last_move_up = false;
                
                            successful_move = true;
                        }
                    }
                }
                // Move left
                else if ( ( C == "KeyA" || C == "KeyJ" || C == "ArrowLeft" ) )
                {
                    if( player_sprite.dir == DIR_RIGHT )
                    {
                        player_sprite.redraw( true );
                        player_sprite.dir = DIR_LEFT;
                        return;
                    }

                    // If left edge of screen and there is
                    // a screen to the left, start transition
                    // to next screen
                    if( player_sprite.char_i == 0
                            && current_screen_i > 0
                    )
                    {
                        console.log( "Swipe left" );

                        screen_transition( DIR_LEFT );
                        return;
                    }
                    // Otherwise treat as regular move
                    else if( 
                          can_move_left( player_sprite )
                          && ( on_solid_ground( player_sprite )
                              // This clause permits hoz move on
                              // ladder, even if no ground below
                              || on_ladder( player_sprite )
                               // This clause permits hoz 'jump' mid-air
                               || ( player_sprite.last_move_up 
                                    && TICKS_SINCE_LAST_PLAYER_MOVE
                                          <  player_sprite.ticks_per_move * 2                              
                                  )
                          )
                    )
                    {
                        // Add 'scent trail'
                        if( scent_sprite === player_sprite )
                        {
                            get_char( player_sprite ).scent = DIR_LEFT;
                        }

                        if( !blocked( player_sprite, -1, 0 )
                            && player_sprite.move_relative( -1, 0 )
                        )
                        {
                            // If move successful, adjust char position
                            // player_sprite.char_i -= 1;

                            player_sprite.last_move_up = false;

                            successful_move = true;
                        }
                    }
                }
            }

            if( !successful_move
                && player_sprite.chars_fallen == 0
                && TICKS_SINCE_LAST_PLAYER_MOVE
                        >= player_sprite.ticks_per_move
            )
            {
                // Move down
                if ( ( C == "KeyS" || C == "KeyK" || C == "ArrowDown" ) )
                {
                    /*
                    console.log( "MOVE DOWN: pos",
                                 player_sprite.char_i,
                                 player_sprite.char_j,
                                 "MAX J", CHARS_HIGH - 1,
                                 "screen_j", current_screen_j,
                                 "level dims",
                                 LEVEL_DIMS[current_level],
                                 player_sprite.char_j == CHARS_HIGH - 1,
                                 current_screen_j < LEVEL_DIMS[current_level][1] - 1 );
                    */

                    // If bottom edge of screen and there is
                    // a screen below, start transition
                    // to next screen
                    if( player_sprite.char_j == CHARS_HIGH - 1
                            && current_screen_j 
                                < LEVEL_DIMS[current_level][1] - 1
                    )
                    {
                        console.log( "Swipe down" );

                        screen_transition( DIR_DOWN );
                        return;
                    }
                    // Otherwise treat as regular move
                    else if( !blocked( player_sprite, 0, 1 )
                             && can_descend( player_sprite ) 
                    )
                    {
                        // Add 'scent trail'
                        if( scent_sprite === player_sprite )
                        {
                            get_char( player_sprite ).scent = DIR_DOWN;
                        }

                        if( player_sprite.move_relative( 0, 1 ) )
                        {
                            // If move successful, adjust char position
                            // player_sprite.char_j += 1;

                            player_sprite.last_move_up = false;

                            successful_move = true;
                        }
                    }
                }
                // Move up
                else if ( ( C == "KeyW" || C == "KeyI" || C == "ArrowUp" ) )
                {
                    // If top edge of screen and there is
                    // a screen above, start transition
                    // to next screen
                    if( player_sprite.char_j == 0
                            && current_screen_j > 0
                    )
                    {
                        console.log( "Swipe up" );

                        screen_transition( DIR_UP );
                        return;
                    }
                    // Otherwise treat as regular move
                    else if( !blocked( player_sprite, 0, -1 )
                             && ( on_ladder( player_sprite )
                                  || on_solid_ground( player_sprite )
                             ) && can_move( player_sprite, DIR_UP )
                    )
                    {
                        // Add 'scent trail'
                        if( scent_sprite === player_sprite )
                        {
                            get_char( player_sprite ).scent = DIR_UP;
                        }

                        if( player_sprite.move_relative( 0, -1 ) )
                        {
                            // If move successful, adjust char position
                            // player_sprite.char_j -= 1;

                            player_sprite.last_move_up = true;

                            successful_move = true;
                        }
                    }
                }
            }

            // Post move processing
            if( successful_move )
            {
                // Check for end of level
                if( check_for_end_of_level() ) { return; }

                // Check for deadly player collisions
                if( check_for_deadly_item_collision() ) { return; }
                if( check_for_player_enemy_collision() ) { return; }

                // Check for player collision with checkpoint
                check_for_player_checkpoint();
                
                // Check for special pop-up tips
                check_for_special_tip();

                // Check for collectable
                // Note: this must be done *after* char indices
                //       (i.e.. char_i and /or char_j) updated
                check_for_collectable();

                // Update time of last move
                player_sprite.prev_move_ticks = TICKS;
            }
        }  // End of in-play key handling
        else 
        {
            // Handle non-play keypress events
            switch( game_state )
            {
                case GAME_STATE_PLAY_PAUSED:
                        if( C == "KeyP" )
                        {
                            unpause();
                            return;
                        }
                        break;
                        
                case GAME_STATE_TITLE:
                    if ( C == "Enter" ) { blerb_screen(); }
                    break;

                case GAME_STATE_BLERB:
                    if ( C == "Enter" ) { menu_screen(); }
                    break;

                case GAME_STATE_MENU:
                    switch( C )
                    {
                        case "Digit1":
                            instruction_screen_1();
                            break;

                        case "Digit2":
                            reset_vars_for_new_game();
                            current_level = 0;
                            start_level = 0;
                            level_intro_screen( 0 );
                            break;

                        case "Digit3":
                            select_level_screen();
                            break;

                        case "Digit4":
                            about_screen();
                            break;

                        default:
                            console.log( "Unrecognized menu choice", C );
                            return;
                    }
                
                case GAME_STATE_INSTRUCTIONS_1:
                    if ( C == "Enter" ) { instruction_screen_2(); }
                    break;

                case GAME_STATE_INSTRUCTIONS_2:
                    if ( C == "Enter" ) { instruction_screen_3(); }
                    break;

                case GAME_STATE_INSTRUCTIONS_3:
                    if ( C == "Enter" ) { instruction_screen_4(); }
                    break;

                case GAME_STATE_INSTRUCTIONS_4:
                    if ( C == "Enter" ) { menu_screen(); }
                    break;

                case GAME_STATE_SELECT_LEVEL:
                    select_level( C );
                    break;

                case GAME_STATE_ABOUT:
                    if( C == "Enter" || C == "Escape" )
                    {
                        menu_screen();
                    }
                    break;

                case GAME_STATE_LEVEL_INTRO:
                    if ( C == "Enter" )
                    {
                        audio_stop_theme();

                        reset_vars_for_new_level();

                        draw_level( current_level );

                        /*
                        // DEBUG TO START AT SPECIFIED SCREEN
                        if( current_level == 1 )
                        {
                            current_screen_i = 2;
                            current_screen_j = 1;
                            draw_level(
                                current_level,
                                CANV_CHARS_CTX,
                                current_screen_i,
                                current_screen_j,
                                19, // player_i
                                10 // player_j
                            );
                        }
                        else
                        {
                            draw_level( current_level );
                        }
                        */
                    }
                    break;

                case GAME_STATE_GAME_OVER:
                    if ( C == "Enter" ) { menu_screen(); }
                    break;

                case GAME_STATE_BONUS_FINISHED:
                    if( C == "Enter" || C == "Escape" )
                    {
                        level_intro_screen( current_level );
                    }
                    break;

                case GAME_STATE_QUIT_OPTION:
                    if( C == "KeyY" )
                    {
                        // Hide pause menu which will be
                        // visible at this point
                        pop_up_div.style.visibility = 'hidden';

                        // Game over
                        game_over_screen();
                        return;
                    }
                    else
                    {
                        // Return stat bar to previous state
                        stat_bar_alert( "PAUSED" );

                        game_state = GAME_STATE_PAUSE_MENU;

                        return;
                    }
                    break;

                case GAME_STATE_RESTART_OPTION:
                    if( C == "KeyY" )
                    {
                        // Return game status to in-play
                        // (this must be done before stat
                        //  bar is updated)
                        game_state = GAME_STATE_IN_PLAY;

                        // Return stat bar to normal status
                        stat_bar_update();

                        // Call life lost routine with
                        // 'true' parameter to indicate level
                        // restart required
                        player_loses_life( true );
                        return;
                    }
                    else if( C == "KeyN" )
                    {
                        // This is important otherwise
                        // 'unpause' will ignore request
                        game_state = GAME_STATE_PLAY_PAUSED;

                        // Restart game
                        unpause();

                        return;
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_WITH_CHEATS:
                    if ( C == "Enter" )
                    {
                        audio_stop_theme();
                        menu_screen();
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS:
                    if ( C == "Enter" )
                    {
                        audio_stop_theme();
                        menu_screen();
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_SEQUENCE:
                    // No action
                    break;

                default:
                    console.log( "Error: unrecognized",
                                 "non-play game state",
                                 game_state );
                    return;
                    // console.log( "Defaulting draw_level'." );
                    // draw_level( 0 );
            }
        }
    }
    // END OF EVENT HANDLERS
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // PRE-SIZE CHARACTER arrays

    // Create (empty) array to hold main play area characters
    for( let j = 0; j < CHARS_HIGH; j++ )
    {
        // Add new line to char array
        chars.push( [] );

        // Get reference to line
        const LINE = chars[j];

        // Add new char to line
        for( let i = 0; i < CHARS_WIDE ; i++ )
        {
            LINE.push( new character( i, j ) );
        }
    }
    
    // Create (empty) array to hold stat bar characters
    {
        // Add one line to char array
        sb_chars.push( [] );

        // Get reference to line
        const LINE = sb_chars[0];

        // Add new char to line
        for( let i = 0; i < CHARS_WIDE; i++ )
        {
            LINE.push( new character( i, 0 ) );
        }
    }

    /////////////////////////////////////////////////
    // GAME LAUNCHES FROM HERE
    mouse_activation_screen();
    /////////////////////////////////////////////////
}
</script>
<style>

body
{
    background-color: black;
    font-size: 32px;
    color: white
}

button
{
    display: block;
    background-color: gray;
    color: black;
    width: 80%;
    padding: 15px 32px;
    text-align: center;
    // text-decoration: bold;
    font-size: 28px;
    border: 4px solid magenta;
    margin-bottom: 12px;
}

button:hover
{
    background-color: white;
}

</style>
<body padding="0px 0px 0px 0px"><div>
<div id="color_way_select" align="center">
<p>Choose color mode</p>
<button onclick="game(true)"><b>EGA palette (4 color)</b></button>
<button onclick="game(false)"><b>CGA palette (16 color)<b></button>
</div>
</div></body>
</html>
